---
path: '/ru/part-6/4-scope-of-variables'
title: 'Локальные и глобальные переменные'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы узнаете, что подразумевается под локальной переменной
- Вы узнаете, как область видимости переменной влияет на то, как она используется
- Вы узнаете, что означает ключевое слово Python `global`
- Вы сможете использовать локальные и глобальные переменные в правильных контекстах

</text-box>

_Область видимости_ переменной относится к разделам программы, где переменная доступна. _Локальная_ переменная доступна только в определенной части программы, в то время как _глобальная_ переменная доступна для использования в любом разделе программы.

## Локальные переменные

Переменные, определенные внутри функции Python, являются локальными переменными, доступными только внутри функции. Это относится как к параметрам функции, так и к другим переменным, определенным в определении функции. Переменная, которая является локальной для функции, _не существует вне функции_.

В следующем примере мы пытаемся получить доступ к переменной `x` в основной функции, но это вызывает ошибку:

```python
def testing():
    x = 5
    print(x)

testing()
print(x)
```

<sample-output>

5
NameError: name 'x' is not defined

</sample-output>

Переменная `x` существует только во время выполнения функции `testing`. Другие функции или основная функция не могут получить доступ к переменной.

## Глобальные переменные

Переменные, определенные внутри основной функции, являются глобальными переменными. Мы ранее определили основную функцию как те разделы кода в программе Python, которые не попадают ни в какую другую функцию. Значение, сохраненное в глобальной переменной, можно получить из любой другой функции в программе, поэтому следующее не вызывает никаких ошибок:

```python
def testing():
    print(x)

x = 3
testing()
```

<sample-output>

3

</sample-output>

Глобальную переменную нельзя изменить напрямую изнутри другой функции. Следующая функция _не влияет_ на значение, сохраненное в глобальной переменной:

```python
def testing():
    x = 5
    print(x)

x = 3
testing()
print(x)
```

<sample-output>

5
3

</sample-output>

Здесь функция `testing` создает _новую, локальную_ переменную `x`, которая "маскирует" глобальную переменную во время выполнения функции. Эта переменная имеет значение 5, но это другая переменная, чем глобальная `x`, которая определена в основной функции.

Но что бы делал следующий код?

```python
def testing():
    print(x)
    x = 5

x = 3
testing()
print(x)
```

<sample-output>

UnboundLocalError: local variable 'x' referenced before assignment

</sample-output>


Функция `testing` присваивает значение переменной `x`, поэтому Python интерпретирует `x` как локальную переменную вместо глобальной переменной с тем же именем. Функция пытается получить доступ к переменной до ее определения, поэтому возникает ошибка.

Если мы хотим указать, что мы намерены изменить глобальную переменную внутри функции, нам понадобится ключевое слово Python `global`:

```python
def testing():
    global x
    x = 3
    print(x)

x = 5
testing()
print(x)
```

<sample-output>

3
3

</sample-output>

Теперь присваивание `x = 3` внутри функции также влияет на основную функцию. Все разделы программы используют одну и ту же глобальную переменную `x`.

## Когда следует использовать глобальные переменные?

Глобальные переменные - это не способ обойти параметры функции или возвращаемые значения, и их не следует использовать таким образом. То есть, _возможно_ написать функцию, которая сохраняет свои результаты непосредственно в глобальной переменной:

```python
def calculate_sum(a, b):
    global result
    result = a + b

calculate_sum(2, 3)
print(result)
```

Лучше написать функцию с возвращаемым значением, как мы привыкли делать к настоящему времени:

```python
def calculate_sum(a, b):
    return a + b

result = calculate_sum(2, 3)
print(result)
```

Преимущество последнего подхода заключается в том, что функция является _независимым_ целым. У нее есть определенные, заданные параметры, и она возвращает результат. У нее нет побочных эффектов, поэтому ее можно тестировать и изменять независимо от других разделов программы.

Глобальные переменные полезны в ситуациях, когда нам нужно иметь некоторую общую информацию "более высокого уровня", доступную всем функциям в программе. Следующий пример как раз такой ситуации:

```python
def calculate_sum(a, b):
    global count
    count += 1
    return a + b

def calculate_difference(a, b):
    global count
    count += 1
    return a - b


count = 0
print(calculate_sum(2, 3))
print(calculate_sum(5, 5))
print(calculate_difference(5, 2))
print(calculate_sum(1, 0))
print("There were", count, "function calls")
```

<sample-output>

5
10
3
1
There were 4 function calls

</sample-output>

В этом случае мы хотим отслеживать, сколько раз любая из функций была вызвана во время выполнения программы. Глобальная переменная `count` полезна здесь, потому что мы можем увеличивать ее из самих функций по мере их выполнения, но все же получать доступ к окончательному значению в основной функции.

## Передача данных от одной функции к другой, пересмотр

<!--- см. также раздел 4-6, значительное перекрытие-->
Если программа состоит из нескольких функций, часто возникает вопрос передачи данных от одной функции к другой.

Когда мы затрагивали эту тему [ранее](/ru/part-4/6-strings-and-lists#passing-data-from-one-function-to-another), у нас была программа, которая просит пользователя ввести некоторые целочисленные значения, выводит их и выполняет статистический анализ чисел. Программа была разделена на три отдельные функции:

```python
def input_from_user(how_many: int):
    print(f"Please type in {how_many} numbers:")
    numbers = []

    for i in range(how_many):
        number = int(input(f"Number {i+1}: "))
        numbers.append(number)

    return numbers

def print_result(numbers: list):
    print("The numbers are: ")
    for number in numbers:
        print(number)

def analyze(numbers: list):
    mean = sum(numbers) / len(numbers)
    return f"There are altogether {len(numbers)} numbers, the mean is {mean}, the smallest is {min(numbers)} and the greatest is {max(numbers)}"

# the main function using these functions
inputs = input_from_user(5)
print_result(inputs)
analysis_result = analyze(inputs)
print(analysis_result)
```

Пример выполнения программы:

<sample-output>

Please type in 5 numbers:
Number 1: 10
Number 2: 34
Number 3: -32
Number 4: 99
Number 5: -53
The numbers are:
10
34
-32
99
-53
There are altogether 5 numbers, the mean is 11.6, the smallest is -53 and the greatest is 99

</sample-output>

Основной принцип здесь заключается в том, что главная функция "хранит" данные, обрабатываемые программой. Здесь это означает числа, введенные пользователем, которые хранятся в переменной `inputs`.

Если числа нужны в какой-то функции, переменная передается как аргумент, как видно выше при вызове функций `print_result` и `analyze`. Если функция производит результат, который важен в другом месте программы, функция возвращает его с оператором `return`, как видно с функциями `input_from_user` и `analyze` выше.

Как всегда в программировании, есть много способов достичь той же функциональности. Было бы возможно использовать ключевое слово `global` и заставить функции напрямую обращаться к переменной `inputs`, определенной в основной функции. Однако есть веские причины, почему [это не умное решение](https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil). Если множество различных функций могут обращаться и потенциально изменять переменную напрямую, быстро становится невозможно надежно отслеживать состояние программы, и программа рискует стать непредсказуемой. Это особенно актуально, когда количество задействованных функций растет, как это обычно происходит в крупных программных проектах.

В заключение, передача данных в функции и из функций лучше всего обрабатывается аргументами и возвращаемыми значениями.

Вы также можете отделить неявную основную функцию в приведенном выше примере в свою собственную, явную функцию `main`. Тогда переменная `inputs` больше не будет глобальной переменной, а вместо этого будет локальной переменной в функции `main`:

```python
# your main function goes here
def main():
    inputs = input_from_user(5)
    print_result(inputs)
    analysis_result = analyze(inputs)

    print(analysis_result)

# run the main function
main()
```

<!---
Викторина для проверки содержания этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->

Пожалуйста, ответьте на краткую анкету по материалам этой недели.

<quiz id="979b7162-29ef-5fd8-816b-cf1ff80eff23"></quiz>