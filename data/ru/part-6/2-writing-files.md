---
path: '/ru/part-6/2-writing-files'
title: 'Запись файлов'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы узнаете, как создавать файлы с помощью кода Python
- Вы сможете записывать текстовые данные в файл
- Вы узнаете, как создать CSV-файл

</text-box>

До сих пор мы читали данные из файлов, но, естественно, также возможно записывать данные в файлы. Обычно программа обрабатывает данные и сохраняет результаты в файле, чтобы их можно было использовать позже или обрабатывать дальше другой программой.

Мы можем создавать новый файл каждый раз, когда хотим записать данные в файл, но также можем добавлять новые данные в конец существующего файла. В обоих случаях мы используем функцию `open` из предыдущего раздела. Для записи файлов функция требует второй аргумент.

## Создание нового файла

Если вы хотите создать новый файл, вы бы вызвали функцию `open` с дополнительным аргументом `w`, чтобы указать, что файл должен быть открыт в режиме записи. Итак, вызов функции может выглядеть так:

```python
with open("new_file.txt", "w") as my_file:
    # code to write something to the file
```

**Примечание: если файл уже существует, все содержимое будет перезаписано**. Стоит быть очень осторожным при создании новых файлов.

С открытым файлом вы можете записывать в него данные. Вы можете использовать метод `write`, который принимает строку, которую нужно записать, в качестве аргумента.

```python
with open("new_file.txt", "w") as my_file:
    my_file.write("Hello there!")
```

Когда вы выполняете программу, новый файл с именем `new_file.txt` появляется в директории. Содержимое будет выглядеть так:

<sample-data>

Привет!

</sample-data>

Если вы хотите переносы строк в файле, вам нужно будет добавить их вручную - функция `write` работает не совсем как более знакомая функция `print`, хотя они похожи. Итак, следующая программа

```python
with open("new_file.txt", "w") as my_file:
    my_file.write("Hello there!")
    my_file.write("This is the second line")
    my_file.write("This is the last line")
```

приведет к файлу с таким содержимым:

<sample-data>

Привет!Это вторая строкаЭто последняя строка

</sample-data>

Переносы строк достигаются добавлением символов новой строки `\n` к аргументам строк:

```python
with open("new_file.txt", "w") as my_file:
    my_file.write("Hello there!\n")
    my_file.write("This is the second line\n")
    my_file.write("This is the last line\n")
```

Теперь содержимое `new_file.txt` будет выглядеть так:

<sample-data>

Привет!
Это вторая строка
Это последняя строка

</sample-data>

<programming-exercise name='Надпись' tmcname='part06-10_inscription'>

Пожалуйста, напишите программу, которая спрашивает имя пользователя, а затем создает "надпись" в файле, указанном пользователем. Пожалуйста, посмотрите пример ниже.

<sample-output>

Whom should I sign this to: **Ada**
Where shall I save it: **inscribed.txt**

</sample-output>

Содержимое файла `inscribed.txt` было бы

<sample-data>

Hi Ada, we hope you enjoy learning Python with us! Best, Mooc.fi Team

</sample-data>

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

## Добавление данных в существующий файл

Если вы хотите добавить данные в конец файла, вместо перезаписи всего файла, вы должны открыть файл в режиме добавления с аргументом `a`.

Если файл еще не существует, режим добавления работает точно так же, как режим записи.

Следующая программа открывает файл `new_file.txt` и добавляет пару строк текста в конец:

```python
with open("new_file.txt", "a") as my_file:
    my_file.write("This is the 4th line\n")
    my_file.write("And yet another line.\n")
```

После выполнения этой программы содержимое файла будет выглядеть так:

<sample-output>

Hello there!
This is the second line
This is the last line
This is the 4th line
And yet another line.

</sample-output>

В практике программирования добавление данных в файлы не очень распространенная задача.

Чаще файл читается, обрабатывается и перезаписывается полностью. Например, когда содержимое должно измениться в _середине_ файла, обычно проще всего перезаписать весь файл.

<programming-exercise name='Дневник' tmcname='part06-11_diary'>

Пожалуйста, напишите программу, которая работает как простой дневник. Записи дневника должны сохраняться в файле `diary.txt`. Когда программа выполняется, она должна сначала прочитать любые записи, уже находящиеся в файле.

Примечание: автоматические тесты для этого упражнения изменят содержимое файла. Если вы хотите сохранить его содержимое, сначала сделайте копию файла под другим именем.

Программа должна работать следующим образом:

<sample-output>

1 - add an entry, 2 - read entries, 0 - quit
Function: **1**
Diary entry: **Today I ate porridge**
Diary saved

1 - add an entry, 2 - read entries, 0 - quit
Function: **2**
Entries:
Today I ate porridge
1 - add an entry, 2 - read entries, 0 - quit
Function: **1**
Diary entry: **I went to the sauna in the evening**
Diary saved

1 - add an entry, 2 - read entries, 0 - quit
Function: **2**
Entries:
Today I ate porridge
I went to the sauna in the evening
1 - add an entry, 2 - read entries, 0 - quit
Function: **0**
Bye now!

</sample-output>

Когда программа выполняется во второй раз, должно происходить следующее:

<sample-output>

1 - add an entry, 2 - read entries, 0 - quit
Function: **2**
Entries:
Today I ate porridge
I went to the sauna in the evening
1 - add an entry, 2 - read entries, 0 - quit
Function: **0**
Bye now!

</sample-output>

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

## Запись CSV-файлов

CSV-файлы можно записывать строка за строкой с помощью метода `write` точно так же, как любой другой файл. Следующий пример создает файл `coders.csv`, где каждая строка содержит имя, рабочую среду, любимый язык и годы опыта одного программиста. Поля разделены точкой с запятой.

```python
with open("coders.csv", "w") as my_file:
    my_file.write("Eric;Windows;Pascal;10\n")
    my_file.write("Matt;Linux;PHP;2\n")
    my_file.write("Alan;Linux;Java;17\n")
    my_file.write("Emily;Mac;Cobol;9\n")
```

Выполнение этой программы приведет к следующему файлу:

<sample-output>

Eric;Windows;Pascal;10
Matt;Linux;PHP;2
Alan;Linux;Java;17
Emily;Mac;Cobol;9

</sample-output>

Что если данные для записи хранятся в памяти компьютера в списке?

```python
coders = []
coders.append(["Eric", "Windows", "Pascal", 10])
coders.append(["Matt", "Linux", "PHP", 2])
coders.append(["Alan", "Linux", "Java", 17])
coders.append(["Emily", "Mac", "Cobol", 9])
```

Мы можем построить строку, которую хотим записать, как f-строку, и записать готовую строку в файл так:

```python
with open("coders.csv", "w") as my_file:
    for coder in coders:
        line = f"{coder[0]};{coder[1]};{coder[2]};{coder[3]}"
        my_file.write(line+"\n")
```

Если каждый список данных о программисте был очень длинным, с многими другими элементами, построение строки вручную было бы довольно громоздким. Мы можем использовать цикл `for` для построения строки вместо этого:

```python
with open("coders.csv", "w") as my_file:
    for coder in coders:
        line = ""
        for value in coder:
            line += f"{value};"
        line = line[:-1]
        my_file.write(line+"\n")
```

## Очистка содержимого файла и удаление файлов

Иногда необходимо очистить содержимое существующего файла. Открытие файла в режиме записи и немедленное закрытие файла достигнет именно этого:

```python
with open("file_to_be_cleared.txt", "w") as my_file:
    pass
```

Теперь блок `with` содержит только команду `pass`, которая на самом деле ничего не делает. Python не допускает пустых блоков, поэтому команда здесь необходима.

Можно также обойти блок `with`, используя следующую однострочную команду:

```python
open('file_to_be_cleared.txt', 'w').close()
```

<text-box variant='hint' name='Удаление файлов'>

Вы также можете полностью удалить файл. Нам нужно будет попросить помощи у операционной системы для достижения этого:

```python
# the command to delete files is in the os module
import os

os.remove("unnecessary_file.csv")
```

Примечание: это не будет работать при запуске автоматических тестов на серверах курса из-за технических ограничений в среде тестирования. Если вас просят очистить содержимое файла, используйте методы, описанные выше.

</text-box>

<programming-exercise name='Фильтрация содержимого файла' tmcname='part06-12_filtering_file_contents'>

Файл `solutions.csv` содержит некоторые решения математических задач:

```csv
Arto;2+5;7
Pekka;3-2;1
Erkki;9+3;11
Arto;8-3;4
Pekka;5+5;10
...jne...
```

Как видно выше, в каждой строке формат `имя_студента;задача;результат`. Все операции либо сложение, либо вычитание, и каждая имеет точно два операнда.

Пожалуйста, напишите функцию с именем `filter_solutions()`, которая

* Читает содержимое файла `solutions.csv`
* записывает те строки, которые имеют _правильный_ результат, в файл `correct.csv`
* записывает те строки, которые имеют _неправильный_ результат, в файл `incorrect.csv`

Используя пример выше, файл `correct.csv` будет содержать строки 

```sh
Arto;2+5;7
Pekka;3-2;1
Pekka;5+5;10
```

Остальные две будут в файле `incorrect.csv`.

Пожалуйста, запишите строки в том же порядке, в каком они появляются в исходном файле. Не изменяйте исходный файл.

Примечание: функция должна иметь точно такой же результат, независимо от того, сколько раз она вызывается. То есть, не должно иметь значения, вызывается ли функция один раз

```python
filter_solutions()
```

или несколько раз подряд

```python
filter_solutions()
filter_solutions()
filter_solutions()
filter_solutions()
```

После выполнения содержимое файлов `correct.csv` и `incorrect.csv` должно быть точно таким же в любом случае.

</programming-exercise>

<programming-exercise name='Сохранить персональные данные' tmcname='part06-13_store_personal_data'>

Пожалуйста, напишите функцию с именем `store_personal_data(person: tuple)`, которая принимает кортеж, содержащий некоторую идентифицирующую информацию, в качестве аргумента.

Кортеж содержит следующие элементы:

* Имя (строка)
* Возраст (целое число)
* Рост (дробь)

Это должно быть обработано и записано в файл `people.csv`. Файл может уже содержать некоторые данные; новая запись идет в конец файла. Данные должны быть записаны в формате

имя;возраст;рост

Каждая запись должна быть на отдельной строке. Если мы вызываем функцию с аргументом `("Paul Paulson", 37, 175.5)`, функция должна записать эту строку в конец файла:

`Paul Paulson;37;175.5`

</programming-exercise>

## Обработка данных в CSV-формате

Давайте напишем программу, которая оценивает успеваемость студентов на курсе. Программа читает CSV-файл, который содержит еженедельные баллы за упражнения, полученные студентами. Программа затем вычисляет общее количество баллов и определяет оценку, полученную каждым студентом. Наконец, программа создает CSV-файл, содержащий общее количество баллов и оценку для каждого студента.

CSV-файл, подаваемый на вход программы, выглядит так:

<sample-data>

Peter;4;2;3;5;4;0;0
Paula;7;2;8;3;5;4;5
Susan;3;4;3;5;3;4;4
Emily;6;6;5;5;0;4;8

</sample-data>

Логика программы разделена на три функции: чтение файла и обработка содержимого в доступный формат, определение оценки и запись файла.

Файл читается согласно принципам, рассмотренным в предыдущем разделе. Данные сохраняются в словаре, где ключом является имя студента, а значением - список баллов, полученных студентом, в целочисленном формате:

```python
def read_weekly_points(filename):
    weekly_points = {}
    with open(filename) as my_file:
        for line in my_file:
            parts = line.split(";")
            point_list = []
            for points in parts[1:]:
                point_list.append(int(points))
            weekly_points[parts[0]] = point_list

    return weekly_points
```

Вторая функция предназначена для определения оценки на основе полученных баллов. Эта функция в свою очередь используется третьей функцией, которая записывает результаты в файл.

```python
def grade(points):
    if points < 20:
        return 0
    elif points < 25:
        return 1
    elif points < 30:
        return 2
    elif points < 35:
        return 3
    elif points < 40:
        return 4
    else:
        return 5

def save_results(filename, weekly_points):
    with open(filename, "w") as my_file:
        for name, point_list in weekly_points.items():
            point_sum = sum(point_list)
            my_file.write(f"{name};{point_sum};{grade(point_sum)}\n")
```

Эта структура позволяет нам написать очень простую главную функцию. Обратите внимание, как имена файлов для чтения и записи файлов задаются как аргументы в главной функции:

```python
weekly_points = read_weekly_points("weekly_points.csv")
save_results("results.csv", weekly_points)
```

Когда главная функция выполняется, содержимое файла `results.csv`, созданного в результате, выглядит так:

<sample-data>

Peter;18;0
Paula;34;3
Susan;26;2
Emily;41;5

</sample-data>

Обратите внимание, как каждая функция, определенная выше, относительно проста, и все они имеют одну ответственность. Это общий и рекомендуемый подход при программировании больших целых. Принцип единой ответственности облегчает проверку функциональности. Он также облегчает внесение изменений в программу позже и добавление новых функций.

Скажем, мы хотели добавить функцию для вывода оценки одного студента. У нас уже есть функция, которая определяет оценку студента, поэтому мы можем использовать это в нашей новой функции:

```python
def get_grade(student_name, weekly_points):
    for name, point_list in weekly_points.items():
        if name == student_name:
            return grade(sum(point_list))


weekly_points = read_weekly_points("weekly_points.csv")
print(get_grade("Paula", weekly_points))

```

<sample-data>

3

</sample-data>

Если мы определим, что определенная функциональность в программе нуждается в исправлении, в хорошо спроектированной программе изменение повлияет только на некоторые выбранные разделы кода, и будет легче определить, где должны быть сделаны изменения. Например, если бы мы хотели изменить границы оценок, нам нужно было бы только реализовать изменение в функции для определения оценки, и это работало бы также во всех других функциях, использующих эту функцию. Если код для этой единой функциональности был реализован в нескольких местах, существовал бы определенный риск, что мы не запомнили изменить все экземпляры при изменении функциональности.

<programming-exercise name='Оценивание курса, часть 4' tmcname='part06-14_course_grading_part_4'>

Давайте вернемся к проекту оценивания курса из предыдущего раздела.

Как мы оставили его в прошлый раз, программа читала и обрабатывала файлы, содержащие информацию о студентах, выполненных упражнениях и результатах экзамена. Мы добавим файл, содержащий информацию о курсе. Пример формата файла:

<sample-data>

<pre>

name: Introduction to Programming
study credits: 5
</pre>

</sample-data>

Программа должна затем создать два файла. Должен быть файл под названием `results.txt` со следующим содержимым:

<sample-data>

<pre>
Introduction to Programming, 5 credits
======================================
name                          exec_nbr  exec_pts. exm_pts.  tot_pts.  grade
pekka peloton                 21        5         9         14        0
jaana javanainen              27        6         11        17        1
liisa virtanen                35        8         14        22        3
</pre>

</sample-data>

Раздел статистики идентичен результатам, выведенным в части 3 проекта. Единственное добавление здесь - раздел заголовка.

Дополнительно, должен быть файл под названием `results.csv` со следующим форматом:

<sample-data>

<pre>
12345678;pekka peloton;0
12345687;jaana javanainen;1
12345699;liisa virtanen;3
</pre>

</sample-data>

Когда программа выполняется, она должна выглядеть так:

<sample-output>

Student information: **students1.csv**
Exercises completed: **exercises1.csv**
Exam points: **exam_points1.csv**
Course information: **course1.txt**
Results written to files results.txt and results.csv

</sample-output>

То есть, программа только спрашивает имена входных файлов. Весь вывод должен быть записан в файлы. Пользователь увидит только сообщение, подтверждающее это.

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

<programming-exercise name='Поиск слов' tmcname='part06-15_word_search'>

Шаблон упражнения включает файл `words.txt`, который содержит слова на английском языке.

Пожалуйста, напишите функцию с именем `find_words(search_term: str)`. Она должна вернуть список, содержащий все слова в файле, которые соответствуют поисковому запросу.

Поисковый запрос может включать строчные буквы и следующие символы шаблона:

* Точка `.` означает, что любой одиночный символ допустим на ее месте. Например, `ca.` даст слова типа _cat_ и _car_, `p.ng` даст слова типа _ping_ и _pong_, а `.a.e` даст слова типа _sane_, _care_ и _late_.
* Звездочка `*` в _конце_ поискового запроса означает, что любое слово, которое _начинается_ с поискового запроса, допустимо. Звездочка в _начале_ поискового запроса означает, что любое слово, которое _заканчивается_ поисковым запросом, допустимо. Например, `ca*` даст слова типа _california_, _cat_, _caring_ и _catapult_, в то время как `*ane` даст слова типа _crane_, _insane_ и _aeroplane_. В поисковом запросе может быть только одна звездочка.
* Если в поисковом запросе нет символов шаблона, возвращаются только слова, которые точно соответствуют поисковому запросу.

Вы можете предположить, что оба символа шаблона никогда не используются в одном поисковом запросе.

Слова в файле все написаны строчными буквами. Вы также можете предположить, что аргумент функции будет полностью в нижнем регистре.

Если подходящие слова не найдены, функция должна вернуть пустой список.

Подсказка: строковые методы Python `startswith()` и `endswith()` могут быть полезны здесь. Вы можете найти больше информации о них онлайн.

Пример функции в действии:

```python
print(find_words("*vokes"))
```

<sample-output>

['convokes', 'equivokes', 'evokes', 'invokes', 'provokes', 'reinvokes', 'revokes']

</sample-output>

</programming-exercise>

<programming-exercise name='Словарь, хранящийся в файле' tmcname='part06-16_dictionary_file'>

Пожалуйста, напишите программу, которая функционирует как словарь. Пользователь может вводить новые записи или искать существующие записи.

Программа должна работать следующим образом:

<sample-output>

1 - Add word, 2 - Search, 3 - Quit
Function: **1**
The word in Finnish: **auto**
The word in English: **car**
Dictionary entry added
1 - Add word, 2 - Search, 3 - Quit
Function: **1**
The word in Finnish: **roska**
The word in English: **garbage**
Dictionary entry added
1 - Add word, 2 - Search, 3 - Quit
Function: **1**
The word in Finnish: **laukku**
The word in English: **bag**
Dictionary entry added
1 - Add word, 2 - Search, 3 - Quit
Function: **2**
Search term: **bag**
roska - garbage
laukku - bag
1 - Add word, 2 - Search, 3 - Quit
Function: **2**
Search term: **car**
auto - car
1 - Add word, 2 - Search, 3 - Quit
Function: **2**
Search term: **laukku**
laukku - bag
1 - Add word, 2 - Search, 3 - Quit
Function: **3**
Bye!

</sample-output>

Записи словаря должны быть записаны в файл под названием `dictionary.txt`. Программа должна сначала прочитать содержимое файла. Новые записи записываются в конец файла всякий раз, когда они добавляются в словарь.

Формат данных, хранящихся в словаре, остается на ваше усмотрение.

**Примечание:** автоматические тесты для этого упражнения могут изменить содержимое файла. Если вы хотите сохранить его содержимое, сначала сделайте копию файла под другим именем.

**Примечание2:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

<!---
Викторина для обзора содержания этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->