---
path: '/ru/part-6/3-errors'
title: 'Обработка ошибок'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы узнаете, как обрабатывать неверный ввод
- Вы поймете, что такое исключения в программировании
- Вы познакомитесь с наиболее распространенными типами исключений в Python
- Вы сможете обрабатывать исключения в своих программах

</text-box>

Существует две основные категории ошибок, которые возникают в программировании:

1. Синтаксические ошибки, которые препятствуют выполнению программы
2. Ошибки времени выполнения, которые прерывают выполнение

Ошибки категории 1 обычно легко исправить, поскольку интерпретатор Python указывает местоположение ошибки при попытке выполнения программы. Распространенные синтаксические ошибки включают отсутствие двоеточия в конце строки заголовка или отсутствие кавычки в конце строки.

Ошибки категории 2 могут быть труднее обнаружить, поскольку они могут возникать только в определенной точке выполнения программы и только при определенных обстоятельствах. Программа может прекрасно работать в большинстве ситуаций, но останавливаться из-за ошибки в конкретном частном случае. Теперь мы сосредоточимся на обработке таких типов ошибок.

## Проверка ввода

Многие ошибки, возникающие во время выполнения программы, связаны с неверным вводом. Некоторые примеры включают:

* отсутствующие или пустые значения ввода в обязательных полях, такие как пустые строки, когда длина строки критична
* отрицательные значения там, где принимаются только положительные значения, например -15 как количество ингредиента в рецепте
* отсутствующие файлы или опечатки в именах файлов
* значения, которые слишком малы или слишком велики, например при работе с датами и временем
* неверные индексы, такие как попытка получить доступ к индексу 3 в строке "hey"
* значения неправильного типа, такие как строки, когда ожидаются целые числа

К счастью, мы как программисты можем подготовиться к большинству ошибок. Давайте посмотрим на программу, которая спрашивает у пользователя его возраст и убеждается, что это приемлемое число (в данном случае от 0 до 150):

```python
age = int(input("Пожалуйста, введите свой возраст: "))
if age >= 0 and age <= 150:
    print("Это хороший возраст")
else:
    print("Это неверный возраст")
```

<sample-output>

Пожалуйста, введите свой возраст: **25**
Это хороший возраст

</sample-output>

<sample-output>

Пожалуйста, введите свой возраст: **-3**
Это неверный возраст

</sample-output>

Пока пользователь вводит целочисленное значение, наша проверка ввода работает нормально. Но что, если он введет строку?

<sample-output>

Пожалуйста, введите свой возраст: **двадцать три**
ValueError: invalid literal for int() with base 10: 'двадцать три'

</sample-output>

Функция `int` не может разобрать входную строку `двадцать три` как допустимое целочисленное значение. Выполнение останавливается и выводится указанное выше сообщение об ошибке.

## Исключения

Ошибки, которые возникают во время выполнения программы, называются _исключениями_. Можно подготовиться к исключениям и обрабатывать их так, чтобы выполнение продолжалось, несмотря на их возникновение.

Обработка исключений в Python осуществляется с помощью операторов `try` и `except`. Идея заключается в том, что если что-то в блоке `try` вызывает исключение, Python проверяет, есть ли соответствующий блок `except`. Если такой блок существует, он выполняется, и программа затем продолжается, как будто ничего не произошло.

Давайте изменим приведенный выше пример так, чтобы программа была подготовлена к исключению `ValueError`:

```python
try:
    age = int(input("Пожалуйста, введите свой возраст: "))
except ValueError:
    age = -1

if age >= 0 and age <= 150:
    print("Это хороший возраст")
else:
    print("Это неверный возраст")
```

<sample-output>

Пожалуйста, введите свой возраст: **двадцать три**
Это неверный возраст

</sample-output>

Мы можем использовать блок `try`, чтобы отметить, что код в блоке может вызвать ошибку. В операторе `except` непосредственно после блока упоминается соответствующая ошибка. В приведенном выше примере мы покрыли только исключение `ValueError`. Если бы исключение имело какую-то другую причину, выполнение все равно было бы остановлено, несмотря на блоки `try` и `except`.

В приведенном выше примере, если ошибка перехвачена, значение `age` устанавливается в -1. Это неверное значение ввода, для которого мы уже запрограммировали поведение, поскольку программа ожидает, что возраст пользователя будет больше 0.

В следующем примере у нас есть функция `read_integer`, которая просит пользователя ввести целочисленное значение, но функция также подготовлена к неверному вводу. Функция продолжает запрашивать целые числа, пока пользователь не введет допустимое значение ввода.

```python
def read_integer():
    while True:
        try:
            input_str = input("Пожалуйста, введите целое число: ")
            return int(input_str)
        except ValueError:
            print("Этот ввод неверен")

number = read_integer()
print("Спасибо!")
print(number, "в кубе равно", number**3)
```

<sample-output>

Пожалуйста, введите целое число: **три**
Этот ввод неверен
Пожалуйста, введите целое число: **текст**
Этот ввод неверен
Пожалуйста, введите целое число: **5**
Спасибо!
5 в кубе равно 125

</sample-output>

Иногда достаточно перехватить исключения с помощью структуры try-except, не делая с ними ничего. То есть, мы можем просто игнорировать ситуацию в блоке `except`.

Если бы мы изменили приведенный выше пример так, чтобы мы принимали только целые числа меньше 100, результаты могли бы выглядеть так:

```python
def read_small_integer():
    while True:
        try:
            input_str = input("Пожалуйста, введите целое число: ")
            number = int(input_str)
            if number < 100:
                return number
        except ValueError:
            pass # эта команда на самом деле ничего не делает

        print("Этот ввод неверен")

number = read_small_integer()
print(number, "в кубе равно", number**3)
```

<sample-output>

Пожалуйста, введите целое число: **три**
Этот ввод неверен
Пожалуйста, введите целое число: **1000**
Этот ввод неверен
Пожалуйста, введите целое число: **5**
Спасибо!
5 в кубе равно 125

</sample-output>

Теперь блок `except` содержит только команду `pass`, которая ничего не делает. Python не допускает пустых блоков, поэтому команда необходима.

<programming-exercise name='Reading input' tmcname='part06-17_read_input'>

Пожалуйста, напишите функцию с именем `read_input`, которая запрашивает у пользователя ввод до тех пор, пока пользователь не введет целое число, которое попадает в границы, заданные как аргументы функции. Функция должна вернуть окончательное допустимое целочисленное значение, введенное пользователем.

Пример работы функции:

```python
number = read_input("Пожалуйста, введите число: ", 5, 10)
print("Вы ввели:", number)
```

<sample-output>

Пожалуйста, введите число: **семь**
Вы должны ввести целое число между 5 и 10
Пожалуйста, введите число: **-3**
Вы должны ввести целое число между 5 и 10
Пожалуйста, введите число: **8**
Вы ввели: 8

</sample-output>

</programming-exercise>

## Типичные ошибки

Вот подборка типичных ошибок, с которыми вы, вероятно, столкнетесь, а также некоторые ситуации, в которых они могут возникнуть.

**ValueError**

Эта ошибка часто возникает, когда аргумент, переданный функции, каким-то образом недопустим. Например, вызов функции `float("1,23")` вызывает ошибку, поскольку десятичные дроби в Python всегда разделяются точкой, а здесь у нас запятая.

**TypeError**

Эта ошибка возникает, когда значение имеет неправильный тип. Например, вызов функции `len(10)` вызывает `TypeError`, поскольку функция `len` требует значения, длину которого можно вычислить, например строки или списка.

**IndexError**

Эта распространенная ошибка возникает при попытке обратиться к несуществующему индексу. Например, выражение `"abc"[5]` вызывает `IndexError`, поскольку в рассматриваемой строке нет индекса 5.

**ZeroDivisionError**

Как следует из названия, эта ошибка возникает при попытке деления на ноль, что, как мы знаем из математики, всегда является плохой идеей. Например, если мы пытаемся определить арифметическое среднее значений в списке с помощью формулы `sum(my_list) / len(my_list)`, но наш список имеет нулевую длину, произойдет эта ошибка.

**Исключения при работе с файлами**

Некоторые распространенные ошибки при работе с файлами: **FileNotFoundError** (при попытке доступа к файлу, который не существует), **io.UnsupportedOperation** (при попытке выполнить операцию с файлом, которая не поддерживается режимом, в котором открыт файл) или **PermissionError** (программа не имеет необходимых разрешений для доступа к файлу).

## Обработка нескольких исключений одновременно

К каждому блоку `try` может быть прикреплено более одного блока `except`. Например, следующая программа может обрабатывать как `FileNotFoundException`, так и `PermissionError`:

```python
try:
    with open("example.txt") as my_file:
        for line in my_file:
            print(line)
except FileNotFoundError:
    print("Файл example.txt не найден")
except PermissionError:
    print("Нет разрешения для доступа к файлу example.txt")
```

Иногда не нужно указывать ошибку, к которой готовится программа. Особенно при работе с файлами часто достаточно знать, что произошла ошибка, и безопасно выйти из программы. Не всегда необходимо знать _почему_ произошла ошибка. Если нам нужно покрыть все возможные исключения, мы можем использовать блок `except` без указания ошибки:

```python

try:
    with open("example.txt") as my_file:
        for line in my_file:
            print(line)
except:
    print("Произошла ошибка при чтении файла.")

```

Примечание: оператор `except` здесь покрывает все возможные ошибки, даже те, которые вызваны ошибками программирования. Только синтаксические ошибки не будут пойманы этим, поскольку они препятствуют выполнению кода в первую очередь.

Например, следующая программа всегда будет выдавать ошибку, потому что имя переменной `my_file` написано как `myfile` в третьей строке.

```python
try:
    with open("example.txt") as my_file:
        for line in myfile:
            print(line)
except:
    print("Произошла ошибка при чтении файла.")
```

Блок `except` может скрыть реальную ошибку: проблема здесь была вызвана не обработкой файла как таковой, а именем переменной, которое было написано неправильно. Без блока `except` была бы показана выброшенная ошибка, и причину можно было бы найти легче. Поэтому обычно хорошей идеей является использование только блоков `except`, специально объявленных для определенных типов ошибок.

## Передача исключений

Если выполнение функции вызывает исключение, и это исключение не обрабатывается, оно передается в участок кода, который вызвал функцию, и так далее по цепочке вызовов, пока не достигнет уровня основной функции. Если оно не обрабатывается и там, выполнение программы останавливается, и исключение обычно выводится для пользователя.

В следующем примере у нас есть функция `testing`. Если она вызывает исключение, это не обрабатывается внутри самой функции, а в основной функции:

```python
def testing(x):
    print(int(x) + 1)

try:
    number = input("Пожалуйста, введите число: ")
    testing(number)
except:
    print("Что-то пошло не так")
```

<sample-output>

Пожалуйста, введите число: **три**
Что-то пошло не так

</sample-output>

## Вызов исключений

Вы также можете вызывать исключения с помощью команды `raise`. Может показаться странной идеей намеренно вызывать ошибки в ваших программах, но на самом деле это может быть очень полезным механизмом.

Например, иногда может быть хорошей идеей вызвать ошибку при обнаружении неверных параметров. До сих пор мы обычно выводили сообщения при проверке ввода, но если мы пишем функцию, которая выполняется из другого места, простой вывод чего-либо может остаться незамеченным при вызове функции. Вызов ошибки может облегчить отладку.

В следующем примере у нас есть функция, которая вычисляет факториалы (например, факториал числа 5 равен 1 * 2 * 3 * 4 * 5). Если аргумент, переданный функции, отрицательный, функция вызывает ошибку:

```python
def factorial(n):
    if n < 0:
        raise ValueError("Ввод был отрицательным: " + str(n))
    k = 1
    for i in range(2, n + 1):
        k *= i
    return k

print(factorial(3))
print(factorial(6))
print(factorial(-1))
```

<sample-output>

6
720
Traceback (most recent call last):
  File "test.py", line 11, in <module>
    print(factorial(-1))
  File "test.py", line 3, in factorial
    raise ValueError("Ввод был отрицательным: " + str(n))
ValueError: Ввод был отрицательным: -1

</sample-output>


<programming-exercise name='Parameter validation' tmcname='part06-18_parameter_validation'>

Пожалуйста, напишите функцию с именем `new_person(name: str, age: int)`, которая создает и возвращает кортеж, содержащий данные в аргументах. Первый элемент должен быть именем, а второй - возрастом.

Если значения, хранящиеся в переменных параметров, недопустимы, функция должна выбросить исключение `ValueError`.

Недопустимые параметры в этом случае включают:

* имя является пустой строкой
* имя содержит менее двух слов
* имя длиннее 40 символов
* возраст является отрицательным числом
* возраст больше 150

</programming-exercise>

<programming-exercise name='Incorrect lottery numbers' tmcname='part06-19_incorrect_lottery_numbers'>

Файл `lottery_numbers.csv` содержит выигрышные номера лотереи в следующем формате:

<sample-data>

week 1;5,7,11,13,23,24,30
week 2;9,13,14,24,34,35,37
...и т.д...

</sample-data>

Каждая строка должна содержать заголовок `week x`, за которым следуют семь целых чисел, которые все находятся между 1 и 39 включительно.

Файл был поврежден. Строки в файле могут содержать следующие виды ошибок (эти точные строки могут не присутствовать в файле, но ошибки в подобном формате будут):

Номер недели неверен:

<sample-data>

week zzc;1,5,13,22,24,25,26

</sample-data>

Одно или несколько чисел неверны:

<sample-data>

week 22;1,**,5,6,13,2b,34

</sample-data>

Слишком мало чисел:

<sample-data>

week 13;4,6,17,19,24,33

</sample-data>

Числа слишком малы или велики:

<sample-data>

week 39;5,9,15,35,39,41,105

</sample-data>

Одно и то же число появляется дважды:

<sample-data>

week 41;5,12,3,35,12,14,36

</sample-data>

Пожалуйста, напишите функцию с именем `filter_incorrect()`, которая создает файл с именем `correct_numbers.csv`. Файл должен содержать только те строки из исходного файла, которые имеют правильный формат.

</programming-exercise>

<!---
Викторина для проверки содержания этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->