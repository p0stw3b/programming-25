---
path: '/ru/part-6/1-reading-files'
title: 'Чтение файлов'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы узнаете, как читать содержимое файлов с помощью Python
- Вы узнаете, что такое текстовый файл и CSV-файл
- Вы сможете обрабатывать содержимое CSV-файла в своих программах

</text-box>

<!--тот же текст в разделах 3-1, 5-1 и 6-1, проверьте их все, если меняете это-->
<text-box variant='hint' name="О упражнениях в этом курсе">

Становление опытным программистом требует много практики, иногда даже довольно механической практики. Это также включает развитие навыков решения проблем и применение интуиции. Поэтому в этом курсе много упражнений разных типов. Некоторые из них просят вас довольно прямолинейно применить то, что вы изучили в материале, но некоторые из них намеренно более сложные и открытые.

Некоторые упражнения поначалу могут показаться ошеломляющими, но об этом не стоит беспокоиться. Ни одно из упражнений не является строго обязательным, и фактически _требуется только 25% баллов в каждой части для прохождения курса._ Более подробную информацию о прохождении курса можно найти на [странице об оценивании](/ru/grading-and-exams).

**Упражнения не расположены в каком-либо определенном порядке сложности.** Каждый раздел обычно вводит некоторые новые концепции программирования, и они затем практикуются как с более простыми, так и более сложными упражнениями. **Если вы столкнулись с упражнением, которое кажется слишком сложным, переходите к следующему.** Вы всегда можете вернуться к более сложным упражнениям, если у вас будет время позже.

Когда дела неизбежно становятся трудными, слово утешения: задача, которая кажется невозможно сложной на этой неделе, вероятно, будет казаться довольно легкой примерно через четыре недели.

</text-box>

Очень распространенный случай использования программирования - это обработка данных, хранящихся в файлах. Программы могут читать данные из файлов и записывать вычисленные результаты в файлы. Даже большие объемы данных становится легко обрабатывать автоматически, когда используются файлы.

В этом курсе мы работаем только с _текстовыми файлами_. Все используемые файлы будут состоять из строк текста. В качестве примера, редактор Visual Studio Code, который мы используем в этом курсе, работает с текстовыми файлами. Примечание: хотя текстовые процессоры, такие как Microsoft Word, обычно используются с файлами, содержащими текст, документы Word сами по себе не являются текстовыми файлами. Они также содержат информацию о форматировании и закодированы способом, который делает работу с ними в программе более сложной.

## Чтение данных из файла

Давайте сначала работать с файлом под названием `example.txt`, со следующим содержимым:

<sample-data>

Hello there!
This example file contains three lines of text.
This is the last line.

</sample-data>

Простой способ включить файлы в программу Python - использовать оператор `with`. Строка заголовка открывает файл, а затем следует блок, где файл может быть доступен. После блока файл автоматически закрывается и больше не может быть доступен.

Итак, следующий код открывает файл, читает содержимое, выводит его, а затем закрывает файл:

```python
with open("example.txt") as new_file:
    contents = new_file.read()
    print(contents)
```

<sample-output>

Hello there!
This example file contains three lines of text.
This is the last line.

</sample-output>

Переменная `new_file` выше - это _дескриптор файла_. Через него можно получить доступ к файлу, пока он еще открыт. Здесь мы использовали метод `read`, который возвращает содержимое файла как одну строку. Итак, в данном случае строка, возвращаемая `read`, была бы

```
"Hello there!\nThis example file contains three lines of text.\nThis is the last line."
```

## Перебор содержимого файла

Метод `read` полезен для вывода содержимого всего файла, но чаще мы захотим пройти через файл строка за строкой.

Текстовые файлы можно рассматривать как списки строк, где каждая строка представляет одну строку в файле. Мы можем пройти через список с помощью цикла `for`.

Следующий пример читает наш пример файла с помощью цикла `for`, удаляет переносы строк с конца каждой строки, считает количество строк и выводит каждую строку с ее номером. Он также отслеживает длину строк:

```python
with open("example.txt") as new_file:
    count = 0
    total_length = 0

    for line in new_file:
        line = line.replace("\n", "")
        count += 1
        print("Line", count, line)
        length = len(line)
        total_length += length

print("Total length of lines:", total_length)
```

<sample-output>

Line 1 Hello there!
Line 2 This example file contains three lines of text.
Line 3 This is the last line.
Total length of lines: 81

</sample-output>

В конце каждой строки в файле есть перенос строки `\n`, но функция `print` также добавляет перенос строки по умолчанию. В выводе выше нет дополнительных переносов строк, потому что переносы строк в концах строк удаляются с помощью метода `replace`. Он заменяет каждый символ переноса строки пустой строкой. Таким образом, длины строк также вычисляются правильно.

<programming-exercise name='Наибольшее число' tmcname='part06-01_largest_number'>

Файл `numbers.txt` содержит целые числа, по одному числу на строку. Содержимое может выглядеть так:

```sh
2
45
108
3
-10
1100
...etc...
```

Пожалуйста, напишите функцию с именем `largest`, которая читает файл и возвращает наибольшее число в файле.

Обратите внимание, что функция не принимает никаких аргументов. Файл, с которым вы работаете, всегда называется `numbers.txt`.

**Примечание:** Если Visual Studio Code не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на инструкции после этого упражнения.

</programming-exercise>

## Что делать, если Visual Studio Code не может найти мой файл?

Когда вы выполняете свой код, Visual Studio Code может жаловаться на то, что не может найти файл, даже если вы проверили и дважды проверили, что имя файла было написано правильно, и файл существует. Изменение следующей настройки может исправить проблему:

* Откройте настройки из строки меню: _File_ -> _Preferences_ -> _Settings_
* Найдите соответствующую настройку с поисковым термином "executeinfile"
* Выберите вкладку _Workspace_
* Выберите опцию под _Python_ -> _Terminal_ -> _Execute In File Dir_

Ваше окно настроек должно теперь выглядеть примерно так:

<img src="../../part-6/6_1_1.png">

Если это не помогает, вы можете скопировать файл из директории _src_

<img src="../../part-6/6_1_2.png">

непосредственно в корень директории упражнения

<img src="../../part-6/6_1_3.png">

## Отладка кода, который работает с файлами

Использование встроенного [отладчика](/ru/part-4/1-vscode#встроенный-отладчик) Visual Studio Code с программами, которые работают с файлами, часто приведет к неприятному сообщению об ошибке:

<img src="../../part-6/6_1_4.png">

Причина в том, что отладчик всегда будет искать файлы в корне директории упражнения. Настройка _Execute In File Dir_, упомянутая выше, не будет иметь эффекта на это. Самое простое решение - просто скопировать файл в корень директории.

Вам может потребоваться перезапустить Visual Studio Code после копирования всех необходимых файлов.

## Чтение CSV-файлов

CSV-файл, сокращение от _Comma-Separated Values_, это текстовый файл, который содержит данные, разделенные заранее определенным символом. Наиболее распространенными символами, используемыми для этой цели, являются запятая `,` и точка с запятой `;`, но в принципе возможен любой символ.

CSV-файлы обычно используются для хранения записей разных типов. Многие программы баз данных и электронных таблиц, такие как Excel, могут импортировать и экспортировать данные в формате CSV, что делает обмен данными между различными системами простым.

Мы уже изучили, что можем пройти через строки в файле с помощью цикла `for`, но как мы можем разделить различные поля в одной строке? Python имеет строковый метод `split` именно для этой цели. Метод принимает символ(ы) разделителя в качестве строкового аргумента и возвращает содержимое целевой строки в виде списка строк, разделенных по разделителю.

Пример того, как работает метод:

```python
text = "monkey,banana,harpsichord"
words = text.split(",")
for word in words:
    print(word)
```

<sample-output>

monkey
banana
harpsichord

</sample-output>

Предположим, у нас есть файл `grades.csv`, который содержит имена студентов и оценки, которые они получили по некоторым курсам. Каждая строка содержит данные одного студента, и данные разделены точкой с запятой.

<sample-data>

Paul;5;4;5;3;4;5;5;4;2;4
Beth;3;4;2;4;4;2;3;1;3;3
Ruth;4;5;5;4;5;5;4;5;4;4

</sample-data>

Следующая программа проходит через файл строка за строкой, разделяет каждую строку на отдельные части и выводит имя и оценки каждого студента.

```python
with open("grades.csv") as new_file:
    for line in new_file:
        line = line.replace("\n", "")
        parts = line.split(";")
        name = parts[0]
        grades = parts[1:]
        print("Name:", name)
        print("Grades:", grades)
```

<sample-output>

Name: Paul
Grades: ['5', '4', '5', '3', '4', '5', '5', '4', '2', '4']
Name: Beth
Grades: ['3', '4', '2', '4', '4', '2', '3', '1', '3', '3']
Name: Ruth
Grades: ['4', '5', '5', '4', '5', '5', '4', '5', '4', '4']

</sample-output>

<programming-exercise name='Фруктовый рынок' tmcname='part06-02_fruit_market'>

Файл `fruits.csv` содержит названия фруктов и их цены в формате, указанном в этом примере:

```sh
banana;6.50
apple;4.95
orange;8.0
...etc...
```

Пожалуйста, напишите функцию с именем `read_fruits`, которая читает файл и возвращает словарь на основе содержимого. В словаре название фрукта должно быть ключом, а значение должно быть его ценой. Цены должны быть типа `float`.

Примечание: функция не принимает никаких аргументов. Файл, с которым вы работаете, всегда называется `fruits.csv`.

</programming-exercise>

<programming-exercise name='Матрица' tmcname='part06-03_matrix'>

Файл `matrix.txt` содержит матрицу в формате, указанном в примере ниже:

```sh
1,0,2,8,2,1,3,2,5,2,2,2
9,2,4,5,2,4,2,4,1,10,4,2
...etc...
```

Пожалуйста, напишите две функции с именами `matrix_sum` и `matrix_max`. Обе проходят через матрицу в файле, а затем возвращают сумму элементов или элемент с наибольшим значением, как подразумевают названия функций.

Пожалуйста, также напишите функцию `row_sums`, которая возвращает список, содержащий сумму каждой строки в матрице. Например, вызов `row_sums`, когда матрица в файле определена как

```sh
1,2,3
2,3,4
```

функция должна вернуть список `[6, 9]`.

Подсказка: вы также можете включить другие вспомогательные функции в свою программу. Очень стоит потратить минуту на размышления о том, какие функциональности являются общими для трех функций, которые вас просят написать. Обратите внимание, что три функции, названные выше, не принимают никаких аргументов, но любые вспомогательные функции, которые вы напишете, могут принимать аргументы. Файл, с которым вы работаете, всегда называется `matrix.txt`.

**Примечание:** Если Visual Studio Code не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на инструкции перед этим упражнением.

</programming-exercise>

## Чтение одного и того же файла несколько раз

Иногда необходимо обработать содержимое файла более одного раза в одной программе. Давайте посмотрим на программу, которая работает с некоторыми персональными данными, хранящимися в CSV-файле:

<sample-data>
Peter;40;Helsinki
Emily;34;Espoo
Eric;42;London
Adam;100;Amsterdam
Alice;58;Paris
</sample-data>

```python
with open("people.csv") as new_file:
    # print out the names
    for line in new_file:
        parts = line.split(";")
        print("Name:", parts[0])

    # find the oldest
    age_of_oldest = -1
    for line in new_file:
        parts = line.split(";")
        name = parts[0]
        age = int(parts[1])
        if age > age_of_oldest:
            age_of_oldest = age
            oldest = name
    print("the oldest is", oldest)
```

Выполнение этого приведет к довольно загадочному сообщению об ошибке:

```python
Traceback (most recent call last):
    print("the oldest is"; oldest)
UnboundLocalError: local variable 'oldest' referenced before assignment
```

Причина этого в том, что последний цикл `for` вообще не выполняется, поскольку файл может быть обработан только один раз. Как только последняя строка прочитана, дескриптор файла остается в конце файла, и данные в файле больше не могут быть доступны.

Если мы хотим получить доступ к содержимому во втором цикле `for`, нам нужно будет `открыть` файл второй раз:

```python
with open("people.csv") as new_file:
    # print out the names
    for line in new_file:
        parts = line.split(";")
        print("Name:", parts[0])

with open("people.csv") as new_file:
    # find the oldest
    age_of_oldest = -1
    for line in new_file:
        parts = line.split(";")
        name = parts[0]
        age = int(parts[1])
        if age > age_of_oldest:
            age_of_oldest = age
            oldest = name
    print("the oldest is", oldest)
```

Хотя приведенный выше код будет работать, он содержит ненужное повторение. Обычно лучше прочитать файл только один раз и сохранить его содержимое в подходящем формате для дальнейшей обработки:

```python
people = []
# read the contents of the file and store it in a list
with open("people.csv") as new_file:
    for line in new_file:
        parts = line.split(";")
        people.append((parts[0], int(parts[1]), parts[2]))

# print out the names
for person in people:
    print("Name:", person[0])

# find the oldest
age_of_oldest = -1
for person in people:
    name = person[0]
    age = person[1]
    if age > age_of_oldest:
        age_of_oldest = age
        oldest = name
print("the oldest is", oldest)
```

## Дополнительная обработка CSV-файлов

Давайте продолжим с файлом `grades.csv`, который имеет следующее содержимое:

<sample-data>

Paul;5;4;5;3;4;5;5;4;2;4
Beth;3;4;2;4;4;2;3;1;3;3
Ruth;4;5;5;4;5;5;4;5;4;4

</sample-data>

Эта следующая программа создает словарь `grades` на основе содержимого файла. Ключами являются имена студентов, а значение, прикрепленное к каждому ключу, это список оценок, полученных студентом. Программа преобразует оценки в целые значения, чтобы их можно было легче обрабатывать.

```python
grades = {}
with open("grades.csv") as new_file:
    for line in new_file:
        line = line.replace("\n", "")
        parts = line.split(";")
        name = parts[0]
        grades[name] = []
        for grade in parts[1:]:
            grades[name].append(int(grade))

print(grades)
```

<sample-output>

{'Paul': [5, 4, 5, 3, 4, 5, 5, 4, 2, 4], 'Beth': [3, 4, 2, 4, 4, 2, 3, 1, 3, 3], 'Ruth': [4, 5, 5, 4, 5, 5, 4, 5, 4, 4]}

</sample-output>

Теперь мы можем вывести некоторую статистику по каждому студенту на основе содержимого словаря `grades`:

```python
for name, grade_list in grades.items():
    best = max(grade_list)
    average = sum(grade_list) / len(grade_list)
    print(f"{name}: best grade {best}, average {average:.2f}")
```

<sample-output>

Paul: best grade 5, average 4.10
Beth: best grade 4, average 2.90
Ruth: best grade 5, average 4.50

</sample-output>

Пожалуйста, внимательно посмотрите на программу в приведенном выше примере. Поначалу она может показаться немного сложной, но техника может использоваться для файлов, содержащих много различных типов данных.

## Удаление ненужных строк, пробелов и переносов строк

Предположим, у нас есть CSV-файл, содержащий некоторые имена, который был экспортирован из Excel:

```sh
first; last
Paul; Python
Jean; Java
Harry; Haskell
```

Excel печально известен добавлением лишних пробелов. Здесь у нас есть лишний пробел между элементами, после каждой точки с запятой.

Мы хотели бы вывести фамилии каждого человека в списке. Первая строка содержит заголовки для данных, и ее можно безопасно игнорировать:

```python
last_names = []
with open("people.csv") as new_file:
    for line in new_file:
        parts = line.split(";")
        # ignore the header line
        if parts[0] == "first":
            continue
        last_names.append(parts[1])

print(last_names)
```

Выполнение этого выведет

<sample-output>

[' Python\n', ' Java\n', ' Haskell']

</sample-output>

Первые два элемента имеют символ переноса строки в конце, и все три имеют лишний ведущий пробел.

Мы уже использовали метод `replace` для удаления лишних пробелов, но более эффективным решением является использование строкового метода Python `strip`, который удаляет пробелы с начала и конца строки. Он удаляет все пробелы, переносы строк, табуляции и другие символы, которые обычно не печатаются.

Вы можете попробовать это в консоли Python:

```python
>>> " tryout ".strip()
'tryout'
>>> "\n\ntest\n".strip()
'test'
>>>
```

Очистка строки требует лишь небольшого изменения в программе:

```python
last_names = []
with open("people.csv") as new_file:
    for line in new_file:
        parts = line.split(';')
        if parts[0] == "first":
            continue # this was the header line, so it is ignored
        last_names.append(parts[1].strip())
print(last_names)
```

Теперь у нас есть желаемый аккуратный вывод:

<sample-output>

['Python', 'Java', 'Haskell']

</sample-output>

Есть также связанные строковые методы `lstrip` и `rstrip`. Они удаляют только ведущие или завершающие непечатаемые символы, l для левого края строки и r для правого:

```python
>>> " teststring  ".rstrip()
' teststring'
>>> " teststring  ".lstrip()
'teststring  '
```

## Объединение данных из разных файлов

Очень часто данные, обрабатываемые программой, разбросаны по нескольким файлам. Давайте посмотрим на ситуацию, где персональные данные персонала компании хранятся в файле под названием `employees.csv`:

```csv
pic;name;address;city
080488-123X;Pekka Mikkola;Vilppulantie 7;00700 Helsinki
290274-044S;Liisa Marttinen;Mannerheimintie 100 A 10;00100 Helsinki
010479-007Z;Arto Vihavainen;Pihapolku 4;01010 Kerava
010499-345K;Leevi Hellas;Tapiolantie 11 B;02000 Espoo
```

Зарплаты хранятся в отдельном файле `salaries.csv`:

```csv
pic;salary;bonus
080488-123X;3300;0
290274-044S;4150;200
010479-007Z;1300;1200
```

Каждая строка данных в обоих файлах содержит _личный идентификационный код_, который идентифицирует, чьи данные мы обрабатываем. Используя личный идентификационный код как общий фактор, легко связать имена и зарплаты каждого сотрудника. Мы можем, например, вывести следующий список месячных доходов:

<sample-output>

<pre>
incomes:
Pekka Mikkola    3300 euros
Liisa Marttinen  4350 euros
Arto Vihavainen  2500 euros
</pre>

</sample-output>

Эта программа использует два словаря как вспомогательные структуры данных: `names` и `salaries`. Оба используют PIC в качестве ключа:

```python
names = {}

with open("employees.csv") as new_file:
    for line in new_file:
        parts = line.split(';')
        if parts[0] == "pic":
            continue
        names[parts[0]] = parts[1]

salaries = {}

with open("salaries.csv") as new_file:
    for line in new_file:
        parts = line.split(';')
        if parts[0] == "pic":
            continue
        salaries[parts[0]] = int(parts[1]) +int(parts[2])

print("incomes:")

for pic, name in names.items():
    if pic in salaries:
        salary = salaries[pic]
        print(f"{name:16} {salary} euros")
    else:
        print(f"{name:16} 0 euros")
```

Сначала программа создает словари `names` и `salaries`. Они имеют следующее содержимое:

```sh
{
    '080488-123X': 'Pekka Mikkola',
    '290274-044S': 'Liisa Marttinen',
    '010479-007Z': 'Arto Vihavainen',
    '010499-345K': 'Leevi Hellas'
}

{
    '080488-123X': 3300,
    '290274-044S': 4350,
    '010479-007Z': 2500
}
```

Цикл `for` в конце программы объединяет имена сотрудников с их соответствующими зарплатами.

Программа также учитывает ситуации, где pic сотрудника отсутствует в файле зарплат.

Помните, порядок, в котором элементы хранятся в словаре, не имеет значения, поскольку ключи обрабатываются на основе хеш-значений.

<programming-exercise name='Оценивание курса, часть 1' tmcname='part06-04_course_grading_part_1'>

Эта программа работает с двумя CSV-файлами. Один из них содержит информацию о некоторых студентах курса:

```csv
id;first;last
12345678;peter;pythons
12345687;jean;javanese
12345699;alice;adder
```

Другой содержит количество упражнений, которые каждый студент выполнил каждую неделю:

```csv
id;e1;e2;e3;e4;e5;e6;e7
12345678;4;1;1;4;5;2;4
12345687;3;5;3;1;5;4;6
12345699;10;2;2;7;10;2;2
```

Как вы можете видеть выше, оба CSV-файла также имеют строку заголовка, которая сообщает вам, что содержит каждый столбец.

Пожалуйста, напишите программу, которая спрашивает пользователя о названиях этих двух файлов, читает файлы, а затем выводит общее количество упражнений, выполненных каждым студентом. Если файлы имеют содержимое в примерах выше, программа должна вывести следующее:

<sample-output>

Student information: **students1.csv**
Exercises completed: **exercises1.csv**
pekka peloton 21
jaana javanainen 27
liisa virtanen 35

</sample-output>

Подсказка: при тестировании вашей программы вы можете быстро потерять терпение, если всегда будете вводить имена файлов в приглашении. Возможно, вы захотите жестко закодировать пользовательский ввод, например так:

```python
if False:
    # this is never executed
    student_info = input("Student information: ")
    exercise_data = input("Exercises completed: ")
else:
    # hard-coded input
    student_info = "students1.csv"
    exercise_data = "exercises1.csv"
```

Фактическая функциональность программы теперь "спрятана" в ветке `False` оператора `if`. Она никогда не будет выполнена.

Теперь, если вы хотите быстро проверить, что программа работает правильно также с пользовательским вводом, вы можете просто заменить `False` на `True`:

```python

if True:
    student_info = input("Student information: ")
    exercise_data = input("Exercises completed: ")
else:
    # now this is the False branch, and is never executed
    student_info = "students1.csv"
    exercise_data = "exercises1.csv"
```

Когда вы проверили, что ваша программа работает правильно, вы можете удалить структуру `if`, оставив команды, запрашивающие ввод.

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

**Примечание2:** Если Visual Studio не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на [эти инструкции](/ru/part-6/1-reading-files#что-делать-если-visual-studio-code-не-может-найти-мой-файл).

</programming-exercise>

<programming-exercise name='Оценивание курса, часть 2' tmcname='part06-05_course_grading_part_2'>

Давайте расширим программу, созданную в предыдущем упражнении. Теперь также баллы за экзамен, присужденные каждому студенту, содержатся в CSV-файле. Содержимое файла следует этому формату:

```csv
id;e1;e2;e3
12345678;4;1;4
12345687;3;5;3
12345699;10;2;2
```

В приведенном выше примере студент, чей студенческий номер 12345678, получил 4+1+4 балла на экзамене, что равно в общей сложности 9 баллам.

Программа должна снова спросить пользователя о названиях файлов. Затем программа должна обработать файлы и вывести оценку для каждого студента.

<sample-output>

Student information: **students1.csv**
Exercises completed: **exercises1.csv**
Exam points: **exam_points1.csv**
pekka peloton 0
jaana javanainen 1
liisa virtanen 3

</sample-output>

Каждое выполненное упражнение засчитывается в _баллы за упражнения_, так что выполнение не менее 10% от общего количества упражнений присуждает 1 балл, выполнение не менее 20% присуждает 2 балла и т.д. Выполнение всех 40 упражнений присуждает 10 баллов. Количество присуждаемых баллов всегда является целым числом.

Итоговая оценка за курс определяется на основе суммы баллов за экзамен и упражнения согласно следующей таблице:

баллы за экзамен + баллы за упражнения   | оценка
:--:|:----:
0-14 | 0 (незачет)
15-17 | 1
18-20 | 2
21-23 | 3
24-27 | 4
28- | 5

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

<programming-exercise name='Оценивание курса, часть 3' tmcname='part06-06_course_grading_part_3'>

Это упражнение продолжит предыдущее. Теперь мы выведем некоторую статистику на основе CSV-файлов.

<sample-output>

Student information: **students1.csv**
Exercises completed: **exercises1.csv**
Exam points: **exam_points1.csv**
<pre>
name                          exec_nbr  exec_pts. exm_pts.  tot_pts.  grade
pekka peloton                 21        5         9         14        0
jaana javanainen              27        6         11        17        1
liisa virtanen                35        8         14        22        3
</pre>

</sample-output>

Каждая строка содержит информацию для одного студента. Количество выполненных упражнений, количество присужденных баллов за упражнения, количество присужденных баллов за экзамен, общее количество присужденных баллов и оценка отображаются в аккуратных столбцах. Ширина столбца для имени должна составлять 30 символов, а другие столбцы должны быть шириной 10 символов.

Вы можете найти полезными f-строки, рассмотренные в [части 4](/ru/part-4/5-print-statement-formatting).

F-строки различают строки и числа, когда дело доходит до выравнивания столбцов:

```python
word = "python"
print(f"{word:10}continues")
print(f"{word:>10}continues")
```

<sample-output>

<pre>
python    continues
    pythoncontinues
</pre>

</sample-output>

Как видно выше, по умолчанию строки выравниваются по _левому_ краю области, указанной для них. Символ `>` можно использовать для выравнивания по правому краю.

С числовыми значениями логика обратная:

```python
number = 42
print(f"{number:10}continues")
print(f"{number:<10}continues")
```

<sample-output>

<pre>
        42continues
42        continues
</pre>

</sample-output>

С числами поведение по умолчанию - выравнивание по _правому_ краю. Символ `<` можно использовать для выравнивания по левому краю.

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

</programming-exercise>

<programming-exercise name='Проверка орфографии' tmcname='part06-07_spellchecker'>

Пожалуйста, напишите программу, которая просит пользователя ввести некоторый текст. Ваша программа должна затем выполнить проверку орфографии и вывести обратную связь пользователю, так чтобы все неправильно написанные слова имели звездочки вокруг них. Пожалуйста, посмотрите два примера ниже:

<sample-output>

Write text: **We use ptython to make a spell checker**
<pre>
We use *ptython* to make a spell checker
</pre>

</sample-output>

<sample-output>

Write text: **This is acually a good and usefull program**
<pre>
This is *acually* good and *usefull* program
</pre>

</sample-output>

Регистр букв должен быть неважен для функционирования вашей программы.

Шаблон упражнения включает файл `wordlist.txt`, который содержит все слова, которые проверка орфографии должна принимать как правильные.

**Примечание:** это упражнение не просит вас писать функции, поэтому вы __не должны__ размещать какой-либо код внутри блока `if __name__ == "__main__"`.

**Примечание2** Если Visual Studio не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на [эти инструкции](/ru/part-6/1-reading-files#что-делать-если-visual-studio-code-не-может-найти-мой-файл).

</programming-exercise>

<programming-exercise name='Поиск рецептов' tmcname='part06-08_recipe_search'>

Это упражнение о создании программы, которая позволяет пользователю искать рецепты на основе их названий, времени приготовления или используемых ингредиентов. Программа должна читать рецепты из файла, предоставленного пользователем.

Каждый рецепт состоит из трех или более строк. Первая строка содержит название рецепта, вторая строка содержит целое число, представляющее время приготовления в минутах, а остальные строки содержат используемые ингредиенты, по одному на каждой строке. Рецепт заканчивается пустой строкой, за исключением последнего рецепта в файле, который просто заканчивается концом файла. Итак, в одном файле может быть более одного рецепта, как в примере ниже.

```sh
Pancakes
15
milk
eggs
flour
sugar
salt
butter

Meatballs
45
mince
eggs
breadcrumbs

Tofu rolls
30
tofu
rice
water
carrot
cucumber
avocado
wasabi

Cake pops
60
milk
bicarbonate
eggs
salt
sugar
cardamom
butter
```

**Подсказка:** возможно, лучше всего сначала прочитать все строки в файле и поместить их в список, которым затем легче манипулировать способом, описанным в упражнении.

#### Поиск рецептов на основе названия рецепта

Пожалуйста, напишите функцию с именем `search_by_name(filename: str, word: str)`, которая принимает имя файла и строку поиска в качестве аргументов. Функция должна пройти через файл и выбрать все рецепты, чье _название_ содержит данную строку поиска. Названия этих рецептов затем возвращаются в списке.

Пример функции в действии:

```python
found_recipes = search_by_name("recipes1.txt", "cake")

for recipe in found_recipes:
    print(recipe)
```

<sample-output>

Pancakes
Cake pops

</sample-output>

Как видно в примере выше, регистр букв не важен. Поисковый термин _cake_ возвращает как _Pancakes_, так и _Cake pops_, даже если последний написан с заглавной буквы.

**Примечание:** Если Visual Studio не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на [эти инструкции](/ru/part-6/1-reading-files#что-делать-если-visual-studio-code-не-может-найти-мой-файл).

#### Поиск рецептов на основе времени приготовления

Пожалуйста, напишите функцию с именем `search_by_time(filename: str, prep_time: int)`, которая принимает имя файла и целое число в качестве аргументов. Функция должна пройти через файл и выбрать все рецепты, чье время приготовления не превышает заданное число.

Названия этих рецептов снова возвращаются в списке, но к каждому названию должно быть добавлено время приготовления. Пожалуйста, посмотрите на пример ниже.

```python
found_recipes = search_by_time("recipes1.txt", 20)

for recipe in found_recipes:
    print(recipe)
```

<sample-output>

Pancakes, preparation time 15 min

</sample-output>

#### Поиск рецептов на основе ингредиентов

**Предостережение:** эта третья часть упражнения значительно более требовательна, чем предыдущие две. Если вы чувствуете, что не продвигаетесь, возможно, стоит двигаться дальше, выполнить другие упражнения в этой части материала, а затем вернуться к этому упражнению, если у вас будет время позже. Помните, вы можете отправить и получить баллы за первые две части этого упражнения, даже если вы не завершили третью часть.

Пожалуйста, напишите функцию с именем `search_by_ingredient(filename: str, ingredient: str)`, которая принимает имя файла и строку поиска в качестве аргументов. Функция должна пройти через файл и выбрать все рецепты, чьи _ингредиенты_ содержат данную строку поиска.

Названия этих рецептов возвращаются в списке точно так же, как во второй части, с добавленным временем приготовления. Пожалуйста, посмотрите на пример ниже.

```python
found_recipes = search_by_ingredient("recipes1.txt", "eggs")

for recipe in found_recipes:
    print(recipe)
```

<sample-output>

Pancakes, preparation time 15 min
Meatballs, preparation time 45 min
Cake pops, preparation time 60 min

</sample-output>

</programming-exercise>

<programming-exercise name='Городские велосипеды' tmcname='part06-09_city_bikes'>

В этом упражнении мы напишем некоторые функции для работы с файлом, содержащим данные о местоположении станций [городских велосипедов в Хельсинки](https://www.hsl.fi/en/citybikes).

Каждый файл будет следовать этому формату:

```csv
Longitude;Latitude;FID;name;total_slot;operative;id
24.950292890004903;60.155444793742276;1;Kaivopuisto;30;Yes;001
24.956347471358754;60.160959093887129;2;Laivasillankatu;12;Yes;002
24.944927399779715;60.158189199971673;3;Kapteeninpuistikko;16;Yes;003
```

Каждая станция имеет одну строку в файле. Строка содержит координаты, название и другую идентифицирующую информацию для станции.

#### Расстояние между станциями

Сначала напишите функцию с именем `get_station_data(filename: str)`. Эта функция должна прочитать названия и местоположения всех станций в файле и вернуть их в словаре в следующем формате:

<sample-output>

<pre>
{
  "Kaivopuisto": (24.950292890004903, 60.155444793742276),
  "Laivasillankatu": (24.956347471358754, 60.160959093887129),
  "Kapteeninpuistikko": (24.944927399779715, 60.158189199971673)
}
</pre>

</sample-output>

Ключи словаря - это названия станций, а прикрепленное значение - это кортеж, содержащий координаты местоположения станции. Первый элемент в кортеже - это поле _Longitude_, а второй - поле _Latitude_.

Далее, напишите функцию с именем `distance(stations: dict, station1: str, station2: str)`, которая возвращает расстояние между двумя станциями, заданными в качестве аргументов.

Расстояние вычисляется с использованием теоремы Пифагора. Коэффициенты умножения ниже - приблизительные значения для преобразования широт и долгот в расстояния в километрах в регионе Хельсинки.

```python
# we will need the function sqrt from the math module 
import math

x_km = (longitude1 - longitude2) * 55.26
y_km = (latitude1 - latitude2) * 111.2
distance_km = math.sqrt(x_km**2 + y_km**2)
```

Некоторые примеры функции в действии:

```python
stations = get_station_data('stations1.csv')
d = distance(stations, "Designmuseo", "Hietalahdentori")
print(d)
d = distance(stations, "Viiskulma", "Kaivopuisto")
print(d)
```

<sample-output>

0.9032737292463177
0.7753594392019532

</sample-output>

**Примечание:** Если Visual Studio не может найти файл и вы проверили, что нет орфографических ошибок, взгляните на [эти инструкции](/ru/part-6/1-reading-files#что-делать-если-visual-studio-code-не-может-найти-мой-файл).

#### Наибольшее расстояние

Пожалуйста, напишите функцию с именем `greatest_distance(stations: dict)`, которая определяет две станции в списке с наибольшим расстоянием друг от друга. Функция должна вернуть кортеж, где первые два элемента - это названия двух станций, а третий элемент - расстояние между ними.

```python
stations = get_station_data('stations1.csv')
station1, station2, greatest = greatest_distance(stations)
print(station1, station2, greatest)
```

<sample-output>

Laivasillankatu Hietalahdentori 1.478708873076181

</sample-output>

</programming-exercise>

<!---
Викторина для обзора содержания этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->