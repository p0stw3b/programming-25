---
path: '/ru/part-2/4-simple-loops'
title: 'Простые циклы'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, что означает цикл в программировании
- Вы сможете использовать цикл `while True` в ваших программах
- Вы будете знать, как использовать команду `break` для выхода из цикла

</text-box>

Мы теперь подробно рассмотрели условные структуры. Еще одна центральная техника в программировании - повторение, или _итерация_. Вместе они образуют фундаментальные структуры управления, которые должен освоить любой программист. Они называются структурами управления, потому что в сущности они позволяют вам контролировать, какие строки кода выполняются когда. Пока условные структуры позволяют вам _выбирать между_ секциями кода, итерационные структуры позволяют вам _повторять_ секции кода. Их часто называют _циклами_, потому что они позволяют программе "возвращаться назад" к какой-то строке, которая уже была выполнена раньше. Процесс выполнения одного повторения цикла также называется итерацией цикла.

Этот раздел знакомит с простым циклом `while`. Его структура похожа на условные операторы, которые мы уже рассмотрели. В следующей части мы погрузимся в некоторые более сложные примеры.

Давайте посмотрим на программу, которая просит пользователя ввести число, а затем выводит число в квадрате. Это продолжается до тех пор, пока пользователь не введет -1.

```python
while True:
    number = int(input("Пожалуйста, введите число, -1 для выхода: "))

    if number == -1:
        break

    print(number ** 2)

print("Спасибо и до свидания!")
```

Выполнение программы может выглядеть так:

<sample-output>

Пожалуйста, введите число, -1 для выхода: **2**
4
Пожалуйста, введите число, -1 для выхода: **4**
16
Пожалуйста, введите число, -1 для выхода: **10**
100
Пожалуйста, введите число, -1 для выхода: **-1**
Спасибо и до свидания!

</sample-output>

Как вы можете видеть выше, программа запрашивает несколько чисел благодаря оператору `while` в программе. Когда пользователь вводит -1, выполняется команда `break`, которая выходит из цикла, и выполнение продолжается с первой строки после блока `while`.

С циклами крайне важно, чтобы всегда был способ выйти из цикла в какой-то точке кода, иначе повторение могло бы продолжаться вечно. Чтобы проиллюстрировать это, давайте немного изменим приведенный выше пример:

```python
number = int(input("Пожалуйста, введите число, -1 для выхода: "))
while True:
    if number == -1:
        break

    print(number ** 2)

print("Спасибо и до свидания!")
```

В этой версии программа просит пользователя ввести число _вне цикла_. Если пользователь введет любое другое число, кроме -1, из цикла никогда не выйти. Это образует _бесконечный цикл_, что означает, что блок кода внутри цикла повторяется бесконечно:

<sample-output>

Пожалуйста, введите число, -1 для выхода: **2**
4
4
4
4
4
4
4
4
(продолжается до бесконечности...)

</sample-output>

Следующая программа имеет похожую структуру на пример выше бесконечного цикла, но пользовательский опыт совершенно другой. Эта программа позволяет пользователю продолжить только если он введет правильный PIN _1234_:

```python
while True:
    code = input("Пожалуйста, введите ваш PIN: ")
    if code == "1234":
        break
    print("Неправильно...попробуйте снова")

print("Правильный PIN введен!")
```

<sample-output>

Пожалуйста, введите ваш PIN: **0000**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **9999**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **1234**
Правильный PIN введен!

</sample-output>

<in-browser-programming-exercise name="Продолжим?" tmcname="part02-15_shall_we_continue" title="Продолжим?">

Давайте создадим программу по образцу приведенного выше примера. Эта программа должна вывести сообщение "привет", а затем спросить "Продолжим?" до тех пор, пока пользователь не введет "нет". Затем программа должна вывести "ладно тогда" и завершиться. Пожалуйста, посмотрите на пример ниже.

<sample-output>

привет
Продолжим? **да**
привет
Продолжим? **конечно**
привет
Продолжим? **ага**
привет
Продолжим? **нет**
ладно тогда

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Проверка ввода" tmcname="part02-16_input_validation" title="Проверка ввода">

Пожалуйста, напишите программу, которая спрашивает у пользователя целые числа.

Если число меньше нуля, программа должна вывести сообщение "Неверное число".

Если число больше нуля, программа должна вывести квадратный корень из числа, используя функцию Python `sqrt`.

В любом случае программа должна затем спросить другое число.

Если пользователь вводит число ноль, программа должна прекратить запрашивать числа и выйти из цикла.

Ниже вы найдете напоминание о том, как используется функция `sqrt`. Не забудьте `import`ировать ее в начале программы.

```python
# функция sqrt не будет работать без этой строки в начале программы
from math import sqrt

print(sqrt(9))
```

<sample-output>

3.0

</sample-output>

Пример ожидаемого поведения вашей программы:

<sample-output>

Пожалуйста, введите число: **16**
4.0
Пожалуйста, введите число: **4**
2.0
Пожалуйста, введите число: **-3**
Неверное число
Пожалуйста, введите число: **1**
1.0
Пожалуйста, введите число: **0**
Выход...

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Исправить код: Обратный отсчет" tmcname="part02-17_countdown" title="Исправить код: Обратный отсчет">

Эта программа должна вывести обратный отсчет. Код следующий:

```python
number = 5
print("Обратный отсчет!")
while True:
  print(number)
  number = number - 1
  if number > 0:
    break

print("Сейчас!")
```

Это должно вывести

<sample-output>

Обратный отсчет!
5
4
3
2
1
Сейчас!

</sample-output>

Однако программа работает не совсем правильно. Пожалуйста, исправьте ее.

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Повторить пароль" tmcname="part02-18_repeat_password" title="Повторить пароль">

Пожалуйста, напишите программу, которая спрашивает у пользователя пароль. Программа должна затем попросить пользователя ввести пароль снова. Если пользователь вводит что-то другое, чем первый пароль, программа должна продолжать спрашивать до тех пор, пока пользователь не введет первый пароль снова правильно.

Посмотрите на ожидаемое поведение ниже:

<sample-output>

Пароль: **секрет**
Повторите пароль: **secret**
Они не совпадают!
Повторите пароль: **незапомнил**
Они не совпадают!
Повторите пароль: **секрет**
Аккаунт пользователя создан!

</sample-output>

</in-browser-programming-exercise>

## Циклы и вспомогательные переменные

Давайте сделаем пример проверки PIN более реалистичным. Эта версия дает пользователю только три попытки ввода PIN.

Программа использует две вспомогательные переменные. Переменная `attempts` отслеживает, сколько раз пользователь ввел PIN. Переменная `success` устанавливается в `True` или `False` в зависимости от того, удается ли пользователю войти в систему.

```python
attempts = 0

while True:
    code = input("Пожалуйста, введите ваш PIN: ")
    attempts += 1

    if code == "1234":
        success = True
        break

    if attempts == 3:
        success = False
        break

    # это печатается, если код был неправильным И было меньше трех попыток
    print("Неправильно...попробуйте снова")

if success:
    print("Правильный PIN введен!")
else:
    print("Слишком много попыток...")
```

<sample-output>

Пожалуйста, введите ваш PIN: **0000**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **1234**
Правильный PIN введен!

</sample-output>

<sample-output>

Пожалуйста, введите ваш PIN: **0000**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **9999**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **4321**
Слишком много попыток...

</sample-output>

Цикл завершается _либо_ когда пользователь вводит правильный PIN _либо_ если было слишком много попыток. Оператор `if` после цикла проверяет значение переменной `success` и выводит сообщение соответственно.

## Отладочные операторы печати в циклах

Добавление циклов к программам также добавляет потенциальные источники ошибок. Становится еще более важным овладеть использованием отладочных операторов печати, как было введено в [первом разделе этой части](/ru/part-2/1-programming-terminology).

Давайте посмотрим на программу, почти идентичную предыдущему примеру, но с одним критическим различием:

```python
attempts = 0

while True:
    code = input("Пожалуйста, введите ваш PIN: ")
    attempts += 1

    if attempts == 3:
        success = False
        break

    if code == "1234":
        success = True
        break

    print("Неправильно...попробуйте снова")

if success:
    print("Правильный PIN введен!")
else:
    print("Слишком много попыток...")
```

Эта версия ведет себя странно, когда пользователь вводит правильный код на третьей попытке:

<sample-output>

Пожалуйста, введите ваш PIN: **0000**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **9999**
Неправильно...попробуйте снова
Пожалуйста, введите ваш PIN: **1234**
Слишком много попыток...

</sample-output>

Итак, давайте попробуем найти причину, добавив некоторые стратегические отладочные операторы печати внутри цикла:

```python
while True:
    print("начало блока while:")
    code = input("Пожалуйста, введите ваш PIN: ")
    attempts += 1

    print("попытки:", attempts)
    print("условие1:", attempts == 3)
    if attempts == 3:
        success = False
        break

    print("код:", code)
    print("условие2:", code == "1234")
    if code == "1234":
        success = True
        break

    print("Неправильно...попробуйте снова")
```

<sample-output>

начало блока while:
Пожалуйста, введите ваш PIN: **2233**
попытки: 1
условие1: False
код: 2233
условие2: False
Неправильно...попробуйте снова
начало блока while:
Пожалуйста, введите ваш PIN: **4545**
попытки: 2
условие1: False
код: 4545
условие2: False
Неправильно...попробуйте снова
начало блока while:
Пожалуйста, введите ваш PIN: **1234**
попытки: 3
условие1: True
Слишком много попыток...

</sample-output>

Из приведенных выше выводов мы можем видеть, что во время третьей итерации цикла условие первого оператора `if` является `True`, и цикл завершается. Эта итерация никогда не доходит до второго оператора `if`, который проверяет, был ли код введен правильно:

```python
  while True:
    # ....

    # этот блок выполняется слишком рано
    if attempts == 3:
        success = False
        break

    # третья итерация никогда не доходит сюда
    if code == "1234":
        success = True
        break
```

Порядок условных операторов, или различных ветвей внутри условного оператора, является частой причиной ошибок, особенно в циклах. Отладочные операторы печати часто являются самым простым способом найти их причину.

<in-browser-programming-exercise name="PIN и количество попыток" tmcname="part02-19_pin_and_number_of_attempts" title="PIN и количество попыток">

Пожалуйста, напишите программу, которая продолжает спрашивать у пользователя PIN-код до тех пор, пока он не введет правильный, который является _4321_. Программа должна затем вывести количество раз, которое пользователь попробовал разные коды.

<sample-output>

PIN: **3245**
Неправильно
PIN: **1234**
Неправильно
PIN: **0000**
Неправильно
PIN: **4321**
Правильно! Вам потребовалось 4 попытки

</sample-output>

Если пользователь угадывает с первого раза, программа должна вывести что-то немного другое:

<sample-output>

PIN: **4321**
Правильно! Вам потребовалась всего одна попытка!

</sample-output>

</in-browser-programming-exercise>


<in-browser-programming-exercise name="Следующий високосный год" tmcname="part02-20_next_leap_year" title="Следующий високосный год">

Пожалуйста, напишите программу, которая спрашивает у пользователя год и выводит следующий високосный год.

<sample-output>

Год: **2023**
Следующий високосный год после 2023 это 2024

</sample-output>

Если пользователь вводит год, который является високосным (например 2024), программа должна вывести следующий високосный год:

<sample-output>

Год: **2024**
Следующий високосный год после 2024 это 2028

</sample-output>

</in-browser-programming-exercise>

## Объединение строк с оператором +

Приведенный выше пример с проверкой PIN использовал вспомогательную переменную `attempts` для отслеживания того, сколько раз пользователь пытался ввести код:

```python
attempts = 0

while True:
    code = input("Пожалуйста, введите ваш PIN: ")
    attempts += 1
    # ...
```

Переменная устанавливается в ноль вне цикла, и каждая итерация увеличивает ее значение на единицу.

Похожая идея увеличения работает и со строковыми переменными. Программа может, например, отслеживать все PIN-коды, которые пользователь ввел:

```python

codes = ""
attempts = 0

while True:
    code = input("Пожалуйста, введите ваш PIN: ")
    attempts += 1
    codes += code + ", "
    # ...
```

Вспомогательная переменная инициализируется _пустой строкой_, то есть строкой без символов в ней:

```python
codes = ""
```

С каждой итерацией строка становится длиннее, поскольку код, который пользователь ввел, добавляется вместе с запятой:

```python
    code = input("Пожалуйста, введите ваш PIN: ")
    codes += code + ", "
```

Если пользователь вводит коды _1111 2222 1234_, в конце выполнения программы значение `codes` будет

<sample-output>

1111, 2222, 1234,

</sample-output>


<in-browser-programming-exercise name="История" tmcname="part02-21_story" title="История">

### Часть 1

Пожалуйста, напишите программу, которая продолжает спрашивать у пользователя слова. Если пользователь вводит `конец`, программа должна вывести историю, которую сформировали слова, и закончить.

<sample-output>

Пожалуйста, введите слово: **Жили**
Пожалуйста, введите слово: **были**
Пожалуйста, введите слово: **дед**
Пожалуйста, введите слово: **да**
Пожалуйста, введите слово: **баба**
Пожалуйста, введите слово: **и**
Пожалуйста, введите слово: **была**
Пожалуйста, введите слово: **у**
Пожалуйста, введите слово: **них**
Пожалуйста, введите слово: **курочка**
Пожалуйста, введите слово: **конец**
Жили были дед да баба и была у них курочка

</sample-output>

### Часть 2

Измените программу так, чтобы цикл завершался также, если пользователь вводит одно и то же слово два раза подряд.

<sample-output>

Пожалуйста, введите слово: **Это**
Пожалуйста, введите слово: **была**
Пожалуйста, введите слово: **темная**
Пожалуйста, введите слово: **и**
Пожалуйста, введите слово: **бурная**
Пожалуйста, введите слово: **ночь**
Пожалуйста, введите слово: **ночь**
Это была темная и бурная ночь

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Работа с числами" tmcname="part02-22_working_with_numbers" title="Работа с числами">

### Предзадача

Пожалуйста, напишите программу, которая спрашивает у пользователя целые числа. Программа должна продолжать спрашивать числа до тех пор, пока пользователь не введет ноль.

<sample-output>

Пожалуйста, введите целые числа. Введите 0 для завершения.
Число: **5**
Число: **22**
Число: **9**
Число: **-2**
Число: **0**

</sample-output>

### Часть 1: Подсчет

После чтения чисел программа должна вывести, сколько чисел было введено. Ноль в конце не должен включаться в подсчет.

Вам понадобится новая переменная здесь для отслеживания введенных чисел.

<sample-output>

... программа спрашивает числа
Введено чисел: 4

</sample-output>

### Часть 2: Сумма

Программа должна также вывести сумму всех введенных чисел. Ноль в конце не должен включаться в вычисление.

Программа должна теперь вывести следующее:

<sample-output>

... программа спрашивает числа
Введено чисел: 4
Сумма чисел: 34

</sample-output>

### Часть 3: Среднее

Программа должна также вывести среднее значение чисел. Ноль в конце не должен включаться в вычисление. Вы можете предположить, что пользователь всегда введет хотя бы одно действительное ненулевое число.

<sample-output>

... программа спрашивает числа
Введено чисел: 4
Сумма чисел: 34
Среднее значение чисел: 8.5

</sample-output>

#### Часть 4: Положительные и отрицательные

Программа должна также вывести статистику о том, сколько из чисел были положительными и сколько были отрицательными. Ноль в конце не должен включаться в вычисление.

<sample-output>

... программа спрашивает числа
Введено чисел: 4
Сумма чисел: 34
Среднее значение чисел: 8.5
Положительных чисел: 3
Отрицательных чисел: 1

</sample-output>

</in-browser-programming-exercise>

<!--

A quiz to review the contents of this section:

<quiz id="63a51999-e525-5f1d-a333-b26392a5585b"></quiz>

-->

Пожалуйста, ответьте на короткую анкету о материалах этой недели.

<quiz id="5ab8aa39-8d52-5fb7-ac91-253bba93c84b"></quiz>