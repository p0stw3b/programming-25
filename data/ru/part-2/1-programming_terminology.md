---
path: '/ru/part-2/1-programming-terminology'
title: 'Терминология программирования'
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знакомы с некоторой основной терминологией программирования
- Вы будете знать разницу между оператором и выражением
- Вы сможете узнавать тип данных вычисленного выражения
- Вы научитесь использовать методы отладки для поиска ошибок в коде

</text-box>

В первой части курса мы не уделяли много внимания терминологии, поэтому давайте рассмотрим некоторые центральные концепции программирования.

## Оператор

_Оператор_ - это часть программы, которая что-то выполняет. Часто, но не всегда, он относится к одной команде.

Например, `print("Привет!")` - это оператор, который выводит строку текста. Аналогично, `number = 2` - это оператор, который присваивает значение переменной.

Оператор также может быть более сложным. Он может, например, содержать другие операторы. Следующий оператор занимает три строки:

```python
if name == "Анна":
    print("Привет!")
    number = 2
```

В приведенном выше случае есть два оператора (оператор вывода и оператор присваивания) внутри условного оператора.

## Блок

_Блок_ - это группа последовательных операторов, которые находятся на одном уровне в структуре программы. Например, блок условного оператора содержит те операторы, которые выполняются только если условие истинно.

```python
if age > 17:
    # начало условного блока
    print("Вы совершеннолетний!")
    age = age + 1
    print("Теперь вы стали на год старше...")
    # конец условного блока

print("Это здесь принадлежит другому блоку")
```

В Python блоки выражаются отступами всего кода в блоке на одинаковое количество пробелов.

Примечание: главный блок программы Python всегда должен находиться у левого края файла, без отступов:

```python
# эта программа не будет работать, потому что она не написана у левого края файла
  print("привет мир")
  print("эта программа не очень хороша...")
```

## Выражение

_Выражение_ - это часть кода, которая имеет определенный тип данных. Когда программа выполняется, выражение вычисляется так, что оно имеет значение, которое затем можно использовать в программе.

Вот несколько примеров выражений:

| Выражение | Значение  | Тип    | Тип данных Python |
|-----------|-----------|--------|-------------------|
|`2 + 4 + 3` | `9`      | целое число | `int` |
|`"abc" + "de"` | `"abcde"` | строка | `str`|
|`11 / 2`    | `5.5`    | число с плавающей точкой | `float` |
|`2 * 5 > 9` | `True`   | логическое значение | `bool`|

Поскольку все выражения имеют тип, их можно присваивать переменным:

```python
# переменной x присваивается значение выражения 1 + 2
x = 1 + 2
```

Простые выражения могут объединяться для формирования более сложных выражений, например, с арифметическими операциями:

```python
# переменной y присваивается значение выражения '3 умножить на x плюс x в квадрате'
y = 3 * x + x**2
```

## Функция

_Функция_ выполняет некоторую функциональность. Функции также могут принимать один или несколько _аргументов_, которые представляют данные, которые могут быть переданы в функцию и обработаны ею. Аргументы иногда также называются _параметрами_. Есть техническое различие между аргументом и параметром, но слова часто используются взаимозаменяемо. Пока достаточно помнить, что оба термина относятся к идее передачи каких-то данных в функцию.

Функция выполняется, когда она _вызывается_. То есть, когда функция (и ее аргументы, если есть) упоминается в коде. Следующий оператор вызывает функцию `print` с аргументом `"это аргument"`:

```python
print("это аргумент")
```

Другая функция, которую вы уже часто использовали, - это функция `input`, которая запрашивает у пользователя ввод. Аргумент этой функции - это сообщение, которое показывается пользователю:

```python
name = input("Пожалуйста, введите ваше имя: ")
```

В данном случае функция также _возвращает_ значение. После выполнения функции участок кода, где она была вызвана, заменяется значением, которое она возвращает; это еще одно выражение, которое теперь было вычислено. Функция `input` возвращает строковое значение, содержащее то, что пользователь ввел в приглашении. Значение, которое возвращает функция, часто сохраняется в переменной, чтобы его можно было использовать в программе позже.

## Тип данных

_Тип данных_ относится к характеристикам любого значения, присутствующего в программе. В следующем фрагменте кода тип данных переменной `name` - строка или `str`, а тип данных переменной `result` - целое число или `int`:

```python
name = "Анна"
result = 100
```

Вы можете использовать функцию `type` для определения типа данных любого выражения. Пример ее использования:

```python
print(type("Анна"))
print(type(100))
```

<sample-output>

<class 'str'>
<class 'int'>

</sample-output>

## Синтаксис

Подобно естественным языкам, _синтаксис_ языка программирования определяет, как должен быть написан код программы. Каждый язык программирования имеет свой собственный специфический синтаксис.

Синтаксис Python определяет, помимо прочего, что первая строка оператора `if` должна заканчиваться двоеточием, а блок оператора должен быть с отступом:

```python
if name == "Анна":
    print("Привет!")
```

Если синтаксические правила языка программирования не соблюдаются, будет ошибка:

```python
if name == "Анна"
    print("Привет!")
```

<sample-output>

<pre>
  File "test.py", line 1
    if name == "Анна"
                    ^
SyntaxError: invalid syntax
</pre>


</sample-output>

## Отладка

Если синтаксис программы правильный, но программа все еще не функционирует как задумано, в программе есть _ошибка_.

Ошибки проявляются по-разному. Некоторые ошибки вызывают ошибку во время выполнения. Например, следующая программа

```python
x = 10
y = 0
result = x / y

print(f"{x} разделить на {y} равно {result}")
```

вызывает эту ошибку:

<sample-output>

<pre>
ZeroDivisionError: integer division or modulo by zero on line 3
</pre>

</sample-output>

Проблема здесь имеет математическую природу: деление на ноль не допускается, и это останавливает выполнение программы.

Ошибки во время выполнения обычно довольно легко исправить, поскольку сообщение об ошибке указывает строку кода, вызывающую ошибку. Конечно, фактическая причина ошибки может находиться где-то совершенно в другом месте, чем строка кода, вызывающая ошибку.

Иногда ошибка в программе обнаруживается, потому что результат, который производит код, неправильный. Обнаружение и локализация этого типа ошибки может быть сложной задачей. В программных упражнениях этого курса тесты обычно предназначены для выявления ошибок этого типа. Прежде чем ошибка может быть исправлена, ее причина должна быть сначала найдена.

Программистский жаргон называет обнаружение причин ошибок _отладкой_. Это чрезвычайно важный навык в арсенале любого программиста. Профессиональные программисты часто тратят больше времени на отладку, чем на написание нового кода.

Простой, но эффективный способ отладки программы - добавление отладочных операторов печати в код. Проверка результатов вашего кода с помощью команд `print` дает быстрое подтверждение того, что код делает то, что вы хотите.

Следующее - это попытка решить одно из упражнений из [предыдущего раздела](/ru/part-1/5-conditional-statements):

```python
hourly_wage = float(input("Почасовая оплата: "))
hours = int(input("Отработанные часы: "))
day = input("День недели: ")

daily_wages = hourly_wage * hours
if day == "воскресенье":
    daily_wages * 2

print(f"Дневная зарплата: {daily_wages} евро")
```

Программа работает не совсем правильно. Выполнение тестов выводит следующее:

<sample-output>

<pre>
FAIL: PythonEditorTest: test_sunday_1

With input 20.0,6,воскресенье correct wage 240.0 is not found in output Дневная зарплата: 120.0 евро
</pre>

</sample-output>

При отладке упражнений этого курса первый шаг часто состоит в проверке того, как программа ведет себя с входными данными, указанными в неудачном тесте. Действительно, результат не тот, что ожидался:

<sample-output>

Дневная зарплата: 120.0 евро

</sample-output>

Отладка обычно означает многократный запуск программы. Может быть удобно временно "жестко закодировать" проблематичный ввод вместо того, чтобы каждый раз просить пользователя о вводе. В данном случае жесткое кодирование могло бы выглядеть так:

```python
# hourly_wage = float(input("Почасовая оплата: "))
# hours = int(input("Отработанные часы: "))
# day = input("День недели: ")
hourly_wage = 20.0
hours = 6
day = "воскресенье"

daily_wages = hourly_wage * hours
if day == "воскресенье":
    daily_wages * 2

print(f"Дневная зарплата: {daily_wages} евро")
```

Следующим шагом могло бы быть добавление _отладочных операторов печати_. Проблемная часть кода находится в разделе, касающемся воскресенья, поэтому давайте добавим команды `print` до и после строки, которая должна удваивать дневную зарплату по воскресеньям:

```python
# ...

daily_wages = hourly_wage * hours
if day == "воскресенье":
    print("зарплата до:", daily_wages)
    daily_wages * 2
    print("зарплата после удвоения:", daily_wages)

print(f"Дневная зарплата: {daily_wages} евро")
```

Запуск кода теперь ничего не показывает - отладочные операторы печати вообще не печатаются. Кажется, что содержимое блока `if` никогда не выполняется, поэтому должна быть проблема с условным оператором. Давайте попробуем вывести значение логического выражения:

```python
# ...

daily_wages = hourly_wage * hours
print("условие:", day == "воскресенье")
if day == "воскресенье":
    print("зарплата до:", daily_wages)
    daily_wages * 2
    print("зарплата после удвоения:", daily_wages)

print(f"Дневная зарплата: {daily_wages} евро")
```

Действительно, значение `False`, поэтому содержимое блока if никогда не выполняется:

<sample-output>

условие:  False
Дневная зарплата: 120.0 евро

</sample-output>

Проблема должна тогда лежать в условии оператора `if`. Как во многих ситуациях программирования, регистр букв имеет значение также в сравнениях. Обратите внимание, как "воскресенье" в логическом выражении не было написано с заглавной буквы, но во вводе было. Давайте исправим это (и в команде `print`, и в операторе `if`):

```python
# ...

daily_wages = hourly_wage * hours
print("условие:", day == "Воскресенье")
if day == "Воскресенье":
    print("зарплата до:", daily_wages)
    daily_wages * 2
    print("зарплата после удвоения:", daily_wages)

print(f"Дневная зарплата: {daily_wages} евро")
```

Запуск этого выводит следующее:

<sample-output>

условие: True
зарплата до: 120
зарплата после удвоения: 120
Дневная зарплата: 120.0 евро

</sample-output>

Кажется, значение, хранящееся в `daily_wages`, сначала правильное: `hourly_wage = 20.0` и `hours = 6`, и 20.0 * 6 = 120.0. Команда, которая должна удваивать цифру, однако этого не делает, поэтому должна быть проблема с командой. И действительно команда

```python
daily_wages * 2
```

удваивает значение, но не сохраняет новое значение нигде. Давайте изменим ее так, чтобы она также сохраняла новое значение:

```python
daily_wages *= 2
```

Повторный запуск программы показывает, что вывод в конце теперь также правильный:

<sample-output>

условие: True
зарплата до: 120
зарплата после удвоения: 240
Дневная зарплата: 240.0 евро

</sample-output>

Когда программа исправлена, не забудьте удалить все отладочные операторы печати и другой код, добавленный для отладки.

Этот пример был довольно простым, и в такой короткой программе можно было бы, вероятно, выяснить ошибки просто внимательно прочитав код. Однако использование отладочных операторов печати часто является быстрым способом получить представление о том, где может лежать проблема. Операторы печати можно использовать для выяснения, какие части программы, кажется, работают правильно, поэтому усилия по отслеживанию ошибок могут быть сконцентрированы на разделах кода, которые являются наиболее вероятными виновниками.

Отладочные операторы печати - это только один инструмент для отладки программ. Мы вернемся к этой теме позже в ходе этого курса. Вы должны теперь привыкнуть использовать отладочные операторы печати для поиска ошибок в коде. Профессиональные программисты не могут обойтись без их использования, поэтому это очень полезный инструмент и для начинающих.

<in-browser-programming-exercise name="Исправить синтаксис" tmcname="part02-01_fix_syntax" height="400px" title="Исправить синтаксис">

Следующая программа содержит несколько _синтаксических ошибок_. Пожалуйста, исправьте программу так, чтобы синтаксис был в порядке и программа работала, как указано в примерах ниже.

```python
  number = input("Пожалуйста, введите число: ")
  if number>100
    print("Число было больше ста")
    number - 100
    print("Теперь его значение уменьшилось на сто)
     print("Его значение сейчас"+ number)
 print(number + " должно быть моим счастливым числом!")
 print("Хорошего дня!)
```

<sample-output>

Пожалуйста, введите число: **13**
13 должно быть моим счастливым числом!
Хорошего дня!

</sample-output>

<sample-output>

Пожалуйста, введите число: **101**
Число было больше ста
Теперь его значение уменьшилось на сто
Его значение сейчас 1
1 должно быть моим счастливым числом!
Хорошего дня!

</sample-output>

</in-browser-programming-exercise>


<in-browser-programming-exercise name="Количество символов" tmcname="part02-02_number_of_characters" title="Количество символов">

Функция `len` может использоваться для определения длины строки, среди прочего. Функция возвращает количество символов в строке.

Несколько примеров того, как это работает:

```python
word = "abcd"
print(len(word))

print(len("привет"))

word2 = "howdydoody"
length = len(word2)
print(length)

empty_string = ""
length = len(empty_string)
print(length)
```

<sample-output>

4
6
10
0

</sample-output>

Пожалуйста, напишите программу, которая просит пользователя ввести слово, а затем выводит количество символов, если было введено больше одного.

Примеры ожидаемого поведения:

<sample-output>

Пожалуйста, введите слово: **привет**
В слове привет 6 букв
Спасибо!

</sample-output>

<sample-output>

Пожалуйста, введите слово: **банан**
В слове банан 5 букв
Спасибо!

</sample-output>

<sample-output>

Пожалуйста, введите слово: **б**
Спасибо!

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Приведение типов" tmcname="part02-03_typecasting" title="Приведение типов">

При программировании на Python часто нам нужно изменить тип данных значения. Например, число с плавающей точкой может быть преобразовано в целое число с помощью функции `int`:

```python

temperature = float(input("Пожалуйста, введите температуру: "))

print("Температура", temperature)

print("...а округленная вниз это", int(temperature))

```

<sample-output>

Пожалуйста, введите температуру: **5.15**
Температура 5.15
...а округленная вниз это 5

</sample-output>

Обратите внимание, функция всегда округляет вниз, а не согласно правилам округления в математике. Это пример _функции пола_.

<sample-output>

Пожалуйста, введите температуру: **8.99**
Температура 8.99
...а округленная вниз это 8

</sample-output>

Пожалуйста, напишите программу, которая просит пользователя ввести число с плавающей точкой, а затем выводит целую часть и десятичную часть отдельно. Используйте функцию Python `int`.

Вы можете предположить, что число, данное пользователем, всегда больше нуля.

Пример ожидаемого поведения:

<sample-output>

Пожалуйста, введите число: **1.34**
Целая часть: 1
Десятичная часть: 0.34

</sample-output>

</in-browser-programming-exercise>

<!--

A quiz to review the contents of this section:

<quiz id="eb4b41d3-b83b-5815-a1d5-ae9b377aa274"></quiz>


-->