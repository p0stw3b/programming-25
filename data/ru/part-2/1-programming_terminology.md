---
path: '/ru/part-2/1-programming-terminology'
title: 'Терминология программирования'
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знакомы с некоторой основной терминологией программирования
- Вы будете знать разницу между оператором и выражением
- Вы сможете узнавать тип данных вычисленного выражения
- Вы научитесь использовать методы отладки для поиска ошибок в коде

</text-box>

В первой части курса мы не уделяли много внимания терминологии, поэтому давайте рассмотрим некоторые центральные концепции программирования.

## Оператор

_Оператор_ - это часть программы, которая что-то выполняет. Часто, но не всегда, он относится к одной команде.

Например, `print("Привет!")` - это оператор, который выводит строку текста. Аналогично, `number = 2` - это оператор, который присваивает значение переменной.

Оператор также может быть более сложным. Он может, например, содержать другие операторы. Следующий оператор занимает три строки:

```python
if name == "Anna":
    print("Hi!")
    number = 2
```

В приведенном выше случае есть два оператора (оператор вывода и оператор присваивания) внутри условного оператора.

## Блок

_Блок_ - это группа последовательных операторов, которые находятся на одном уровне в структуре программы. Например, блок условного оператора содержит те операторы, которые выполняются только если условие истинно.

```python
if age > 17:
    # beginning of the conditional block
    print("You are of age!")
    age = age + 1
    print("You are now one year older...")
    # end of the conditional block

print("This here belongs to another block")
```

В Python блоки выражаются отступами всего кода в блоке на одинаковое количество пробелов.

Примечание: главный блок программы Python всегда должен находиться у левого края файла, без отступов:

```python
# this program will not work because it is not written at the leftmost egde of the file
  print("hello world")
  print("this program is not very good...")
```

## Выражение

_Выражение_ - это часть кода, которая имеет определенный тип данных. Когда программа выполняется, выражение вычисляется так, что оно имеет значение, которое затем можно использовать в программе.

Вот несколько примеров выражений:

| Выражение | Значение  | Тип    | Тип данных Python |
|-----------|-----------|--------|-------------------|
|`2 + 4 + 3` | `9`      | целое число | `int` |
|`"abc" + "de"` | `"abcde"` | строка | `str`|
|`11 / 2`    | `5.5`    | число с плавающей точкой | `float` |
|`2 * 5 > 9` | `True`   | логическое значение | `bool`|

Поскольку все выражения имеют тип, их можно присваивать переменным:

```python
# the variable x is assigned the value of the expression 1 + 2
x = 1 + 2
```

Простые выражения могут объединяться для формирования более сложных выражений, например, с арифметическими операциями:

```python
# the variable y is assigned the value of the expression '3 times x plus x squared'
y = 3 * x + x**2
```

## Функция

_Функция_ выполняет некоторую функциональность. Функции также могут принимать один или несколько _аргументов_, которые представляют данные, которые могут быть переданы в функцию и обработаны ею. Аргументы иногда также называются _параметрами_. Есть техническое различие между аргументом и параметром, но слова часто используются взаимозаменяемо. Пока достаточно помнить, что оба термина относятся к идее передачи каких-то данных в функцию.

Функция выполняется, когда она _вызывается_. То есть, когда функция (и ее аргументы, если есть) упоминается в коде. Следующий оператор вызывает функцию `print` с аргументом `"это аргument"`:

```python
print("this is an argument")
```

Другая функция, которую вы уже часто использовали, - это функция `input`, которая запрашивает у пользователя ввод. Аргумент этой функции - это сообщение, которое показывается пользователю:

```python
name = input("Please type in your name: ")
```

В данном случае функция также _возвращает_ значение. После выполнения функции участок кода, где она была вызвана, заменяется значением, которое она возвращает; это еще одно выражение, которое теперь было вычислено. Функция `input` возвращает строковое значение, содержащее то, что пользователь ввел в приглашении. Значение, которое возвращает функция, часто сохраняется в переменной, чтобы его можно было использовать в программе позже.

## Тип данных

_Тип данных_ относится к характеристикам любого значения, присутствующего в программе. В следующем фрагменте кода тип данных переменной `name` - строка или `str`, а тип данных переменной `result` - целое число или `int`:

```python
name = "Anna"
result = 100
```

Вы можете использовать функцию `type` для определения типа данных любого выражения. Пример ее использования:

```python
print(type("Anna"))
print(type(100))
```

<sample-output>

<class 'str'>
<class 'int'>

</sample-output>

## Синтаксис

Подобно естественным языкам, _синтаксис_ языка программирования определяет, как должен быть написан код программы. Каждый язык программирования имеет свой собственный специфический синтаксис.

Синтаксис Python определяет, помимо прочего, что первая строка оператора `if` должна заканчиваться двоеточием, а блок оператора должен быть с отступом:

```python
if name == "Anna":
    print("Hi!")
```

Если синтаксические правила языка программирования не соблюдаются, будет ошибка:

```python
if name == "Anna"
    print("Hi!")
```

<sample-output>

<pre>
  File "test.py", line 1
    if name == "Anna"
                    ^
SyntaxError: invalid syntax
</pre>


</sample-output>

## Отладка

Если синтаксис программы правильный, но программа все еще не функционирует как задумано, в программе есть _ошибка_.

Ошибки проявляются по-разному. Некоторые ошибки вызывают ошибку во время выполнения. Например, следующая программа

```python
x = 10
y = 0
result = x / y

print(f"{x} divided by {y} is {result}")
```

вызывает эту ошибку:

<sample-output>

<pre>
ZeroDivisionError: integer division or modulo by zero on line 3
</pre>

</sample-output>

Проблема здесь имеет математическую природу: деление на ноль не допускается, и это останавливает выполнение программы.

Ошибки во время выполнения обычно довольно легко исправить, поскольку сообщение об ошибке указывает строку кода, вызывающую ошибку. Конечно, фактическая причина ошибки может находиться где-то совершенно в другом месте, чем строка кода, вызывающая ошибку.

Иногда ошибка в программе обнаруживается, потому что результат, который производит код, неправильный. Обнаружение и локализация этого типа ошибки может быть сложной задачей. В программных упражнениях этого курса тесты обычно предназначены для выявления ошибок этого типа. Прежде чем ошибка может быть исправлена, ее причина должна быть сначала найдена.

Программистский жаргон называет обнаружение причин ошибок _отладкой_. Это чрезвычайно важный навык в арсенале любого программиста. Профессиональные программисты часто тратят больше времени на отладку, чем на написание нового кода.

Простой, но эффективный способ отладки программы - добавление отладочных операторов печати в код. Проверка результатов вашего кода с помощью команд `print` дает быстрое подтверждение того, что код делает то, что вы хотите.

Следующее - это попытка решить одно из упражнений из [предыдущего раздела](/ru/part-1/5-conditional-statements):

```python
hourly_wage = float(input("Hourly wage: "))
hours = int(input("Hours worked: "))
day = input("Day of the week: ")

daily_wages = hourly_wage * hours
if day == "sunday":
    daily_wages * 2

print(f"Daily wages: {daily_wages} euros")
```

Программа работает не совсем правильно. Выполнение тестов выводит следующее:

<sample-output>

<pre>
FAIL: PythonEditorTest: test_sunday_1

With input 20.0,6,Sunday correct wage 240.0 is not found in output Daily wages: 120.0 euros
</pre>

</sample-output>

При отладке упражнений этого курса первый шаг часто состоит в проверке того, как программа ведет себя с входными данными, указанными в неудачном тесте. Действительно, результат не тот, что ожидался:

<sample-output>

Daily wages: 120.0 euros

</sample-output>

Отладка обычно означает многократный запуск программы. Может быть удобно временно "жестко закодировать" проблематичный ввод вместо того, чтобы каждый раз просить пользователя о вводе. В данном случае жесткое кодирование могло бы выглядеть так:

```python
# hourly_wage = float(input("Hourly wage: "))
# hours = int(input("Hours worked: "))
# day = input("Day of the week: ")
hourly_wage = 20.0
hours = 6
day = "Sunday"

daily_wages = hourly_wage * hours
if day == "sunday":
    daily_wages * 2

print(f"Daily wages: {daily_wages} euros")
```

Следующим шагом могло бы быть добавление _отладочных операторов печати_. Проблемная часть кода находится в разделе, касающемся воскресенья, поэтому давайте добавим команды `print` до и после строки, которая должна удваивать дневную зарплату по воскресеньям:

```python
# ...

daily_wages = hourly_wage * hours
if day == "sunday":
    print("wages before:", daily_wages)
    daily_wages * 2
    print("wages after doubling:", daily_wages)

print(f"Daily wages: {daily_wages} euros")
```

Запуск кода теперь ничего не показывает - отладочные операторы печати вообще не печатаются. Кажется, что содержимое блока `if` никогда не выполняется, поэтому должна быть проблема с условным оператором. Давайте попробуем вывести значение логического выражения:

```python
# ...

daily_wages = hourly_wage * hours
print("condition:", day == "sunday")
if day == "sunday":
    print("wages before:", daily_wages)
    daily_wages * 2
    print("wages after doubling:", daily_wages)

print(f"Daily wages: {daily_wages} euros")
```

Действительно, значение `False`, поэтому содержимое блока if никогда не выполняется:

<sample-output>

condition:  False
Daily wages: 120.0 euros

</sample-output>

Проблема должна тогда лежать в условии оператора `if`. Как во многих ситуациях программирования, регистр букв имеет значение также в сравнениях. Обратите внимание, как "воскресенье" в логическом выражении не было написано с заглавной буквы, но во вводе было. Давайте исправим это (и в команде `print`, и в операторе `if`):

```python
# ...

daily_wages = hourly_wage * hours
print("condition:", day == "Sunday")
if day == "Sunday":
    print("wages before:", daily_wages)
    daily_wages * 2
    print("wages after doubling:", daily_wages)

print(f"Daily wages: {daily_wages} euros")
```

Запуск этого выводит следующее:

<sample-output>

condition: True
wages before: 120
wages after doubling: 120
Daily wages: 120.0 euros

</sample-output>

Кажется, значение, хранящееся в `daily_wages`, сначала правильное: `hourly_wage = 20.0` и `hours = 6`, и 20.0 * 6 = 120.0. Команда, которая должна удваивать цифру, однако этого не делает, поэтому должна быть проблема с командой. И действительно команда

```python
daily_wages * 2
```

удваивает значение, но не сохраняет новое значение нигде. Давайте изменим ее так, чтобы она также сохраняла новое значение:

```python
daily_wages *= 2
```

Повторный запуск программы показывает, что вывод в конце теперь также правильный:

<sample-output>

condition: True
wages before: 120
wages after doubling: 240
Daily wages: 240.0 euros

</sample-output>

Когда программа исправлена, не забудьте удалить все отладочные операторы печати и другой код, добавленный для отладки.

Этот пример был довольно простым, и в такой короткой программе можно было бы, вероятно, выяснить ошибки просто внимательно прочитав код. Однако использование отладочных операторов печати часто является быстрым способом получить представление о том, где может лежать проблема. Операторы печати можно использовать для выяснения, какие части программы, кажется, работают правильно, поэтому усилия по отслеживанию ошибок могут быть сконцентрированы на разделах кода, которые являются наиболее вероятными виновниками.

Отладочные операторы печати - это только один инструмент для отладки программ. Мы вернемся к этой теме позже в ходе этого курса. Вы должны теперь привыкнуть использовать отладочные операторы печати для поиска ошибок в коде. Профессиональные программисты не могут обойтись без их использования, поэтому это очень полезный инструмент и для начинающих.

<in-browser-programming-exercise name="Исправить синтаксис" tmcname="part02-01_fix_syntax" height="400px" title="Исправить синтаксис">

Следующая программа содержит несколько _синтаксических ошибок_. Пожалуйста, исправьте программу так, чтобы синтаксис был в порядке и программа работала, как указано в примерах ниже.

```python
  number = input("Please type in a number: ")
  if number>100
    print("The number was greater than one hundred")
    number - 100
    print("Now its value has decreased by one hundred)
     print("Its value is now"+ number)
 print(number + " must be my lucky number!")
 print("Have a nice day!)
```

<sample-output>

Please type in a number: **13**
13 must be my lucky number!
Have a nice day!

</sample-output>

<sample-output>

Please type in a number: **101**
The number was greater than one hundred
Now its value has decreased by one hundred
Its value is now 1
1 must be my lucky number!
Have a nice day!

</sample-output>

</in-browser-programming-exercise>


<in-browser-programming-exercise name="Количество символов" tmcname="part02-02_number_of_characters" title="Количество символов">

Функция `len` может использоваться для определения длины строки, среди прочего. Функция возвращает количество символов в строке.

Несколько примеров того, как это работает:

```python
word = "abcd"
print(len(word))

print(len("hi there"))

word2 = "howdydoody"
length = len(word2)
print(length)

empty_string = ""
length = len(empty_string)
print(length)
```

<sample-output>

4
8
10
0

</sample-output>

Пожалуйста, напишите программу, которая просит пользователя ввести слово, а затем выводит количество символов, если было введено больше одного.

Примеры ожидаемого поведения:

<sample-output>

Please type in a word: **hey**
There are 3 letters in the word hey
Thank you!

</sample-output>

<sample-output>

Please type in a word: **banana**
There are 6 letters in the word banana
Thank you!

</sample-output>

<sample-output>

Please type in a word: **b**
Thank you!

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Приведение типов" tmcname="part02-03_typecasting" title="Приведение типов">

При программировании на Python часто нам нужно изменить тип данных значения. Например, число с плавающей точкой может быть преобразовано в целое число с помощью функции `int`:

```python

temperature = float(input("Please type in a temperature: "))

print("The temperature is", temperature)

print("...and rounded down it is", int(temperature))

```

<sample-output>

Please type in a temperature: **5.15**
The temperature is 5.15
...and rounded down it is 5

</sample-output>

Обратите внимание, функция всегда округляет вниз, а не согласно правилам округления в математике. Это пример _функции пола_.

<sample-output>

Please type in a temperature: **8.99**
The temperature is 8.99
...and rounded down it is 8

</sample-output>

Пожалуйста, напишите программу, которая просит пользователя ввести число с плавающей точкой, а затем выводит целую часть и десятичную часть отдельно. Используйте функцию Python `int`.

Вы можете предположить, что число, данное пользователем, всегда больше нуля.

Пример ожидаемого поведения:

<sample-output>

Please type in a number: **1.34**
Integer part: 1
Decimal part: 0.34

</sample-output>

</in-browser-programming-exercise>

<!--

A quiz to review the contents of this section:

<quiz id="eb4b41d3-b83b-5815-a1d5-ae9b377aa274"></quiz>


-->