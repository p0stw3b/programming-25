---
path: '/ru/part-9/3-encapsulation'
title: 'Инкапсуляция'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После изучения этого раздела

- Вы узнаете, что означает инкапсуляция
- Вы сможете создавать приватные атрибуты
- Вы узнаете, как создавать геттеры и сеттеры для ваших атрибутов

</text-box>

В объектно-ориентированном программировании термин _клиент_ относится к программе, которая использует класс или экземпляры класса. Класс предлагает клиенту _сервисы_, через которые клиент может получить доступ к объектам, созданным на основе класса. Цели здесь таковы:

1) использование класса и/или объектов должно быть максимально простым с точки зрения клиента
2) _целостность_ любого объекта всегда должна сохраняться

Целостность объекта означает, что _состояние_ объекта всегда остается приемлемым. На практике это означает, что значения атрибутов объекта всегда приемлемы. Например, объект, представляющий дату, никогда не должен иметь 13 в качестве значения месяца, объект, моделирующий студента, никогда не должен иметь отрицательное число в качестве значения полученных учебных кредитов, и так далее.

Рассмотрим класс с именем Student:

```python
class Student:
    def __init__(self, name: str, student_number: str):
        self.name = name
        self.student_number = student_number
        self.study_credits = 0

    def add_credits(self, study_credits):
        if study_credits > 0:
            self.study_credits += study_credits
```

Объект `Student` предлагает своим клиентам метод `add_credits`, который позволяет клиенту добавить определенное количество кредитов к общему количеству студента. Метод гарантирует, что значение, переданное в качестве аргумента, больше нуля. Следующий код добавляет учебные кредиты в трех случаях:

```python
sally = Student("Салли Студент", "12345")
sally.add_credits(5)
sally.add_credits(5)
sally.add_credits(10)
print("Учебных кредитов:", sally.study_credits)
```

<sample-output>

Учебных кредитов: 20

</sample-output>

Несмотря на определение метода, все еще возможно получить прямой доступ к атрибуту `study_credits`. Это может привести к ошибочному состоянию, где целостность объекта теряется:

```python
sally = Student("Салли Студент", "12345")
sally.study_credits = -100
print("Учебных кредитов:", sally.study_credits)
```

<sample-output>

Учебных кредитов: -100

</sample-output>

## Инкапсуляция

Общей особенностью объектно-ориентированных языков программирования является то, что классы обычно могут скрывать свои атрибуты от любых потенциальных клиентов. Скрытые атрибуты обычно называются _приватными_. В Python эта приватность достигается добавлением двух подчеркиваний `__` в начало имени атрибута:

```python
class CreditCard:
    # атрибут number является приватным, а атрибут name доступен
    def __init__(self, number: str, name: str):
        self.__number = number
        self.name = name
```

Приватный атрибут не виден непосредственно клиенту. Попытка ссылаться на него вызывает ошибку. В приведенном выше примере атрибут `name` может быть легко получен и изменен:

```python
card = CreditCard("123456","Рэнди Богач")
print(card.name)
card.name = "Чарли Черчмауз"
print(card.name)
```

<sample-output>

Рэнди Богач
Чарли Черчмауз

</sample-output>

Попытка вывести номер карты, однако, вызывает ошибку:

```python
card = CreditCard("123456","Рэнди Богач")
print(card.__number)
```

<sample-output>

AttributeError: 'CreditCard' object has no attribute '__number'

</sample-output>

Сокрытие атрибутов от клиентов называется _инкапсуляцией_. Как следует из названия, атрибут "заключен в капсулу". Клиенту затем предлагается подходящий интерфейс для доступа и обработки данных, хранящихся в объекте.

Добавим еще один инкапсулированный атрибут: баланс на кредитной карте. На этот раз мы также добавим публично видимые методы, которые позволяют клиенту получать доступ и изменять баланс:

```python
class CreditCard:
    def __init__(self, number: str, name: str, balance: float):
        self.__number = number
        self.name = name
        self.__balance = balance

    def deposit_money(self, amount: float):
        if amount > 0:
            self.__balance += amount

    def withdraw_money(self, amount: float):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount

    def retrieve_balance(self):
        return self.__balance
```

```python
card = CreditCard("123456", "Рэнди Богач", 5000)
print(card.retrieve_balance())
card.deposit_money(100)
print(card.retrieve_balance())
card.withdraw_money(500)
print(card.retrieve_balance())
# Следующее не будет работать, потому что баланс недостаточен
card.withdraw_money(10000)
print(card.retrieve_balance())
```

<sample-output>

5000
5100
4600
4600

</sample-output>

Баланс нельзя изменить напрямую, потому что атрибут приватный, но мы включили методы `deposit_money` и `withdraw_money` для изменения значения. Метод `retrieve_balance` возвращает значение, хранящееся в балансе. Методы включают некоторые элементарные проверки для сохранения целостности объекта: например, карта не может быть перерасходована.

<programming-exercise name='Car' tmcname='part09-09_car'>

Реализуйте класс с именем `Car`, который имеет две приватные, _инкапсулированные_ переменные: количество бензина в баке (от 0 до 60 литров) и показание одометра (в километрах). Автомобиль потребляет один литр бензина на километр.

Класс также должен содержать следующие методы:

- `fill_up()` который заправляет бак
- `drive(km:int)` который ведет автомобиль на указанное расстояние или столько, сколько позволяет бензин в баке
- `__str__` который возвращает строковое представление автомобиля согласно примерам ниже

Пример использования класса:

```python
car = Car()
print(car)
car.fill_up()
print(car)
car.drive(20)
print(car)
car.drive(50)
print(car)
car.drive(10)
print(car)
car.fill_up()
car.fill_up()
print(car)
```

<sample-output>

Car: odometer reading 0 km, petrol remaining 0 litres
Car: odometer reading 0 km, petrol remaining 60 litres
Car: odometer reading 20 km, petrol remaining 40 litres
Car: odometer reading 60 km, petrol remaining 0 litres
Car: odometer reading 60 km, petrol remaining 0 litres
Car: odometer reading 60 km, petrol remaining 60 litres

</sample-output>

**Примечание:** вас просят инкапсулировать количество оставшегося бензина и показания одометра. К ним не должно быть возможности получить прямой доступ извне собственных методов класса.

</programming-exercise>

## Краткое замечание о приватных атрибутах, Python и объектно-ориентированном программировании

Существуют способы обойти нотацию с подчеркиванием `__` для сокрытия атрибутов, с которыми вы можете столкнуться при поиске ресурсов в интернете. Никакой атрибут Python не является по-настоящему приватным, и это сделано создателями Python преднамеренно. С другой стороны, от программиста Python обычно ожидается соблюдение рекомендаций по видимости, установленных в классах, и требуется специальное усилие, чтобы обойти их. В других объектно-ориентированных языках программирования, таких как Java, приватные переменные часто действительно скрыты, и лучше думать о приватных переменных Python таким же образом.

## Геттеры и сеттеры

В объектно-ориентированном программировании методы, предназначенные для доступа и изменения атрибутов, обычно называются _геттерами_ и _сеттерами_. Не все программисты Python используют термины "геттер" и "сеттер", но концепция _свойств_, описанная ниже, очень похожа, поэтому мы будем использовать общепринятую терминологию объектно-ориентированного программирования.

Итак, выше мы создали некоторые публичные методы для доступа к приватным атрибутам, но есть более простой, "питоновский" способ доступа к атрибутам. Рассмотрим простой класс с именем `Wallet` с одним приватным атрибутом `money`:

```python
class Wallet:
    def __init__(self):
        self.__money = 0
```

Мы можем добавить методы геттер и сеттер для доступа к приватному атрибуту, используя декоратор `@property`:

```python
class Wallet:
    def __init__(self):
        self.__money = 0

    # Метод геттер
    @property
    def money(self):
        return self.__money

    # Метод сеттер
    @money.setter
    def money(self, money):
        if money >= 0:
            self.__money = money
```

Сначала мы определяем метод геттер, который возвращает количество денег, находящихся в данный момент в кошельке. Затем мы определяем метод сеттер, который устанавливает новое значение для атрибута money, убеждаясь, что новое значение не отрицательное.

Новые методы можно использовать следующим образом:

```python
wallet = Wallet()
print(wallet.money)

wallet.money = 50
print(wallet.money)

wallet.money = -30
print(wallet.money)
```

<sample-output>

0
50
50

</sample-output>

С точки зрения клиента, использование этих новых методов ничем не отличается от прямого доступа к атрибуту. Скобки не нужны; вместо этого вполне приемлемо записать `wallet.money = 50`, как если бы мы просто присваивали значение переменной. Действительно, цель заключалась в том, чтобы скрыть (т.е. инкапсулировать) внутреннюю реализацию атрибута, предлагая при этом легкий способ доступа и изменения данных, хранящихся в объекте.

Предыдущий пример имеет небольшую проблему: клиент не уведомляется о неудаче установки отрицательного значения для атрибута money. Когда предоставленное значение явно неправильно, обычно хорошая идея — вызвать исключение и таким образом уведомить клиента. В этом случае исключение должно быть типа `ValueError`, чтобы обозначить, что предоставленное значение было неприемлемым.

Вот улучшенная версия класса, вместе с кодом для его тестирования:

```python
class Wallet:
    def __init__(self):
        self.__money = 0

    # Метод геттер
    @property
    def money(self):
        return self.__money

    # Метод сеттер
    @money.setter
    def money(self, money):
        if money >= 0:
            self.__money = money
        else:
            raise ValueError("Сумма не должна быть меньше нуля")
```

```python
wallet.money = -30
print(wallet.money)
```

<sample-output>

ValueError: Сумма не должна быть меньше нуля

</sample-output>

**Примечание:** метод геттер, т.е. декоратор `@property`, должен быть введен перед методом сеттером, иначе будет ошибка при выполнении класса. Это потому, что декоратор `@property` определяет имя "атрибута", предлагаемого клиенту. Метод сеттер, добавляемый с `.setter`, просто добавляет к нему новую функциональность.

<programming-exercise name='Recording' tmcname='part09-10_recording'>

Создайте класс с именем `Recording`, который моделирует единственную запись. Класс должен иметь одну приватную переменную: `__length` типа integer.

Реализуйте следующее:

* конструктор, который принимает длительность в качестве аргумента
* метод геттер `length`, который возвращает длительность записи
* метод сеттер, который устанавливает длительность записи

Класс должен быть возможно использовать следующим образом:

```python
the_wall = Recording(43)
print(the_wall.length)
the_wall.length = 44
print(the_wall.length)
```

<sample-output>

43
44

</sample-output>

Если аргумент для конструктора или метода сеттер меньше нуля, это должно вызвать `ValueError`.

Если вам нужно освежить память о вызове исключений, пожалуйста, см. [часть 6](/ru/part-6/3-errors#raising-exceptions) материала курса.

</programming-exercise>

Следующий пример имеет класс с двумя приватными атрибутами, вместе с геттерами и сеттерами для обоих. Попробуйте программу с различными значениями, переданными в качестве аргументов:

```python
class Player:
    def __init__(self, name: str, player_number: int):
        self.__name = name
        self.__player_number = player_number

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name: str):
        if name != "":
            self.__name = name
        else:
            raise ValueError("Имя не может быть пустой строкой")

    @property
    def player_number(self):
        return self.__player_number

    @player_number.setter
    def player_number(self, player_number: int):
        if player_number > 0:
            self.__player_number = player_number
        else:
            raise ValueError("Номер игрока должен быть положительным целым числом")
```

```python
player = Player("Бетти Баллмер", 10)
print(player.name)
print(player.player_number)

player.name = "Бастер Баллмер"
player.player_number = 11
print(player.name)
print(player.player_number)
```

<sample-output>

Бетти Баллмер
10
Бастер Баллмер
11

</sample-output>

Чтобы завершить этот раздел, рассмотрим класс, который моделирует простой дневник. Все атрибуты приватные, но они обрабатываются через различные интерфейсы: владелец дневника имеет методы геттер и сеттер, но записи дневника обрабатываются "традиционными" методами. В этом случае имеет смысл отказать клиенту во всяком доступе к внутренней структуре данных дневника. Только публичные методы непосредственно видимы клиенту.

Инкапсуляция также гарантирует, что внутренняя реализация класса может быть изменена по желанию, при условии, что публичный интерфейс остается неизменным. Клиенту не нужно знать или заботиться о том, основана ли внутренняя структура данных на списках, словарях или чем-то совершенно другом.

```python
class Diary:
    def __init__(self, owner: str):
        self.__owner = owner
        self.__entries = []

    @property
    def owner(self):
        return self.__owner

    @owner.setter
    def owner(self, owner):
        if owner != "":
            self.__owner = owner
        else:
            raise ValueError("Владелец не может быть пустой строкой")

    def add_entry(self, entry: str):
        self.__entries.append(entry)

    def print_entries(self):
        print("Всего", len(self.__entries), "записей")
        for entry in self.__entries:
            print("- " + entry)
```

```python
diary = Diary("Петр")
diary.add_entry("Сегодня я ел кашу")
diary.add_entry("Сегодня я изучал объектно-ориентированное программирование")
diary.add_entry("Сегодня я лег спать рано")
diary.print_entries()
```

<sample-output>

Всего 3 записей
- Сегодня я ел кашу
- Сегодня я изучал объектно-ориентированное программирование
- Сегодня я лег спать рано

</sample-output>

<programming-exercise name='Weather station' tmcname='part09-11_weather_station'>

Создайте класс с именем `WeatherStation`, который используется для хранения наблюдений о погоде. Класс должен иметь следующие публичные атрибуты:

* конструктор, который принимает имя станции в качестве аргумента
* метод с именем `add_observation(observation: str)`, который добавляет наблюдение как последнюю запись в список
* метод с именем `latest_observation()`, который возвращает последнее наблюдение, добавленное в список. Если наблюдений еще нет, метод должен вернуть _пустую строку_.
* метод с именем `number_of_observations()`, который возвращает общее количество добавленных наблюдений
* метод `__str__`, который возвращает имя станции и общее количество добавленных наблюдений согласно примеру ниже.

Все атрибуты должны быть инкапсулированы, чтобы к ним нельзя было получить прямой доступ. Вам решать, как реализовать класс, пока публичный интерфейс точно такой, как описано выше.

Пример использования класса:

```python
station = WeatherStation("Houston")
station.add_observation("Rain 10mm")
station.add_observation("Sunny")
print(station.latest_observation())

station.add_observation("Thunderstorm")
print(station.latest_observation())

print(station.number_of_observations())
print(station)
```

<sample-output>

Sunny
Thunderstorm
3
Houston, 3 observations

</sample-output>

</programming-exercise>