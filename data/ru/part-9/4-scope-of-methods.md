---
path: '/ru/part-9/4-scope-of-methods'
title: 'Область видимости методов'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После изучения этого раздела

- Вы узнаете, как можно ограничить видимость метода в Python
- Вы сможете писать приватные методы

</text-box>

Методы, определенные внутри класса, могут быть скрыты точно так же, как атрибуты в предыдущем разделе. Если метод начинается с двух подчеркиваний `__`, он недоступен напрямую клиенту.

Итак, техника одинакова как для методов, так и для атрибутов, но случаи использования обычно немного отличаются. Приватные атрибуты часто идут в паре с методами getter и setter для контроля доступа к ним. Приватные методы, с другой стороны, обычно предназначены только для внутреннего использования, как вспомогательные методы для процессов, о которых клиент не должен знать.

Приватный метод может использоваться внутри класса как любой другой метод, конечно, не забывая включить префикс `self`. Следующий простой класс представляет получателя электронных писем. Он включает приватный вспомогательный метод для проверки, что адрес электронной почты имеет действительный формат:

```python
class Recipient:
    def __init__(self, name: str, email: str):
        self.__name = name
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")

    def __check_email(self, email: str):
        # A simple check: the address must be over 5 characters long 
        # and contain a dot and an @ character
        return len(email) > 5 and "." in email and "@" in email
```

Попытка вызвать приватный метод напрямую вызывает ошибку:

```python
peter = Recipient("Peter Emailer", "peter@example.com")
peter.__check_email("someone@example.com")
```

<sample-output>

AttributeError: 'Recipient' object has no attribute '__check_email'

</sample-output>

Внутри класса метод может быть доступен нормально, и имеет смысл использовать его также для установки нового значения для адреса. Добавим методы getter и setter для адреса электронной почты:

```python
class Recipient:
    def __init__(self, name: str, email: str):
        self.__name = name
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")

    def __check_email(self, email: str):
        # A simple check: the address must be over 5 characters long 
        # and contain a dot and an @ character
        return len(email) > 5 and "." in email and "@" in email

    @property
    def email(self):
        return self.__email

    @email.setter
    def email(self, email: str):
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")
```

<text-box variant="info" name="Область видимости и пространство имен в Python">

Мы уже встречали термин _область видимости_ в [части 6](/ru/part-6/4-scope-of-variables) этого материала и определили его как разделы программы, где (переменное) имя видимо. Рассматривая термин с другой стороны, он также относится к тому, что видимо из определенной точки в программном коде. Другой связанный термин — _пространство имен_, которое относится к именам, специально доступным в определенной единице Python, такой как класс или определение функции.

Область видимости внутри метода отличается от области видимости внутри класса, которая опять же отличается от области видимости в клиентском коде, который создает экземпляр класса. Метод имеет доступ к своим локальным переменным, но также к атрибутам и другим методам в классе, частью которого он является, даже если они приватные. Класс также имеет доступ к этим своим членам, но он не может напрямую обращаться к локальным переменным внутри своих методов. Клиентский код имеет доступ только к публичным методам и атрибутам, определенным в классе, но, конечно, также к некоторым другим именам в среде, в которой он существует.

Может показаться противоинтуитивным, что класс не имеет доступа ко всему своему содержимому, но это важно для обеспечения целостности. Например, может иметь смысл использовать одно и то же имя локальной переменной в различных методах внутри одного класса, если они выполняют как-то похожие функциональности. Если бы класс имел прямой доступ ко всем локальным переменным внутри методов, их пришлось бы называть по-разному, иначе было бы неясно, какая версия переменной имеется в виду где. Мы уже видели с атрибутами, объявленными с `self`, что вспомогательные переменные не должны быть доступны за пределами метода, поэтому добавление переменных как атрибутов или глобальных переменных не должно быть вариантом. Должен быть способ держать имена в разных частях программы раздельно, и именно для этого служат пространства имен.

Идея пространства имен помогает понять, как одно и то же имя может благополучно сосуществовать в различных функциях, классах или модулях одновременно. Если имя специфично для пространства имен, такого как определение метода, оно недоступно напрямую за его пределами, и поэтому нет причины, почему другое пространство имен не может использовать то же имя. Освоение пространств имен и областей видимости важно для становления опытным программистом, и вы получите много практики на этом курсе.

</text-box>

## Нужен ли мне приватный метод?

В следующем примере класс `DeckOfCards` является моделью колоды из 52 карт. Он содержит вспомогательный метод `__reset_deck`, который создает новую перетасованную колоду карт. Приватный метод в данный момент вызывается только в методе-конструкторе, поэтому реализация может быть размещена напрямую в конструкторе. Однако использование отдельного метода делает код более читаемым и также позволяет получить доступ к функциональности позже в других методах при необходимости.

```python
from random import shuffle

class DeckOfCards:
    def __init__(self):
        self.__reset_deck()

    def __reset_deck(self):
        self.__deck = []
        # Add all 52 cards to the deck
        suits = ["spades", "hearts", "clubs", "diamonds"]
        for suit in suits:
            for number in range(1, 14):
                self.__deck.append((suit, number))
        # Shuffle the deck
        shuffle(self.__deck)

    def deal(self, number_of_cards: int):
        hand = []
        # Move the top cards in the deck to the hand
        for i in range(number_of_cards):
            hand.append(self.__deck.pop())
        return hand
```

Протестируем класс:

```python
deck = DeckOfCards()
hand1 = deck.deal(5)
print(hand1)
hand2 = deck.deal(5)
print(hand2)
```

Поскольку руки генерируются случайно, следующее — это только пример того, что может быть выведено:

<sample-output>

[('spades', 7), ('spades', 11), ('hearts', 7), ('diamonds', 3), ('spades', 4)]
[('clubs', 8), ('spades', 12), ('diamonds', 13), ('clubs', 11), ('spades', 10)]

</sample-output>

Приватные методы в целом менее распространены, чем приватные атрибуты. Как правило, метод должен быть скрыт всякий раз, когда клиент не нуждается в прямом доступе к нему. Это особенно актуально, когда возможно, что клиент может неблагоприятно повлиять на целостность объекта, вызвав метод.

<programming-exercise name='Service charge' tmcname='part09-12_service_charge'>

Создайте класс с именем `BankAccount`, который моделирует банковский счет. Класс должен содержать

* конструктор, который принимает имя владельца (str), номер счета (str) и баланс (float) в качестве аргументов
* метод `deposit(amount: float)` для внесения денег на счет
* метод `withdraw(amount: float)` для снятия денег со счета
* метод getter `balance`, который возвращает баланс счета

Класс также должен содержать приватный метод

* `__service_charge()`, который уменьшает баланс счета на один процент. Всякий раз, когда вызывается любой из методов `deposit` или `withdraw`, этот метод также должен быть вызван. Комиссия за обслуживание рассчитывается и вычитается только после завершения фактической операции (то есть после того, как указанная сумма была добавлена к балансу или вычтена из него).

Все атрибуты данных в определении класса должны быть приватными.

Вы можете использовать следующий код для тестирования класса:

```python
account = BankAccount("Randy Riches", "12345-6789", 1000)
account.withdraw(100)
print(account.balance)
account.deposit(100)
print(account.balance)

```

<sample-output>

891.0
981.09

</sample-output>

</programming-exercise>