---
path: '/ru/part-3/4-defining-functions'
title: 'Определение функций'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После изучения этого раздела

- Вы узнаете, как писать и вызывать свои собственные функции
- Вы поймёте, что означают аргумент и параметр функции
- Вы сможете определять параметры в своих собственных функциях

</text-box>

Мы уже использовали такие функции, как `len`, `print` и `input` в наших программах. Это функции, встроенные в Python, поэтому они всегда готовы к нашим услугам, независимо от того, в какой среде мы программируем. Однако также возможно определять свои собственные функции.

## Определение функции

Прежде чем функция может быть использована, она должна быть определена. Любое определение функции начинается с ключевого слова `def`, сокращение от _define_ (определить). Затем идёт _имя_ функции, за которым следуют скобки и двоеточие. Это называется _заголовком_ функции. После этого, с отступом, как в блоках `while` и `if`, идёт _тело_ функции.

Например, следующий код определяет функцию `message`:

```python
def message():
    print("Это моя собственная функция!")
```

Если выполнить программу выше, ничего не происходит. Это потому, что код в теле функции выполняется только тогда, когда функция _вызывается_.

Вызвать функцию так же просто, как упомянуть её имя в коде. Добавление вызова функции в конец приведённой выше программы, вот так

```python
def message():
    print("Это моя собственная функция!")

message()
```
приводит к выводу строки:

<sample-output>

Это моя собственная функция!

</sample-output>

Когда функция определена, её можно вызывать несколько раз:

```python
def message():
    print("Это моя собственная функция!")

message()
message()
message()
```

<sample-output>

Это моя собственная функция!
Это моя собственная функция!
Это моя собственная функция!

</sample-output>

<text-box variant='hint' name='Тестирование собственных функций'>

Важно: с этого момента большинство упражнений в этом курсе будут просить вас написать свои собственные функции.

Когда программа состоит только из функций, её выполнение не даёт видимого эффекта. Следующий код ничего не выводит, хотя в нём есть оператор print:

```python
def greet():
    print("Привет!")
```

Причина, по которой ничего не выводится, заключается в том, что код внутри тела функции `greet` выполняется только при вызове функции.

"Главная" программа под функцией должна содержать соответствующие вызовы функций, чтобы программу можно было протестировать. Фактически, Python рассматривает весь код, который не находится внутри определений функций, как часть _главной функции_, которая выполняется при оценке или выполнении самого файла. Итак, добавим вызов функции:

```python
def greet():
    print("Привет!")

# Весь код, не находящийся в определениях функций, является частью
# главной функции программы
# Вызываем нашу функцию:

greet()
```

**Важно**: в этом курсе автоматические тесты, которые выполняются на файлах упражнений, требуют пустой главной функции. Никакие команды не должны оставаться в главной функции вашего решения. То есть любой код, который вы сами используете для тестирования, должен содержаться в специально определённом блоке `if`:

```python
def greet():
    print("Привет!")

# Пишите главную функцию в блоке таком образом:
if __name__ == "__main__":
    greet()
```

Любой код, оставленный вне приведённого выше блока, вызывает ошибку:

<img src="../../part-3/3_4_1.png">

Цель этого — убедиться, что ваше решение тестируется на чистом листе, поскольку тесты часто проверяют, что выводят ваши функции. Стоит отметить, что тесты не будут выполнять никакой код из блока `if __name__ == "__main__"`, поэтому никакой код, необходимый для выполнения требований упражнения, не должен помещаться в этот блок.

</text-box>

<in-browser-programming-exercise name="Семь братьев" tmcname="part03-28_seven_brothers" title="Семь братьев">

Пожалуйста, напишите функцию с именем `seven_brothers`. При вызове функция должна вывести имена семи братьев в алфавитном порядке, как в примере ниже. См. [упражнение с похожим именем в части 1](/ru/part-1/1-getting-started#programming-exercise-fix-the-code-seven-brothers) для более подробной информации о братьях.


<sample-output>

Aapo
Eero
Juhani
Lauri
Simeoni
Timo
Tuomas

</sample-output>

</in-browser-programming-exercise>

## Аргументы функции

Функции часто принимают один или несколько _аргументов_, которые могут влиять на то, что делает функция. Например, встроенные функции Python `print` и `input` принимают в качестве аргумента(аргументов) текст, который должен отображаться:

```python
print("Привет!")                              # аргумент - строка "Привет!"
name = input("Как вас зовут? ")                # аргумент - строка "Как вас зовут? "
print(name)                                    # аргумент - значение переменной name
```

Ранее упоминалось, что термины _аргумент_ и _параметр_ часто используются для обозначения одного и того же. Различие состоит в том, что хотя _аргумент_ используется с данными, передаваемыми в функцию при её вызове, _внутри_ функции аргументы присваиваются переменным, называемым _параметрами_. Итак, приблизительно, когда функция вызывается, мы называем переданные фрагменты данных аргументами, но когда мы определяем функцию, мы называем их параметрами.

Это может показаться бесполезным семантическим различием, и чтобы ещё больше запутать дело, не все источники следуют этому определению. В этом курсе мы пытаемся сохранить различие ясным, однако, поскольку знание правильной терминологии поможет вам понимать другие источники помимо материала этого курса.

Давайте определим некоторые функции, которые принимают аргументы. В определении функции параметры определяются в скобках после имени функции:

```python
def hello(target):
    print("Привет", target)
```

Двойной вызов этой функции, вот так

```python
hello("Елена")
hello("мир!")
```

выводит два разных приветствия:

<sample-output>

Привет Елена
Привет мир!

</sample-output>

Давайте внимательнее посмотрим на определение функции:

```python
def hello(target):
    print("Привет", target)
```

В первой строке, в заголовке функции, мы определили, что эта функция принимает аргумент и присваивает его параметру с именем `target`. В теле функции команда `print` использует значение, хранящееся в `target`.

Когда функция вызывается, параметр `target` получает значение, данное как аргумент в вызове функции. Например, следующий вызов функции

```python
name = "Алан"
hello(name)
```

приводит к тому, что параметр `target` устанавливается в значение `"Алан"`.

Имена функций и их параметров следуют тем же принципам, что и имена переменных. Они должны быть описательными и содержать преимущественно строчные буквы и символы подчёркивания. Опять же, есть некоторые исключения из этих рекомендаций, но мы пока будем их игнорировать.

<in-browser-programming-exercise name="Первый символ" tmcname="part03-29_first_character" title="Первый символ">

Упражнение содержит схему функции `first_character`. Пожалуйста, дополните её так, чтобы она выводила первый символ строки, которую она принимает как аргумент.

```python
def first_character(text):
     # напишите ваш код здесь

# тестирование функции:
if __name__ == "__main__":
    first_character('python')
    first_character('жёлтый')
    first_character('завтра')
    first_character('гелиотроп')
    first_character('открыто')
    first_character('ночь')
```

<sample-output>

p
ж
з
г
о
н

</sample-output>

</in-browser-programming-exercise>

<text-box variant='hint' name='Тестирование функций с аргументами'>

Когда ваша функция принимает один или несколько аргументов, рекомендуется тестировать её с различными аргументами.

Обратите особое внимание на "особые случаи", специфические для типа используемого аргумента. Как будет вести себя ваша функция, если аргумент равен нулю или отрицательному числу, или числу с плавающей точкой вместо целого числа? Что происходит, если аргумент — пустая строка?

Если задание упражнения явно не говорит вам включать вызовы функций, вы можете свободно включать свои собственные в блок главной функции `if`, как объяснено выше. Тесты будут игнорировать всё внутри блока if.

</text-box>

## Больше примеров

Давайте рассмотрим ещё несколько примеров функций, которые принимают аргументы. В следующем определении функции параметр — число:

```python
def squared(x):
    print(f"Квадрат числа {x} равен {x * x}")

squared(2)
squared(5)
```

<sample-output>

Квадрат числа 2 равен 4
Квадрат числа 5 равен 25

</sample-output>

Между тем, в этом определении функции есть оператор `if` внутри тела функции:

```python
def hello(name):
    if name == "Елена":
        print("Привет", name)
    else:
        print("Здравствуй", name)

hello("Елена")
hello("Марк")
```

<sample-output>

Привет Елена
Здравствуй Марк

</sample-output>

Эта функция принимает два аргумента:

```python
def sum(x, y):
    result = x + y
    print(f"Сумма аргументов {x} и {y} равна {result}")

sum(1, 2)
sum(5, 24)
```

<sample-output>

Сумма аргументов 1 и 2 равна 3
Сумма аргументов 5 и 24 равна 29

</sample-output>

Функция также включает вспомогательную переменную `result`, которую она использует для хранения суммы своих аргументов.

Обратите внимание, что имена параметров внутри определения функции не имеют никакого отношения к переменным вне её. Мы могли бы точно так же вызвать приведённую выше функцию следующим образом:

```python
x = 100
y = 30
sum(1, 2)
sum(x + y, 10)
```

Это должно вывести

<sample-output>

Сумма аргументов 1 и 2 равна 3
Сумма аргументов 130 и 10 равна 140

</sample-output>

В первом вызове функции параметры получают значения `x = 1` и `y = 2`. Во втором вызове функции они получают значения `x = 130` и `y = 10`, независимо от одноимённых переменных, используемых в вызове функции.

Мы вернёмся к определениям функций в начале следующей части курса.

<!--похожее предупреждение есть в разделах 3-4, 4-6 и 5-1, проверьте их все, если вы изменяете это-->
## Предупреждение: использование глобальных переменных внутри функций

В приведённых выше примерах мы видели, что возможно присваивать новые переменные внутри определений функций. Функция также может видеть переменные, присвоенные вне её, в главной функции. Такие переменные называются _глобальными_ переменными.

Использование глобальных переменных из функций обычно плохая идея. Среди прочих проблем это может вызвать ошибки, которые трудно отследить.

Ниже приведён пример функции, которая использует глобальную переменную "по ошибке":

```python
# это глобальная переменная
name = "Бетти"

def hello(given_name):
    # использование глобальной переменной вместо параметра по ошибке
    print("Привет", name)

hello("Стив")
hello("Бетти")
```

<sample-output>

Привет Бетти
Привет Бетти

</sample-output>

Неважно, с какими разными аргументами мы вызываем функцию, она всегда будет выводить значение `"Бетти"`, хранящееся в глобальной переменной.

<in-browser-programming-exercise name="Среднее значение" tmcname="part03-30_mean" title="Среднее значение">

Пожалуйста, напишите функцию с именем `mean`, которая принимает три целочисленных аргумента. Функция должна вывести арифметическое среднее трёх аргументов.

```python
mean(5, 3, 1)
mean(10, 1, 1)
```

<sample-output>

3.0
4.0

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Печать много раз" tmcname="part03-31_print_many_times" title="Печать много раз">

Пожалуйста, напишите функцию с именем `print_many_times(text, times)`, которая принимает строку и целое число как аргументы. Аргумент-целое число указывает, сколько раз должна быть выведена строка-аргумент:

```python
print_many_times("привет", 5)

print()

text = "Все Питоны, кроме одного, взрослеют"
times = 3
print_many_times(text, times)
```
<sample-output>

привет
привет
привет
привет
привет

Все Питоны, кроме одного, взрослеют
Все Питоны, кроме одного, взрослеют
Все Питоны, кроме одного, взрослеют

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Квадрат из решёток" tmcname="part03-32_square_of_hashes" title="Квадрат из решёток">

Пожалуйста, напишите функцию с именем `hash_square(length)`, которая принимает целочисленный аргумент. Функция выводит квадрат из символов решётки, а аргумент указывает длину стороны квадрата.

```python
hash_square(3)
print()
hash_square(5)
```

<sample-output>

<pre>
###
###
###

#####
#####
#####
#####
#####
</pre>

</sample-output>

</in-browser-programming-exercise>

<in-browser-programming-exercise name="Шахматная доска" tmcname="part03-33_chessboard" title="Шахматная доска">

Пожалуйста, напишите функцию с именем `chessboard`, которая выводит шахматную доску из единиц и нулей. Функция принимает целочисленный аргумент, который указывает длину стороны доски. См. примеры ниже для подробностей:

```python
chessboard(3)
print()
chessboard(6)
```

<sample-output>

<pre>
101
010
101

101010
010101
101010
010101
101010
010101
</pre>

</sample-output>

</in-browser-programming-exercise>


<in-browser-programming-exercise name="Слово в квадрате" tmcname="part03-34_word_squared" title="Слово в квадрате">

Пожалуйста, напишите функцию с именем `squared`, которая принимает строковый аргумент и целочисленный аргумент и выводит квадрат символов, как указано в примерах ниже.

```python
squared("ab", 3)
print()
squared("aybabtu", 5)
```

<sample-output>

<pre>
aba
bab
aba

aybab
tuayb
abtua
ybabt
uayba
</pre>

</sample-output>

</in-browser-programming-exercise>

<!---
Викторина для повторения содержимого этого раздела:

<quiz id="b04f1d8b-d207-5a8c-abbd-e42a3af7c12d"></quiz>
-->

Пожалуйста, ответьте на краткую анкету о материалах этой недели.

<quiz id="59f2a9b1-9713-5fcf-bbaf-285b4fbf008a"></quiz>