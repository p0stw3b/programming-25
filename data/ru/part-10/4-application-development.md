---
path: '/ru/part-10/4-application-development'
title: 'Разработка крупного приложения'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы познакомитесь с некоторыми основными принципами разработки приложений
- Вы научитесь различать разные части приложения (пользовательский интерфейс, программная логика и работа с файлами)
- Вы получите практику написания собственного более крупного приложения

</text-box>

До сих пор в этом курсе мы изучили большое количество возможностей Python.

Курс «Введение в программирование» познакомил с управляющими структурами, такими как while и for, функциями и базовыми структурами данных, такими как списки, кортежи и словари. В принципе, этих инструментов достаточно для выражения всего, что программист может захотеть выразить с помощью Python.

В этом продвинутом курсе программирования, начиная с части 8 материала, вы познакомились с классами и объектами. Давайте на мгновение рассмотрим, когда и _почему_ они необходимы, если основных инструментов из частей 1-7 должно быть достаточно.

## Управление сложностью

Объекты и классы отнюдь не обязательны в каждом программном контексте. Например, если вы программируете небольшой скрипт для одноразового использования, объекты обычно избыточны. Однако, когда вы программируете что-то большее и более сложное, объекты становятся очень полезными.

Когда программы растут в сложности, количество деталей быстро становится неуправляемым, если программа не организована каким-то систематическим способом. Даже некоторые из более сложных упражнений на этом курсе до сих пор выиграли бы от примеров, приведенных в этой части материала.

На протяжении десятилетий концепция [разделения ответственности](https://ru.wikipedia.org/wiki/Разделение_ответственности) была одним из центральных принципов программирования и более широкой области компьютерных наук. Цитируя Википедию:

_Разделение ответственности — это принцип проектирования для разделения компьютерной программы на отдельные секции, так что каждая секция решает отдельную задачу. Задача — это набор информации, которая влияет на код компьютерной программы._

Разделение программы на секции, так что каждая имеет свою собственную задачу для решения, помогает в управлении неизбежной сложностью компьютерной программы.

Функции — это один способ организации программы в отдельные, управляемые целые. Вместо написания единого скрипта, идея состоит в формулировании небольших, отдельно проверяемых функций, каждая из которых решает некоторую часть более крупной проблемы.

Другой распространенный подход к управлению крупными программами — это объекты, через принципы объектно-ориентированного программирования. У обоих подходов есть преимущества и недостатки, и у каждого программиста есть свой любимый. Как мы видели до сих пор, объекты и классы позволяют нам собрать все данные _и_ код, обрабатывающий эти данные, в единое целое, в атрибутах и методах объекта. Кроме того, объекты предоставляют способ инкапсуляции данных, которые они контролируют, так что другие части программы не должны беспокоиться о внутренних деталях объекта.

## Рабочий пример: телефонная книга

Как должна быть разделена программа на классы и объекты? Это отнюдь не простой вопрос с единственным приемлемым ответом, поэтому мы продолжим с примером. В части пятой вы завершили [приложение телефонной книги](/ru/part-5/3-dictionary#programming-exercise-phone-book-version-2), и теперь мы реализуем что-то похожее, используя принципы объектно-ориентированного программирования.

Следуя принципу разделения ответственности, программа должна быть разделена на секции, каждая из которых имеет свою собственную задачу для решения. В объектно-ориентированном программировании это переводится в [принцип единственной ответственности](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности). Не вдаваясь в более тонкие детали, его фундаментальная цель ясна из названия: _единственный класс и объекты, созданные на его основе, должны иметь единственную ответственность в программе_.

Объектно-ориентированное программирование часто используется как способ моделирования объектов и явлений реального мира. Единственный объект в реальном мире моделируется единственным классом в программном коде. В случае телефонной книги такими объектами могут быть
- человек
- имя
- номер телефона

Имя и номер телефона можно рассматривать как просто биты данных, которые не заслуживают своих собственных классов, но _человек_ — это отдельная физическая сущность в реальном мире, и в программном мире он мог бы работать как класс. Объект Person был бы ответственен за связывание имени и номеров телефонов, прикрепленных к нему.

Сама _телефонная книга_ могла бы быть хорошим кандидатом для класса. Её ответственность заключалась бы в управлении различными объектами person и данными, которые они содержат.

Теперь мы изложили ядро нашего приложения: _телефонная книга_ и _человек_ составляют программную логику нашего приложения, или _логику приложения_ сокращенно. Нашему приложению понадобились бы и некоторые другие классы.

Обычно хорошая идея — держать любое взаимодействие с пользователем отдельно от логики приложения. Это, в конце концов, ответственность сама по себе. В дополнение к основной логике приложения, наша программа должна поэтому содержать класс, который обрабатывает пользовательский интерфейс.

Кроме того, наша телефонная книга должна иметь некоторые средства постоянного хранения между выполнениями. Обработка файлов — это, опять же, четко отдельная ответственность, поэтому она заслуживает своего собственного класса.

Теперь, когда у нас есть набросок основных компонентов нашей программы, возникает вопрос: с чего нам начать программирование? Опять же, нет правильного или неправильного ответа, но часто хорошая идея — начать с некоторой части логики приложения.

## Шаг 1: набросок логики приложения

Начнем с класса _PhoneBook_. Скелетная реализация могла бы выглядеть так:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = []

    def add_number(self, name: str, number: str):
        pass

    def get_numbers(self, name: str):
        pass

```

Этот класс состоит из списка людей вместе с методами для добавления и получения данных.

Каждый человек может быть связан с несколькими номерами, поэтому давайте реализуем внутреннюю структуру `persons` с помощью словаря. Словарь позволяет нам искать ключи по имени, а значение, привязанное к ключу словаря, может быть списком. Пока кажется, что нам действительно не нужен отдельный класс для представления человека — запись в словаре подойдет.

Давайте реализуем методы, перечисленные выше, и протестируем нашу телефонную книгу:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = {}

    def add_number(self, name: str, number: str):
        if not name in self.__persons:
            # добавить новую запись в словарь с пустым списком для номеров
            self.__persons[name] = []

        self.__persons[name].append(number)

    def get_numbers(self, name: str):
        if not name in self.__persons:
            return None

        return self.__persons[name]

# код для тестирования
phonebook = PhoneBook()
phonebook.add_number("Eric", "02-123456")
print(phonebook.get_numbers("Eric"))
print(phonebook.get_numbers("Emily"))
```

Это должно вывести следующее:

<sample-output>

['02-123456']
None

</sample-output>

Метод `get_numbers` возвращает `None`, если имя не включено в телефонную книгу. Если имя найдено, он возвращает список номеров, привязанных к имени.

Всякий раз, когда вы вносите изменения в программу, _всегда_ стоит протестировать, что код работает как ожидается, прежде чем переходить к любым другим изменениям. Код, используемый для тестирования, обычно что-то такое, что удаляется вскоре после, и как таковой вы можете подумать, что не стоит беспокоиться о написании каких-либо тестов в первую очередь. В большинстве случаев это неверно. Тестирование необходимо для хороших результатов программирования.

Ошибка в программе должна быть поймана и исправлена как можно скорее. Если вы войдете в привычку проверять функциональность практически каждой новой строки кода, вы обнаружите, что ошибки обычно легко найти и исправить, поскольку вы можете быть вполне уверены, что ошибка была вызвана самым недавним изменением. Если вы тестируете программу только после добавления десятков строк кода, потенциальные источники ошибок также увеличиваются в десятки раз.

## Шаг 2: набросок пользовательского интерфейса

С основной логикой приложения покончено, пришло время реализовать текстовый пользовательский интерфейс. Нам понадобится новый класс, `PhoneBookApplication`, со следующей начальной функциональностью:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break

application = PhoneBookApplication()
application.execute()
```

Эта программа еще не делает много, но давайте пройдемся по содержанию. Метод конструктора создает новую PhoneBook, которая сохраняется в приватном атрибуте. Метод `execute(self)` запускает текстовый пользовательский интерфейс программы, ядро которого — это цикл `while`, который продолжает спрашивать пользователя о командах, пока он не введет команду для выхода. Также есть метод для инструкций, `help(self)`, который вызывается перед входом в цикл, так что инструкции печатаются.

Теперь давайте добавим некоторую реальную функциональность. Сначала мы реализуем добавление новых данных в телефонную книгу:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                name = input("name: ")
                number = input("number: ")
                self.__phonebook.add_number(name, number)

application = PhoneBookApplication()
application.execute()
```

Если пользователь вводит _1_ для добавления нового номера, пользовательский интерфейс спрашивает имя и номер и добавляет их в PhoneBook, используя соответствующий метод, определенный в классе.

Единственная ответственность пользовательского интерфейса — общаться с пользователем. Любая другая функциональность, такая как сохранение новой пары имя-номер, является ответственностью объекта PhoneBook.

Есть место для улучшения в структуре нашего класса пользовательского интерфейса. Давайте создадим метод `add_entry(self)`, который обрабатывает команду для добавления новой записи:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")

    # разделение ответственности в действии: новый метод для добавления записи
    def add_entry(self):
        name = input("name: ")
        number = input("number: ")
        self.__phonebook.add_number(name, number)

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                self.add_entry()

application = PhoneBookApplication()
application.execute()
```

Принцип _разделения ответственности_ распространяется и на уровень методов. Мы могли бы иметь всю функциональность пользовательского интерфейса в одном сложном цикле `while`, но лучше разделить каждую функциональность на свой собственный метод. Ответственность метода `execute()` — просто делегировать команды, введенные пользователем, соответствующим методам. Это помогает с управлением растущей сложностью нашей программы. Например, если мы хотим позже изменить способ работы добавления записей, сразу ясно, что мы должны тогда сосредоточить наши усилия на методе `add_entry()`.

Давайте включим функциональность для поиска записей в наш пользовательский интерфейс. Это также должно иметь свой собственный метод:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")
        print("2 search")

    def add_entry(self):
        name = input("name: ")
        number = input("number: ")
        self.__phonebook.add_number(name, number)

    def search(self):
        name = input("name: ")
        numbers = self.__phonebook.get_numbers(name)
        if numbers == None:
            print("number unknown")
            return
        for number in numbers:
            print(number)

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                self.add_entry()
            elif command == "2":
                self.search()
            else:
                self.help()

application = PhoneBookApplication()
application.execute()
```

Теперь у нас есть простое рабочее приложение телефонной книги, готовое для тестирования. Вот пример запуска:

<sample-output>

commands:
0 exit
1 add entry
2 search

command: **1**
name: **Eric**
number: **02-123456**

command: **1**
name: **Eric**
number: **045-4356713**

command: **2**
name: **Eric**
02-123456
045-4356713

command: **2**
name: Emily
number unknown

command: **0**

</sample-output>

Для такого простого приложения мы написали довольно много кода. Если бы мы написали все это в одном цикле `while`, мы, вероятно, обошлись бы гораздо меньшим количеством кода. Однако код довольно легко читать, структура ясна, и у нас не должно быть проблем с добавлением новых функций.

## Шаг 3: импорт данных из файла

Предположим, у нас уже есть некоторые номера телефонов, сохраненные в файле, и мы хотим прочитать это при запуске программы. Файл данных в следующем формате CSV:

```csv
Eric;02-1234567;045-4356713
Emily;040-324344
```

Обработка файлов четко является своей собственной областью ответственности, поэтому она заслуживает своего собственного класса:

```python
class FileHandler:
    def __init__(self, filename):
        self.__filename = filename

    def load_file(self):
        names = {}
        with open(self.__filename) as f:
            for line in f:
                parts = line.strip().split(';')
                name, *numbers = parts
                names[name] = numbers

        return names
```

Метод конструктора принимает имя файла как свой аргумент. Метод `load_file(self)` читает содержимое файла. Он разделяет каждую строку на две части: имя и список номеров. Затем он добавляет их в словарь, используя имя как ключ и список как значение.

Метод использует удобную функцию Python: возможно сначала выбрать некоторые элементы из списка отдельно, а затем взять остальные элементы в новом списке. Вы можете увидеть пример этого ниже. Вы можете помнить из [части 6](/ru/part-6/1-reading-files#reading-csv-files), что строковый метод `split` возвращает список.

```python
my_list = [1, 2, 3, 4, 5]
first, second, *rest = my_list
print(first)
print(second)
print(rest)
```

<sample-output>

1
2
[3, 4, 5]

</sample-output>

`*` перед именем переменной `rest` в операторе присваивания означает, что эта последняя переменная должна содержать все оставшиеся элементы в списке, начиная с третьего.

Мы должны абсолютно протестировать обработчик файлов отдельно, прежде чем включить его в наше приложение:

```python
t = FileHandler("phonebook.txt")
print(t.load_file())
```

<sample-output>

{'Eric': ['02-1234567', '045-4356713'], 'Emily': ['040-324344']}

</sample-output>

Поскольку обработчик файлов, кажется, работает нормально, мы можем добавить его в наше приложение. Предположим, мы хотим читать файл первым делом каждый раз, когда запускается программа. Логичное место для чтения файла было бы в конструкторе класса `PhoneBookApplication`:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()
        self.__filehandler = FileHandler("phonebook.txt")

        # добавить имена и номера из файла в телефонную книгу
        for name, numbers in self.__filehandler.load_file().items():
            for number in numbers:
                self.__phonebook.add_number(name, number)

    # остальная часть программы
```

Эта функциональность также должна быть протестирована. Как только мы убедимся, что содержимое файла доступно через пользовательский интерфейс нашего приложения, мы можем перейти к следующему этапу.

## Шаг 4: экспорт данных в файл

Заключительная функция в нашей базовой версии приложения — сохранение содержимого телефонной книги обратно в тот же файл, из которого данные были прочитаны.

Это включает изменение в класс `PhoneBook`. Нам нужно иметь возможность экспортировать содержимое телефонной книги:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = {}

    # ...

    # вернуть все записи (в формате словаря)
    def all_entries(self):
        return self.__persons
```

Фактическое сохранение в файл должно обрабатываться классом `FileHandler`. Давайте добавим метод `save_file`, который принимает словарное представление телефонной книги как свой аргумент:

```python
class FileHandler():
    def __init__(self, filename):
        self.__filename = filename

    def load_file(self):
        # ...

    def save_file(self, phonebook: dict):
        with open(self.__filename, "w") as f:
            for name, numbers in phonebook.items():
                line = [name] + numbers
                f.write(";".join(line) + "\n")
```

Сохранение должно происходить при выходе из программы. Давайте добавим метод для этой цели в пользовательский интерфейс и вызовем его перед выходом из цикла `while`:

```python

class PhoneBookApplication:
    # остальная часть кода для пользовательского интерфейса

    # метод, который выполняется при выходе из программы
    def exit(self):
        self.__filehandler.save_file(self.__phonebook.all_entries())

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":

                self.exit()
                break
            elif command == "1":
                self.add_entry()
            elif command == "2":
                self.search()
            else:
                self.help()
```

<programming-exercise name='Расширение телефонной книги, версия 1' tmcname='part10-10_phone_book_v1'>

В этом упражнении вы создадите небольшое расширение для приложения телефонной книги. Код из приведенного выше примера находится в шаблоне упражнения. Пожалуйста, добавьте команду, которая позволяет пользователю искать в телефонной книге по номеру. После добавления приложение должно работать следующим образом:

<sample-output>

commands:
0 exit
1 add entry
2 search
3 search by number

command: **1**
name: **Eric**
number: **02-123456**

command: **1**
name: **Eric**
number: **045-4356713**

command: **3**
number: **02-123456**
Eric

command: **3**
number: **0100100**
unknown number

command: **0**

</sample-output>

Пожалуйста, реализуйте это дополнение с учетом текущей структуры программы. Это означает, что в классе `PhoneBookApplication` вы должны добавить соответствующий вспомогательный метод для обеспечения новой функциональности, а также добавить новую ветку в цикл `while`. В классе `PhoneBook` вы должны добавить метод, который позволяет поиск по номеру.

**Примечание:** по мере того, как вы тестируете вашу программу и получаете много различных номеров, сохраненных в файле `phonebook.txt`, есть вероятность, что локальные тесты не пройдут, если конфликтующие данные читаются из файла при запуске приложения. Вы можете попробовать очистить содержимое любых файлов `phonebook.txt`, которые вы найдете в директории для упражнения _перед_ запуском локальных тестов. Какой из файлов используется вашей программой, может зависеть от настроек Visual Studio Code. Пожалуйста, ознакомьтесь с объяснением в [части 6](/ru/part-6/1-reading-files#what-if-visual-studio-code-cannot-find-my-file). Если ваше решение правильное, тесты на сервере все равно должны пройти нормально, независимо от этого.

</programming-exercise>

## Объекты в словаре

В следующем упражнении вас просят изменить вашу телефонную книгу так, чтобы значения в словаре были _объектами_, а не списками.

В этом нет ничего принципиально странного, но это первый раз в этом курсе, когда предлагается что-то подобное, поэтому давайте пройдем через более простой пример, прежде чем погружаться в упражнение.

Вот у нас есть приложение, которое отслеживает, сколько упражнений студенты выполнили в курсе. Количество упражнений каждого студента хранится в простом объекте:

```python
class ExerciseCounter:
    def __init__(self):
        self.__exercises = 0

    def done(self):
        self.__exercises += 1

    def how_many(self):
        return self.__exercises
```

Следующая основная функция использует указанный выше класс:

```python
students = {}

print("let's do some exercises")
while True:
    name = input("student: ")
    if len(name) == 0:
        break

    # создать новый объект, если его еще не существует
    if not name in students:
        students[name] = ExerciseCounter()

    # добавить новое выполненное упражнение в счетчик
    students[name].done()

print()
print("exercises completed:")

for student, exercises in students.items():
    print(f"{student}'s exercises: {exercises.how_many()}")
```

Запуск приведенного выше кода может выглядеть так:

<sample-output>

let's do some exercises
student: **peter**
student: **sarah**
student: **andy**
student: **sarah**
student: **charlotte**
student: **charlotte**
student: **andy**
student: **sarah**
student:

exercises completed:
peter's exercises: 1
andy's exercises: 2
sarah's exercises: 3
charlotte's exercises: 2

</sample-output>

В приведенном выше примере есть пара вещей для рассмотрения. Когда пользователь вводит имя, программа сначала проверяет, является ли имя уже ключом в словаре. Если имя отсутствует, создается новый объект и добавляется как запись в словарь:

```python
if not name in students:
    students[name] = ExerciseCounter()
```

После этого мы можем быть _уверены_, что объект существует, привязанный к имени студента, которое используется как ключ. Либо он был только что создан, либо он уже существовал с предыдущей итерации цикла. В любом случае, мы теперь можем получить объект с помощью ключа и вызвать метод `done`:

```python
students[name].done()
```

Приведенная выше строка фактически содержит два отдельных события. Мы могли бы так же использовать вспомогательную переменную и написать это на двух отдельных строках кода:

```python
students_counter = students[name]
students_counter.done()
```

Примечание: Даже если объект здесь присваивается вспомогательной переменной, объект все еще существует в словаре точно так же, как и раньше. Вспомогательная переменная содержит _ссылку_ на объект в словаре.

Если вы не совсем уверены, что фактически происходит в коде выше, пожалуйста, попробуйте это с [инструментом визуализации](http://www.pythontutor.com/visualize.html#mode=edit).

<programming-exercise name='Расширение телефонной книги, версия 2' tmcname='part10-11_phone_book_v2'>

В этом упражнении вы создадите другую версию `PhoneBookApplication`. Вы добавите адреса к данным, которые могут быть прикреплены к имени. Для простоты функциональность сохранения в файл была удалена, и некоторые другие методы были переименованы, чтобы лучше приспособиться к изменению.

## Отдельный класс для данных человека

Пожалуйста, измените способ обработки данных человека. Реализуйте класс с именем `Person`, который заботится о номерах телефонов и адресах людей. Класс должен работать следующим образом:

```python
person = Person("Eric")
print(person.name())
print(person.numbers())
print(person.address())
person.add_number("040-123456")
person.add_address("Mannerheimintie 10 Helsinki")
print(person.numbers())
print(person.address())
```

<sample-output>

Eric
[]
None
['040-123456']
Mannerheimintie 10 Helsinki

</sample-output>

## PhoneBook использует класс Person

Пожалуйста, измените внутреннюю реализацию вашего приложения так, чтобы ваш класс `PhoneBook` использовал объекты класса `Person` для хранения данных в телефонной книге. То есть атрибут `__persons` должен по-прежнему содержать словарь, но значения должны быть объектами Person, а не списками. Пользователь вашего приложения не должен заметить разницы; изменения не должны влиять на пользовательский интерфейс.

**ПРЕДУПРЕЖДЕНИЕ:** всякий раз, когда вы вносите структурные изменения в ваш код, как описано в этом упражнении, всегда делайте маленькие шаги и тестируйте на каждом возможном этапе. Не пытайтесь сделать все изменения сразу. Это верный способ **столкнуться с серьезными проблемами с вашим кодом**.

Подходящий первый шаг мог бы быть написанием кода для проверки функциональности класса `PhoneBook` напрямую. Например, следующее должно, по крайней мере, не вызывать ошибок:

```python
phonebook = PhoneBook()
phonebook.add_number("Eric", "02-123456")
print(phonebook.get_entry("Eric"))
print(phonebook.get_entry("Emily"))
```

Обратите внимание на новое имя для метода получения записи из телефонной книги. Автоматические тесты не проверяют, каков вывод из вашего метода `get_entry`, но убедитесь, что приведенный выше код не вызывает ошибок и что результат имеет смысл в рамках вашей реализации.

Когда вы внесли необходимые изменения в вашу программу и абсолютно проверили функциональность в классе `PhoneBook`, вы можете перейти к пользовательскому интерфейсу и посмотреть, все ли еще работает как ожидается.

## Добавление адреса

Пожалуйста, реализуйте функциональность для добавления адреса к записи в вашей телефонной книге. Программа должна работать следующим образом:

<sample-output>

commands:
0 exit
1 add number
2 search
3 add address

command: **1**
name: **Eric**
number: **02-123456**

command: **3**
name: **Emily**
address: **Viherlaaksontie 7, Espoo**

command: **2**
name: **Eric**
02-123456
address unknown

command: **2**
name: **Emily**
number unknown
Viherlaaksontie 7, Espoo

command: **3**
name: **Eric**
address: **Linnankatu 75, Turku**

command: 2
name: **Eric**
02-123456
Linnankatu 75, Turku

command: **2**
name: **Wilhelm**
address unknown
number unknown

command: **0**

</sample-output>

**ПРЕДУПРЕЖДЕНИЕ и подсказка:** как сказано выше в предыдущем упражнении, не пытайтесь сделать все изменения сразу. Это верный способ **столкнуться с серьезными проблемами с вашим кодом**.

Сначала убедитесь, что вы можете надежно добавлять адреса, используя класс `PhoneBook` напрямую. Как только вы проверили это, вы можете перейти к необходимым изменениям в пользовательском интерфейсе.

</programming-exercise>

## Некоторые заключительные замечания

Структура примера PhoneBook выше довольно хорошо следует фундаментальным принципам объектно-ориентированного программирования. Центральный принцип — определить различные ответственности в программе и разделить их логически между различными классами и методами. Одна из главных мотиваций для этого разделения — управление сложностью. Другой важный мотив — логическое разделение ответственности — модульность в профессиональной терминологии — часто делает код легче в обслуживании и расширении.

В программных пакетах, которые разрабатываются и используются в широком мире, подавляюще самый дорогой аспект разработки — обслуживание и расширение, что означает отладку существующего программного обеспечения и реализацию новых функций. Правильно реализованная модульность финансово очень важна в разработке программного обеспечения.

Есть еще некоторые принципы объектно-ориентированного программирования, стоящие выделения здесь. PhoneBook — хороший пример того, как основная логика приложения может (и должна) быть отделена от _как_ пользовательского интерфейса, _так_ и любых средств хранения данных. Это важно по нескольким различным причинам. Во-первых, это разделение делает возможным тестировать код в меньших единицах, один класс и метод за раз. Во-вторых, поскольку основная логика теперь независима от интерфейсов к внешнему миру, возможно изменить, до некоторой степени, реализацию либо основной логики, либо интерфейсов, не ломая все приложение.

Процесс обработки файлов в приложении PhoneBook проходит следующим образом: программа читает файл только один раз, при запуске. После этого все данные хранятся в переменных в программе. Когда программа завершается, она снова сохраняет все данные, фактически перезаписывая файл. В большинстве случаев это рекомендуемый способ работы с внешними файлами, поскольку редактирование данных на месте часто гораздо более сложно.

Есть много хороших руководств по изучению хороших практик программирования. Одно такое — [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Роберта Мартина. Примеры кода в книге реализованы в Java, однако, поэтому работа с примерами может быть довольно громоздкой на данном этапе вашей программистской карьеры, хотя сама книга очень рекомендуется персоналом курса. Темы легко обслуживаемого, расширяемого, высококачественного кода будут далее изучаться на курсах [Методы разработки программного обеспечения](https://studies.helsinki.fi/courses/cu/hy-CU-118024742-2020-08-01) и [Инженерия программного обеспечения](https://studies.helsinki.fi/courses/cu/hy-CU-118024909-2020-08-01).

Написание кода в соответствии с установленными принципами объектно-ориентированного программирования дается ценой. Вы, вероятно, закончите написанием большего количества кода, чем вы бы, если бы вы написали свою реализацию в одном непрерывном приступе спагетти-кода. Один из ключевых навыков программиста — решить лучший подход для каждой ситуации. Иногда необходимо просто быстро что-то склепать для немедленного использования. С другой стороны, если в обозримом будущем можно ожидать, что код будет переиспользован, поддержан или далее развит, либо вами, либо, что более критично, кем-то еще полностью, читаемость и логическая модульность программного кода становятся существенными. Чаще чем нет, если стоит делать, стоит делать хорошо, даже на очень ранних этапах разработки.

Чтобы закончить эту часть материала, вы реализуете еще одно более крупное приложение.

<programming-exercise name='Записи курсов' tmcname='part10-12_course_records'>

Пожалуйста, напишите интерактивное приложение для отслеживания ваших исследований. Внутренняя структура зависит от вас, но это была бы хорошая возможность попрактиковаться в создании похожей структуры, как в примере PhoneBook выше.

Ваша программа должна работать следующим образом:

<sample-output>

1 add course
2 get course data
3 statistics
0 exit

command: **1**
course: **ItP**
grade: **3**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 3

command: **1**
course: **ItP**
grade: **5**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 5

command: **1**
course: **ItP**
grade: **1**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 5

command: **2**
course: **Introduction to Java**
no entry for this course

command: **1**
course: **ACiP**
grade: **1**
credits: **10**

command: **1**
course: **ItAI**
grade: **2**
credits: **5**

command: **1**
course: **Algo101**
grade: **4**
credits: **1**

command: **1**
course: **CompModels**
grade: **5**
credits: **8**

command: **3**
5 completed courses, a total of 29 credits
mean 3.4
grade distribution
5: xx
4: x
3:
2: x
1: x

command: **0**

</sample-output>

Каждое название курса должно результировать в единую запись в записях. Оценка может быть повышена путем повторного ввода деталей курса, но оценка никогда не должна быть понижена.

Это упражнение стоит два балла за упражнение. Первый предоставляется после того, как команды 1, 2 и 0 работают правильно в вашей программе. Второй предоставляется, если команда 3 также работает как ожидается.

</programming-exercise>

## Эпилог

Чтобы закончить эту часть материала, давайте вернемся к пользовательскому интерфейсу примера телефонной книги на мгновение.

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()
        self.__filehandler = FileHandler("phonebook.txt")

    # остальная часть программы

application = PhoneBookApplication()
application.execute()
```

Объект `PhoneBookApplication` содержит как объект `PhoneBook`, так и объект `FileHandler`. Имя файла, передаваемое в FileHandler, в настоящее время жестко закодировано в класс `PhoneBookApplication`. Это совершенно неуместная деталь, когда речь идет о _пользовательском интерфейсе_ приложения. На самом деле, это нарушает принцип _разделения ответственности_: где объект `PhoneBook` сохраняет свое содержимое, не должно быть заботой `PhoneBookApplication`, но если мы хотели изменить местоположение, нам пришлось бы изменить код `PhoneBookApplication`.

Было бы лучше создать объект FileHandler где-то _вне_ класса `PhoneBookApplication` и передать его как аргумент приложению:

```python
class PhoneBookApplication:
    def __init__(self, storage_service):
        self.__phonebook = PhoneBook()
        self.__storage_service = storage_service

    # остальная часть пользовательского интерфейса

# создать FileHandler
storage_service = FileHandler("phonebook.txt")
# передать его как аргумент конструктору PhoneBookApplication
application = PhoneBookApplication(storage_service)
application.execute()
```

Это удаляет _ненужную зависимость_ из класса `PhoneBookApplication`. Если имя файла изменяется, пользовательский интерфейс больше не нужно изменять. Нам просто нужно передать другой аргумент конструктору:

```python
class PhoneBookApplication:
    def __init__(self, filename):
        self.__phonebook = PhoneBook()
        self.__filename = filename

    # остальная часть пользовательского интерфейса

# использовать другое имя файла
storage_service = FileHandler("new_phonebook.txt")
application = PhoneBookApplication(storage_service)
application.execute()
```

Это изменение также позволяет нам рассмотреть более экзотические места хранения, например, облачный сервис в интернете. Нам просто нужно реализовать класс, который использует облачный сервис и предлагает `PhoneBookApplication` точно такие же методы, как `FileHandler`.

Экземпляр этого нового класса "облачного обработчика" может быть передан как аргумент конструктору, и ни одна строка кода не должна быть изменена в пользовательском интерфейсе:

```python
class CloudHandler:
    # код для сохранения содержимого телефонной книги
    # в облачном сервисе в интернете

storage_service = CloudHandler("amazon-cloud", "username", "passwrd")
application = PhoneBookApplication(storage_service)
application.execute()
```

Как вы видели раньше, использование таких техник имеет ценник, поскольку есть больше кода для написания, поэтому программист должен рассмотреть, является ли это приемлемым компромиссом.

Техника, описанная выше, называется _внедрение зависимостей_. Как подразумевает название, идея состоит в том, чтобы предоставить любую зависимость, требуемую объектом, из _вне_ объекта. Это очень полезный инструмент в инструментарии программиста, поскольку он облегчает реализацию новых функций в программах и способствует автоматическому тестированию. Эта тема будет далее изучена на вышеупомянутых курсах [Методы разработки программного обеспечения](https://studies.helsinki.fi/courses/cu/hy-CU-118024742-2020-08-01) и [Инженерия программного обеспечения](https://studies.helsinki.fi/courses/cu/hy-CU-118024909-2020-08-01).

Пожалуйста, ответьте на быстрый опрос об этой части курса.

<quiz id="f56ab364-0556-5d73-90d1-12c47de1fe75"></quiz>