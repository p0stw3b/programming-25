---
path: '/ru/part-11/1-list-comprehensions'
title: 'Генераторы списков'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, что такое генераторы списков
- Вы сможете использовать генераторы списков для создания новых списков

</text-box>

Одна из ситуаций, где программирование наиболее мощно - это обработка последовательностей элементов и событий. Компьютеры хороши в повторении действий. Например, в предыдущих частях этого материала мы итерировали строки, списки и словари различными способами.

Предположим, у нас есть список целых чисел, и нам нужен тот же список элементов в строковом формате. Традиционный способ выполнения задачи мог бы выглядеть так:

```python
numbers = [1, 2, 3, 6, 5, 4, 7]

strings = []
for number in numbers:
    strings.append(str(number))
```

## Генераторы списков

Существует также более "питоновский" способ генерации списков из существующих списков. Они называются _генераторы списков_.

Идея состоит в том, чтобы уместить в одну строку как описание того, что должно быть сделано с каждым элементом списка, так и присваивание результата новому списку.

В приведённом выше примере операция, выполняемая над каждым элементом списка, была очень простой: каждое целое число преобразовывалось в строку. Давайте посмотрим, как это выглядело бы при реализации с помощью генератора списков:

```python
numbers = [1, 2, 3, 6, 5, 4, 7]
strings = [str(number) for number in numbers]
```

Вторая строка выше содержит многие из тех же элементов, что и более традиционный итеративный подход, но синтаксис другой. Один из способов обобщения выражения генератора списков был бы

`[<выражение> for <элемент> in <серия>]`

Квадратные скобки вокруг выражения генератора списков сигнализируют Python, что результатом должен быть новый список. Один за другим каждый элемент в исходном списке обрабатывается, и результат сохраняется в новом списке, точно так же, как в итеративном подходе выше. В результате мы получаем новый список с точно таким же количеством элементов, как было в исходном, и все элементы были обработаны одинаковым образом.

(Примечание: оригиналы изображений в этой части временно отсутствуют, поэтому в иллюстрациях этой части есть финская лексика. Мы работаем над исправлением этого.)

<img src="../../part-11/11_1_2.png">

Генераторы списков могут обрабатывать и гораздо более сложные операции. Мы можем выполнять вычисления, такие как умножение исходных элементов на десять:

```python
numbers = list(range(1,10))
print(numbers)

numbers_multiplied = [number * 10 for number in numbers]
print(numbers_multiplied)
```

<sample-output>

[1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 20, 30, 40, 50, 60, 70, 80, 90]

</sample-output>

На самом деле, выражение внутри выражения генератора списков может быть любым выражением Python. Вы даже можете вызывать функции, которые определили сами:

```python
def factorial(n: int):
    """ Функция вычисляет факториал n! для целых чисел больше нуля """
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [5, 2, 4, 3, 0]
    factorials = [factorial(number) for number in numbers]
    print(factorials)
```

<sample-output>

[120, 2, 24, 6, 1]

</sample-output>

С более знакомым циклом `for` тот же процесс можно было бы выразить так:

```python
def factorial(n: int):
    """ Функция вычисляет факториал n! для целых чисел больше нуля """
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [5, 2, 4, 3, 0]
    factorials = []
    for number in numbers:
        factorials.append(factorial(number))
    print(factorials)
```

Генераторы списков позволяют нам выразить ту же функциональность более лаконично, обычно без потери читаемости.

Мы также можем вернуть выражение генератора списков из функции напрямую. Если нам нужна функция для вычисления факториалов для списков чисел, мы можем достичь этого очень лаконично:

```python
def factorials(numbers: list):
    return [factorial(number) for number in numbers]
```

<programming-exercise name='Square roots' tmcname='part11-01_square_roots'>

Напишите функцию `square_roots(numbers: list)`, которая принимает список целых чисел в качестве аргумента. Функция должна вернуть новый список, содержащий квадратные корни исходных целых чисел.

Модуль [math](https://docs.python.org/3/library/math.html) из стандартной библиотеки Python содержит подходящую функцию для вычисления квадратного корня.

Функция должна использовать генератор списков. Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Функция должна работать следующим образом:

```python
lines = square_roots([1,2,3,4])
for line in lines:
    print(line)
```

<sample-output>

1.0
1.4142135623730951
1.7320508075688772
2.0

</sample-output>

</programming-exercise>

<programming-exercise name='Rows of stars' tmcname='part11-02_rows_of_stars'>

Напишите функцию `rows_of_stars(numbers: list)`, которая принимает список целых чисел в качестве аргумента. Функция должна вернуть новый список, содержащий строки звёздочек. Длина каждой строки должна соответствовать целому числу с тем же индексом в исходном списке. Функция должна использовать генератор списков для достижения этого.

Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Функция должна работать следующим образом:

```python
rows = rows_of_stars([1,2,3,4])
for row in rows:
    print(row)

print()

rows = rows_of_stars([4, 3, 2, 1, 10])
for row in rows:
    print(row)
```

<sample-output>

<pre>
*
**
***
****

****
***
**
*
**********
</pre>

</sample-output>

</programming-exercise>

<programming-exercise name='Best exam result' tmcname='part11-03_best_exam_result'>

Шаблон упражнения содержит определение класса `ExamResult`. Класс имеет следующие публичные атрибуты:

* name
* grade1
* grade2
* grade3

Напишите функцию `best_results(results: list)`, которая принимает список объектов ExamResult в качестве аргумента.

Функция должна вернуть новый список, содержащий только лучший результат из каждого объекта ExamResult. Функция должна использовать генератор списков для достижения этого.

Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Функция должна работать следующим образом:

```python
result1 = ExamResult("Peter",5,3,4)
result2 = ExamResult("Pippa",3,4,1)
result3 = ExamResult("Paul",2,1,3)
results = [result1, result2, result3]
print(best_results(results))
```

<sample-output>

[5, 4, 3]

</sample-output>

</programming-exercise>

<programming-exercise name='Lengths' tmcname='part11-04_lengths'>

Напишите функцию `lengths(lists: list)`, которая принимает список, содержащий списки целых чисел, в качестве аргумента. Функция должна вернуть новый список, содержащий длины списков в списке аргументов.

Функция должна использовать генератор списков для достижения этого. Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Функция должна работать следующим образом:

```python
lists = [[1,2,3,4,5], [324, -1, 31, 7],[]]
print(lengths(lists))
```

<sample-output>

[5, 4, 0]

</sample-output>

</programming-exercise>

## Фильтрация элементов

В приведённых выше примерах все наши списки оставались одной и той же длины до и после операции генератора списков. В каждом случае все элементы в исходном списке использовались как основа нового списка. Но иногда нам нужны только _некоторые_ из исходных элементов. Как этого достичь?

Выражение генератора списков также позволяет условие, чтобы мы могли проверить элементы против условия и выбрать только те, которые соответствуют. Общий синтаксис выглядит следующим образом:

`[<выражение> for <элемент> in <серия> if <булево выражение>]`

Выражение выше идентично общей форме, представленной в начале этого раздела, но теперь есть выражение if в конце. Только те элементы из исходного списка, для которых булево выражение истинно, используются как основа нового списка.

В приведённом ниже примере мы выбираем все чётные элементы из исходного списка как основу нового списка. На самом деле, эти элементы никак дополнительно не обрабатываются; они присваиваются новому списку как есть:

```python
numbers = [1, 1, 2, 3, 4, 6, 4, 5, 7, 10, 12, 3]

even_items = [item for item in numbers if item % 2 == 0]
print(even_items)
```

<sample-output>

[2, 4, 6, 4, 10, 12]

</sample-output>

Выражение в выражении генератора списков выше - это просто простое `item`, что означает, что никакие операции не должны выполняться над элементами в списке. Выражение могло быть любым выражением Python, как и в предыдущих примерах. Например, следующее выражение генератора списков берёт все чётные элементы в списке, умножает каждый на десять и сохраняет результат в новом списке:

```python
numbers = [1, 1, 2, 3, 4, 6, 4, 5, 7, 10, 12, 3]

even_items = [item * 10 for item in numbers if item % 2 == 0]
print(even_items)
```

<sample-output>

[20, 40, 60, 40, 100, 120]

</sample-output>

Когда вы сталкиваетесь со всё более и более сложными генераторами списков, вам может быть полезно попробовать сначала прочитать условие. В конце концов, элементы обрабатываются только если они проходят тест, поэтому часто имеет смысл сначала выяснить, какие элементы проходят этап фильтрации. Иногда выражение в выражении генератора списков было бы даже невозможно для всех элементов в исходном списке.

Например, операция факториала определена только для неотрицательных целых чисел. Если мы не можем быть уверены, что список содержит только значения нуля или выше, содержимое должно быть отфильтровано перед передачей в функцию факториала, которую мы сделали ранее:

```python
def factorial(n: int):
    """ Функция вычисляет факториал n! для целых чисел больше нуля """
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [-2, 3, -1, 4, -10, 5, 1]
    factorials = [factorial(number) for number in numbers if number >= 0]
    print(factorials)
```

<sample-output>

[6, 24, 120, 1]

</sample-output>

Как мы видели в нашем первом примере генератора списков, где целые числа преобразовывались в строки, элементы в новом списке не должны быть того же типа, что и элементы в исходном списке. Продолжая пример с факториалом выше, мы можем создать кортеж из каждого исходного элемента и его обработанного аналога, и сохранить их в списке, объединяя всё, что мы изучили до сих пор, в одном выражении генератора списков:

```python
def factorial(n: int):
    """ Функция вычисляет факториал n! для целых чисел больше нуля """
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [-2, 3, 2, 1, 4, -10, 5, 1, 6]
    # имя переменной сокращено здесь, чтобы это было легче читать
    factorials = [(n, factorial(n)) for n in numbers if n > 0 and n % 2 == 0]
    print(factorials)
```

<sample-output>

[(2, 2), (4, 24), (6, 720)]

</sample-output>

Разбирая приведённый выше пример, у нас есть булево выражение `n > 0 and n % 2 == 0`. Это означает, что только элементы, которые являются как положительными, так и делимыми на два, принимаются для дальнейшей обработки из исходного списка.

Эти положительные, чётные числа затем каждое в свою очередь обрабатывается в формат `(n, factorial(n))`. Это кортеж, где первый элемент - само число, а второй элемент - результат, возвращённый функцией factorial.

<programming-exercise name='Remove smaller than' tmcname='part11-05_remove_smaller_than'>

Напишите функцию `remove_smaller_than(numbers: list, limit: int)`, которая принимает список целых чисел и предельное значение (также в целочисленном формате) в качестве аргументов.

Функция должна использовать генератор списков для создания нового списка без значений, которые меньше предельного значения.

Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Пример использования функции:

```python
numbers = [1,65, 32, -6, 9, 11]
print(remove_smaller_than(numbers, 10))

print(remove_smaller_than([-4, 7, 8, -100], 0))
```

<sample-output>

[65, 32, 11]
[7, 8]

</sample-output>

</programming-exercise>

<programming-exercise name='Begin with a vowel' tmcname='part11-06_begin_with_vowel'>

Напишите функцию `begin_with_vowel(words: list)`, которая принимает список строк в качестве аргумента.

Функция должна использовать технику генератора списков для создания и возврата нового списка, содержащего только те слова из исходного списка, которые начинаются с гласной (a, e, i, o, u). Как строчные, так и заглавные буквы должны приниматься.

Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Пример использования функции:

```python
word_list = ["automobile","motorbike","Animal","cat","Dog","APPLE","orange"]
for vowelled in begin_with_vowel(word_list):
    print(vowelled)
```

<sample-output>

automobile
Animal
APPLE
orange

</sample-output>

</programming-exercise>

## Альтернативное выполнение с генераторами списков

Часто, когда у нас есть условное выражение, мы также включаем ветку `else`. Поскольку мы можем использовать условия в генераторах списков, ветка else также доступна с генераторами списков. Общий синтаксис условного, используемого с генераторами списков, выглядит так:

`<выражение 1> if <условие> else <выражение 2>`

Мы уже встречались с этими однострочными условными операторами, или тернарными операторами, в [части 7](/ru/part-7/6-more-features). Выражение выше оценивается либо как `выражение 1`, либо как `выражение 2`, в зависимости от того, истинно или ложно условие.

В качестве освежения темы, если нам нужно было напечатать большее из двух чисел, и мы хотели использовать только один оператор print, мы могли бы уместить всё это в одну строку:

```python
number1 = int(input("Введите число 1:"))
number2 = int(input("Введите число 2:"))
print (number1 if number1 > number2 else number2)
```

Объединение синтаксиса тернарного оператора с выражением генератора списков даёт следующую общую структуру:

`[<выражение 1> if <условие> else <выражение 2> for <элемент> in <серия>]`

Это может выглядеть немного запутанно, поскольку условная структура теперь идёт перед фактической частью генератора списков. Это просто так определён синтаксис, по крайней мере на данный момент. Если есть также ветка `else`, условное идёт первым. Если есть только `if`, оно идёт в конец. Вы можете попробовать поменять их местами и посмотреть, что произойдёт.

Включение оператора else означает, что мы снова будем обрабатывать каждый элемент из исходного списка. В зависимости от того, истинно или ложно условие, либо `выражение 1`, либо `выражение 2` выполняется над каждым элементом списка.

Следующий пример проверяет, равны ли элементы списка нулю или больше. Любой такой элемент принимается как есть, но все отрицательные элементы отрицаются, так что знак меняется с отрицательного на положительный. Результат - список, содержащий абсолютные значения элементов в исходном списке.

```python
numbers = [1, -3, 45, -110, 2, 9, -11]
abs_vals = [number if number >= 0 else -number for number in numbers]
print(abs_vals)
```

<sample-output>

[1, 3, 45, 110, 2, 9, 11]

</sample-output>

Повторяя то, что происходит выше: если условие `number >= 0` истинно, элемент подвергается выражению `number`, и результат - сам элемент. Если условие ложно, элемент подвергается выражению `-number`, так что становится положительным по значению.

В следующем примере у нас есть функция `string_lengths`, которая принимает список в качестве аргумента и возвращает другой список с длинами любых строк в исходном списке. Однако эта функция нормально работает с элементами списка любого типа. Если элемент - строка, она вычисляет её длину. Если элемент - что-то ещё, она вставляет -1 в список, который возвращает.

```python
def string_lengths(my_list: list):
    """ Функция возвращает длины строк в новом списке """
    return [len(item) if type(item) == str else -1 for item in my_list]

if __name__ == "__main__":
    test_list = ["hi", 3, True, "there", -123.344, "toodlepip", 2, False]
    lengths = string_lengths(test_list)
    print(lengths)
```

<sample-output>

[2, -1, -1, 5, -1, 9, -1, -1]

</sample-output>


<programming-exercise name='Lottery numbers' tmcname='part11-07_lottery_numbers'>

## Совпадения LotteryNumbers

Напишите класс `LotteryNumbers`, который принимает номер недели (целое значение) и список из семи целых чисел в качестве аргументов конструктора. Список должен содержать правильные номера лотереи для данной недели.

Также напишите метод `number_of_hits(numbers: list)`, который принимает список целых чисел в качестве аргумента. Метод возвращает количество правильных записей в списке параметров.

Метод должен использовать генератор списков для достижения этого. Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Пример использования класса и функции:

```python
week5 = LotteryNumbers(5, [1,2,3,4,5,6,7])
my_numbers = [1,4,7,11,13,19,24]

print(week5.number_of_hits(my_numbers))
```

<sample-output>

3

</sample-output>

## Совпадения LotteryNumbers на месте

Напишите метод `hits_in_place(numbers)`, который принимает список из семи целых чисел в качестве аргумента и возвращает новый список из семи целых чисел. Новый список содержит только те элементы из исходного списка, которые совпадают с правильными номерами недели. Они должны оставаться в тех же индексах, что и в исходном списке. Остальные индексы должны быть заполнены значениями `-1`.

Метод должен использовать генератор списков для достижения этого. Максимальная длина функции - две строки кода, включая строку заголовка, начинающуюся с ключевого слова `def`.

Посмотрите на пример ниже:

```python
week8 = LotteryNumbers(8, [1,2,3,10,20,30,33])
my_numbers = [1,4,7,10,11,20,30]

print(week8.hits_in_place(my_numbers))
```

<sample-output>

[1, -1, -1, 10, -1, 20, 30]

</sample-output>

</programming-exercise>