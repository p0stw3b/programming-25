---
path: '/ru/part-8/1-objects-and-methods'
title: 'Объекты и методы'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, что такое объект в программировании
- Вы поймете, что означает независимость отдельных объектов
- Вы сможете создавать и обращаться к объектам

</text-box>

Это первая часть Продвинутого курса по программированию. Материал предназначен для использования с редактором Visual Studio Code, так же как и предшествующий курс "Введение в программирование". Если вы не использовали Visual Studio Code раньше, инструкции по установке вы найдете [здесь](https://www.mooc.fi/en/installation/vscode), а введение в среду программирования из предыдущего курса [здесь](/ru/part-4/1-vscode).

В курсе "Введение в программирование" мы заметили, что часто имеет смысл группировать связанные данные вместе в наших программах. Например, если мы пытаемся сохранить информацию о книге, может быть разумно использовать кортеж или словарь для организации данных в единую структуру данных.

Решение с использованием кортежа могло бы выглядеть так:

```python
name = "В поисках утраченного набора"
author = "Марсель Питонс"
year = 1992

# Объединяем это в кортеж
book = (name, author, year)

# Выводим название книги
print(book[0])
```

В таком случае преимущество использования словаря в том, что мы можем использовать строки вместо индексов в качестве ключей. То есть мы можем давать описательные имена элементам, хранящимся в структуре данных:

```python
name = "В поисках утраченного набора"
author = "Марсель Питонс"
year = 1992

# Объединяем это в словарь
book = {"name": name, "author": author, "year": year}

# Выводим название книги
print(book["name"])
```

В обоих случаях мы создаем новый _объект_. В программировании этот термин имеет специфическое значение - независимое целое, в данном случае содержащее некоторые биты данных, которые каким-то образом связаны между собой. Быть независимым означает, что любые изменения, сделанные в одном объекте, не повлияют на другие объекты.

Если бы мы создали два структурно одинаковых представления книг, используя словари с одинаковыми ключами, любые изменения, внесенные в один из них, не оказали бы влияния на другой:

```python
book1 = {"name": "Старик и питоны", "author": "Эрнест Питонс", "year": 1952}
book2 = {"name": "Семь питонов", "author": "Алексис Питон", "year": 1894}

print(book1["name"])
print(book2["name"])

book1["name"] = "Прощай, ARM-процессоры"

print(book1["name"])
print(book2["name"])
```

<sample-output>

Старик и питоны
Семь питонов
Прощай, ARM-процессоры
Семь питонов

</sample-output>

<img src="../../part-8/8_1_1.png">

<text-box variant="info" name="Объекты Python">

Вы можете помнить из курса "Введение в программирование", что любое значение в Python внутренне обрабатывается как объект. Это означает, что значение, хранящееся в переменной, является _ссылкой на объект_. Сами данные хранятся внутри объекта в памяти компьютера. Если вы присваиваете значение новой переменной командой `a = 3`, значение, хранящееся в переменной, - это _не_ 3, а _ссылка на объект, который содержит значение 3_.

Большинство других языков программирования (по крайней мере тех, которые поддерживают объектно-ориентированное программирование) включают некоторые специально определенные _примитивные типы данных_. Обычно к ним относятся как минимум целые числа, числа с плавающей точкой и булевы истинные значения. Примитивы обрабатываются напрямую, то есть они хранятся непосредственно в переменных, а не как ссылки. Python не имеет таких примитивов, но работа с базовыми типами данных в Python практически очень похожа. Объекты этих базовых типов данных (таких как числа, булевы значения и строки) являются _неизменяемыми_, что означает, что они не могут быть изменены в памяти. Если значение, хранящееся в переменной базового типа данных, нужно изменить, вся ссылка заменяется, но сам объект остается нетронутым в памяти.

</text-box>

## Объекты и методы

К данным, хранящимся в объекте, можно обращаться через _методы_. Метод - это функция, которая оперирует конкретным объектом, к которому он прикреплен. Способ отличить методы от других функций - это способ их вызова: сначала вы пишете имя целевого объекта, затем точку, а затем имя метода с аргументами, если они есть. Например, метод `values` возвращает все значения, хранящиеся в объекте типа словарь, или `dict`:

```python
# это создает объект типа словарь с именем book
book = {"name": "Старик и питоны", "author": "Эрнест Питонс", "year": 1952}

# Выводим все значения
# Вызов метода values() пишется после имени переменной
# Помните о точечной нотации!
for value in book.values():
    print(value)
```

<sample-output>

Старик и питоны
Эрнест Питонс
1952

</sample-output>

Аналогично, строковые методы нацелены на строковый объект, для которого они вызываются. Некоторые примеры строковых методов включают `count` и `find`:

```python
name = "Воображаемая Ирина"

# Выводим количество раз, когда найдена буква И
print(name.count("И"))

# Количество букв И, найденных в другой строке
print("Иррациональные ирисы в Ислингтоне".count("И"))

# Индекс подстроки Ирина
print(name.find("Ирина"))

# Эта строка не содержит такой подстроки
print("Совершенно другая строка".find("Ирина"))
```

<sample-output>

2
1
11
-1

</sample-output>

Строковые методы возвращают значения, но они не изменят содержимое строки. Как было сказано выше, строки в Python неизменяемы. Это не относится ко всем методам. Списки Python изменяемы, поэтому методы списков Python могут изменять содержимое списка, для которого они вызываются:

```python
my_list = [1,2,3]

# Добавляем пару элементов
my_list.append(5)
my_list.append(1)

print(my_list)

# Удаляем первый элемент
my_list.pop(0)

print(my_list)
```

<sample-output>

[1, 2, 3, 5, 1]
[2, 3, 5, 1]

</sample-output>

<programming-exercise name='The smallest average result (Наименьший средний результат)' tmcname='part08-01_smallest_average'>

Напишите функцию с именем `smallest_average(person1: dict, person2: dict, person3: dict)`, которая принимает три объекта-словаря в качестве аргументов.

Каждый объект-словарь содержит значения, сопоставленные со следующими ключами:

* `"name"`: Имя участника
* `"result1"`: первый результат участника (целое число от 1 до 10)
* `"result2"`: второй результат участника (как выше)
* `"result3"`: третий результат участника (как выше)

Функция должна вычислить среднее значение трех результатов для каждого участника, а затем вернуть участника, у которого был наименьший средний результат. Возвращаемое значение должно быть полным объектом-словарем, содержащим информацию об участнике.

Вы можете предполагать, что не будет ничьих, т.е. у единственного участника будет наименьший средний результат.

Пример работы функции:

```python
person1 = {"name": "Mary", "result1": 2, "result2": 3, "result3": 3}
person2 = {"name": "Gary", "result1": 5, "result2": 1, "result3": 8}
person3 = {"name": "Larry", "result1": 3, "result2": 1, "result3": 1}

print(smallest_average(person1, person2, person3))
```

<sample-output>

{'name': 'Larry', 'result1': 3, 'result2': 1, 'result3': 1}

</sample-output>

</programming-exercise>

<programming-exercise name='Row sums (Суммы строк)' tmcname='part08-02_row_sums '>

В Python каждое значение, хранящееся в переменной, является ссылкой на объект, поэтому любое значение, хранящееся в списке, также является ссылкой на объект. Это также верно при моделировании структуры данных матрицы: каждое значение в списке верхнего уровня является ссылкой на другой список, который в свою очередь содержит ссылки на объекты, представляющие элементы матрицы.

Напишите функцию с именем `row_sums(my_matrix: list)`, которая принимает целочисленную матрицу в качестве аргумента.

Функция должна добавить новый элемент в каждую строку матрицы. Этот элемент содержит сумму других элементов в этой строке. Функция не имеет возвращаемого значения. Она должна изменить матрицу-параметр на месте.

Пример работы функции:

```python
my_matrix = [[1, 2], [3, 4]]
row_sums(my_matrix)
print(my_matrix)
```

<sample-output>

[[1, 2, 3], [3, 4, 7]]

</sample-output>

</programming-exercise>