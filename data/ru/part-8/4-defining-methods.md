---
path: '/ru/part-8/4-defining-methods'
title: 'Определение методов'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, как работают методы классов
- Вы сможете писать новые методы в своих собственных классах
- Вы поймете концепции инкапсуляции и клиента в объектно-ориентированном программировании

</text-box>

Классы, которые содержат только атрибуты данных, не очень отличаются от словарей. Ниже вы найдете два способа моделирования банковского счета: сначала с определением класса, а затем с использованием словаря.

```python
# Пример 1: банковский счет с определением класса
class BankAccount:

    def __init__(self, account_number: str, owner: str, balance: float, annual_interest: float):
        self.account_number = account_number
        self.owner = owner
        self.balance = balance
        self.annual_interest = annual_interest

peters_account = BankAccount("12345-678", "Петр Питон", 1500.0, 0.015)
```

```python
# Пример 2: банковский счет со словарем
peters_account = {"account_number": "12345-678", "owner": "Петр Питон", "balance": 1500.0, "annual_interest": 0.015}
```

Со словарем реализация намного короче и прямолинейнее. Однако с классом структура более "тесно связана", так что мы можем ожидать, что все объекты `BankAccount` будут структурно похожими. Класс также имеет имя. На класс `BankAccount` ссылаются при создании нового банковского счета, и тип объекта - `BankAccount`, а не `dict`.

Другое значительное преимущество классов в том, что помимо данных, они могут содержать функциональность. Один из руководящих принципов объектно-ориентированного программирования заключается в том, что объект используется для доступа как к данным, прикрепленным к объекту, так и к функциональности для обработки этих данных.

## Методы в классах

Метод - это подпрограмма или функция, которая привязана к конкретному классу. Обычно метод влияет только на один объект. Метод определяется внутри определения класса, и он может обращаться к атрибутам данных класса так же, как к любой другой переменной.

Давайте продолжим с классом `BankAccount`, представленным выше. Ниже у нас есть новый метод, который добавляет процент к счету:

```python
class BankAccount:

    def __init__(self, account_number: str, owner: str, balance: float, annual_interest: float):
        self.account_number = account_number
        self.owner = owner
        self.balance = balance
        self.annual_interest = annual_interest

    # Этот метод добавляет годовой процент к балансу счета
    def add_interest(self):
        self.balance += self.balance * self.annual_interest


peters_account = BankAccount("12345-678", "Петр Питон", 1500.0, 0.015)
peters_account.add_interest()
print(peters_account.balance)
```

<sample-output>

1522.5

</sample-output>

Метод `add_interest` умножает баланс счета на процент годовых процентов, а затем добавляет результат к текущему балансу. Метод действует только на объект, для которого он вызывается.

Давайте посмотрим, как это работает, когда мы создали несколько экземпляров класса:

```python
# Класс BankAccount определен в предыдущем примере

peters_account = BankAccount("12345-678", "Петр Питон", 1500.0, 0.015)
paulas_account = BankAccount("99999-999", "Паула Питонен", 1500.0, 0.05)
pippas_account = BankAccount("1111-222", "Пиппа Программист", 1500.0, 0.001)

# Добавляем процент на счета Петра и Паулы, но не на счет Пиппы
peters_account.add_interest()
paulas_account.add_interest()

# Выводим все балансы счетов
print(peters_account.balance)
print(paulas_account.balance)
print(pippas_account.balance)
```

<sample-output>

1522.5
1575.0
1500.0

</sample-output>

Как видно выше, годовой процент добавляется только к тем счетам, для которых вызывается метод. Поскольку процентные ставки различны для счетов Петра и Паулы, результаты для этих двух счетов разные. Баланс на счету Пиппы не меняется, потому что метод `add_interest` не вызывается для объекта `pippas_account`.

## Инкапсуляция

В объектно-ориентированном программировании время от времени появляется слово _клиент_. Оно используется для обозначения секции кода, которая создает объект и использует сервис, предоставляемый его методами. Когда данные, содержащиеся в объекте, используются только через методы, которые он предоставляет, гарантируется _внутренняя целостность_ объекта. На практике это означает, что, например, класс `BankAccount` предлагает методы для обработки атрибута `balance`, поэтому баланс никогда не доступен напрямую клиенту. Эти методы могут затем проверить, что баланс не может опуститься ниже нуля, например.

Пример того, как это может работать:

```python
class BankAccount:

    def __init__(self, account_number: str, owner: str, balance: float, annual_interest: float):
        self.account_number = account_number
        self.owner = owner
        self.balance = balance
        self.annual_interest = annual_interest

    # Этот метод добавляет годовой процент к балансу счета
    def add_interest(self):
        self.balance += self.balance * self.annual_interest

    # Этот метод "снимает" деньги со счета
    # Если снятие успешно, метод возвращает True, иначе False
    def withdraw(self, amount: float):
        if amount <= self.balance:
            self.balance -= amount
            return True

        return False

peters_account = BankAccount("12345-678", "Петр Питон", 1500.0, 0.015)

if peters_account.withdraw(1000):
    print("Снятие прошло успешно, баланс теперь", peters_account.balance)
else:
    print("Снятие неуспешно, баланс недостаточен")

# Попробуем снова
if peters_account.withdraw(1000):
    print("Снятие прошло успешно, баланс теперь", peters_account.balance)
else:
    print("Снятие неуспешно, баланс недостаточен")
```

<sample-output>

Снятие прошло успешно, баланс теперь 500.0
Снятие неуспешно, баланс недостаточен

</sample-output>

Поддержание внутренней целостности объекта и предоставление подходящих методов для обеспечения этого называется _инкапсуляцией_. Идея в том, что внутренняя работа объекта скрыта от клиента, но объект предлагает методы, которые можно использовать для доступа к данным, хранящимся в объекте.

Добавление метода автоматически не скрывает атрибут. Даже несмотря на то, что определение класса `BankAccount` содержит метод `withdraw` для снятия денег, клиентский код все еще может обращаться и изменять атрибут `balance` напрямую:

```python
peters_account = BankAccount("12345-678", "Петр Питон", 1500.0, 0.015)

# Попытка снять 2000
if peters_account.withdraw(2000):
    print("Снятие прошло успешно, баланс теперь", peters_account.balance)
else:
    print("Снятие неуспешно, баланс недостаточен")

    # "Принудительно" снимаем 2000
    peters_account.balance -= 2000

print("Баланс теперь:", peters_account.balance)
```

<sample-output>

Снятие неуспешно, баланс недостаточен
Баланс теперь: -500.0

</sample-output>

Возможно скрыть атрибуты данных от клиентского кода, что может помочь в решении этой проблемы. Мы вернемся к этой теме в следующей части.

<programming-exercise name='Decreasing counter (Убывающий счетчик)' tmcname='part08-10_decreasing_counter'>

Это упражнение имеет несколько частей. Вы можете отправлять части отдельно. Каждая часть стоит одного упражнения.

Шаблон упражнения содержит частично завершенный класс `DecreasingCounter`:

```python
class DecreasingCounter:
    def __init__(self, initial_value: int):
        self.value = initial_value

    def print_value(self):
        print("значение:", self.value)

    def decrease(self):
        pass

    # определите остальные ваши методы здесь
```

Класс теперь может использоваться, как показано ниже, и должен производить следующий вывод после завершения первой части упражнения:

```python
counter = DecreasingCounter(10)
counter.print_value()
counter.decrease()
counter.print_value()
counter.decrease()
counter.print_value()
```

<sample-output>

значение: 10
значение: 9
значение: 8

</sample-output>


### Уменьшение значения счетчика

Завершите метод `decrease`, определенный в шаблоне, так чтобы он уменьшал значение, хранящееся в счетчике, на единицу. См. пример выше для ожидаемого поведения.

### Счетчик не должен иметь отрицательного значения

Добавьте функциональность к вашему методу `decrease`, так чтобы значение счетчика никогда не достигало отрицательных значений. Если значение счетчика равно 0, оно не будет дальше уменьшаться.

```python
counter = DecreasingCounter(2)
counter.print_value()
counter.decrease()
counter.print_value()
counter.decrease()
counter.print_value()
counter.decrease()
counter.print_value()
```

<sample-output>

значение: 2
значение: 1
значение: 0
значение: 0

</sample-output>

### Установка значения на ноль

Добавьте метод `set_to_zero`, который устанавливает значение счетчика в 0:

```python
counter = DecreasingCounter(100)
counter.print_value()
counter.set_to_zero()
counter.print_value()
```

<sample-output>

значение: 100
значение: 0

</sample-output>

### Сброс счетчика

Добавьте метод `reset_original_value()`, который сбрасывает счетчик в его начальное состояние:

```python
counter = DecreasingCounter(55)
counter.decrease()
counter.decrease()
counter.decrease()
counter.decrease()
counter.print_value()
counter.reset_original_value()
counter.print_value()
```

<sample-output>

значение: 51
значение: 55

</sample-output>

</programming-exercise>

Чтобы завершить этот раздел, давайте посмотрим на класс, который моделирует личный рекорд игрока. Определение класса содержит отдельные методы валидации, которые убеждаются, что переданные аргументы корректны. Методы вызываются уже в конструкторе. Это обеспечивает внутреннюю корректность созданного объекта.

```python
from datetime import date

class PersonalBest:

    def __init__(self, player: str, day: int, month: int, year: int, points: int):
        # Значения по умолчанию
        self.player = ""
        self.date_of_pb = date(1900, 1, 1)
        self.points = 0

        if self.name_ok(player):
            self.player = player

        if self.date_ok(day, month, year):
            self.date_of_pb = date(year, month, day)

        if self.points_ok(points):
            self.points = points

    # Вспомогательные методы для проверки корректности аргументов
    def name_ok(self, name: str):
        return len(name) >= 2 # Имя должно быть минимум два символа

    def date_ok(self, day, month, year):
        try:
            date(year, month, day)
            return True
        except:
            # исключение вызывается, если аргументы некорректны
            return False

    def points_ok(self, points):
        return points >= 0

if __name__ == "__main__":
    result1 = PersonalBest("Петр", 1, 11, 2020, 235)
    print(result1.points)
    print(result1.player)
    print(result1.date_of_pb)

    # Дата была некорректной
    result2 = PersonalBest("Паула", 4, 13, 2019, 4555)
    print(result2.points)
    print(result2.player)
    print(result2.date_of_pb) # Выводит значение по умолчанию 1900-01-01
```

<sample-output>

235
Петр
2020-11-01
4555
Паула
1900-01-01

</sample-output>

В приведенном выше примере вспомогательные методы также вызывались через параметр `self`, когда они использовались в конструкторе. Также возможно включать _статические_ определения методов в определения классов. Это методы, которые можно вызывать без создания экземпляра класса. Мы вернемся к этой теме в следующей части.

Имя параметра `self` используется только при обращении к функциям _объекта как экземпляра класса_. К ним относятся как атрибуты данных, так и методы, прикрепленные к объекту. Чтобы сделать терминологию более запутанной, атрибуты данных и методы вместе иногда называются просто _атрибутами_ объекта, поэтому в этом материале мы часто уточняли _атрибуты данных_, когда имели в виду переменные, определенные в классе. Здесь терминология некоторых программистов Python слегка отличается от терминологии, используемой в объектно-ориентированном программировании в целом, где _атрибуты_ обычно относятся только к атрибутам данных объекта.

Также возможно создавать локальные переменные в определениях методов без обращения к `self`. Вы должны делать это, если нет необходимости обращаться к переменным вне метода. Локальные переменные в методах не имеют специальных ключевых слов; они используются точно так же, как любые обычные переменные, с которыми вы сталкивались до сих пор.

Итак, например, это будет работать:

```python
class BonusCard:
    def __init__(self, name: str, balance: float):
        self.name = name
        self.balance = balance

    def add_bonus(self):
        # Переменная bonus ниже является локальной переменной.
        # Она не является атрибутом данных объекта.
        # К ней нельзя обращаться напрямую через объект.
        bonus = self.balance * 0.25
        self.balance += bonus

    def add_superbonus(self):
        # Переменная superbonus также является локальной переменной.
        # Обычно вспомогательные переменные являются локальными переменными, потому что
        # нет необходимости обращаться к ним из других
        # методов в классе или напрямую через объект.
        superbonus = self.balance * 0.5
        self.balance += superbonus

    def __str__(self):
        return f"BonusCard(name={self.name}, balance={self.balance})"
```

<programming-exercise name="First and last name (Имя и фамилия)" tmcname='part08-11_first_and_last_name'>

Напишите класс с именем `Person` с _одним атрибутом_ `name`, который устанавливается с аргументом, переданным конструктору.

Также добавьте два метода:

Метод `return_first_name` должен возвращать имя человека, в то время как метод `return_last_name` должен возвращать фамилию человека.

Вы можете предполагать, что имя, переданное конструктору, будет содержать точно два элемента имени, разделенных пробелом.

Пример использования:

```python
if __name__ == "__main__":
    peter = Person("Петр Питонс")
    print(peter.return_first_name())
    print(peter.return_last_name())

    paula = Person("Паула Питоннен")
    print(paula.return_first_name())
    print(paula.return_last_name())
```

<sample-output>

Петр
Питонс
Паула
Питоннен

</sample-output>


</programming-exercise>

<programming-exercise name='Statistics on numbers (Статистика по числам)' tmcname='part08-12_number_stats'>

В этом упражнении вас просят создать программу для работы с числами, подобно упражнению, выполненному в [конце части 2](/ru/part-2/4-simple-loops#programming-exercise-working-with-numbers) в курсе "Введение в программирование". На этот раз вы определите класс для этой цели.

### Подсчет чисел

Напишите класс с именем `NumberStats` со следующими методами:

- метод `add_number` добавляет новое число в статистическую запись
- метод `count_numbers` возвращает количество добавленных чисел

На данный момент нет необходимости хранить сами числа в какой-либо структуре данных. Достаточно просто запомнить, сколько их было добавлено. Метод `add_number` принимает аргумент, но пока нет необходимости обрабатывать фактическое значение каким-либо образом.

Шаблон упражнения содержит следующий скелет определения класса:

```python
class  NumberStats:
    def __init__(self):
        self.numbers = 0

    def add_number(self, number:int):
        pass

    def count_numbers(self):
        pass
```

```python
stats = NumberStats()
stats.add_number(3)
stats.add_number(5)
stats.add_number(1)
stats.add_number(2)
print("Чисел добавлено:", stats.count_numbers())
```

<sample-output>

Чисел добавлено: 4

</sample-output>

### Сумма и среднее

Добавьте следующие методы к определению вашего класса:

- метод `get_sum` должен возвращать сумму добавленных чисел (если числа не добавлены, метод должен возвращать 0)
- метод `average` должен возвращать среднее добавленных чисел (если числа не добавлены, метод должен возвращать 0)

```python
stats = NumberStats()
stats.add_number(3)
stats.add_number(5)
stats.add_number(1)
stats.add_number(2)
print("Чисел добавлено:", stats.count_numbers())
print("Сумма чисел:", stats.get_sum())
print("Среднее чисел:", stats.average())
```

<sample-output>

Чисел добавлено: 4
Сумма чисел: 11
Среднее чисел: 2.75

</sample-output>

### Пользовательский ввод

Напишите основную программу, которая продолжает спрашивать у пользователя целые числа, пока пользователь не введет -1. Программа должна затем вывести сумму и среднее введенных чисел.

Ваша программа должна использовать объект `NumberStats` для ведения записи добавленных чисел.

Примечание: вам не нужно изменять класс `NumberStats` в этой части упражнения, при условии, что он прошел тесты для предыдущей части упражнения. Используйте экземпляр класса для завершения этой части.

Примечание 2: ваша основная программа не должна содержаться в блоке `if __name__ == "__main__"`, иначе тесты не будут работать.

<sample-output>

Пожалуйста, введите целые числа:
**4**
**2**
**5**
**2**
**-1**
Сумма чисел: 13
Среднее чисел: 3.25

</sample-output>

### Несколько сумм

Добавьте к вашей основной программе так, чтобы она также подсчитывала отдельно сумму четных и нечетных добавленных чисел.

Примечание: не изменяйте определение вашего класса `NumberStats` и в этой части упражнения. Вместо этого определите три объекта `NumberStats`. Один из них должен отслеживать все числа, другой должен отслеживать четные числа, а третий должен отслеживать нечетные числа, введенные пользователем.

Примечание 2: ваша основная программа не должна содержаться в блоке `if __name__ == "__main__"`, иначе тесты не будут работать.

Пожалуйста, посмотрите на этот пример того, как должна работать ваша основная функция:

<sample-output>

Пожалуйста, введите целые числа:
**4**
**2**
**5**
**2**
**-1**
Сумма чисел: 13
Среднее чисел: 3.25
Сумма четных чисел: 8
Сумма нечетных чисел: 5

</sample-output>



</programming-exercise>