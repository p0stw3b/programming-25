---
path: '/ru/part-8/2-classes-and-objects'
title: 'Классы и объекты'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, что такое класс
- Вы поймете, какая связь между классом и объектом
- Вы будете знать, что означает объектно-ориентированное программирование

</text-box>

В предыдущем разделе мы работали со списками, кортежами, словарями и строками. Все это довольно особые случаи в программировании на Python. Синтаксис Python имеет уникальный, заранее определенный метод объявления объекта, принадлежащего к каждому из этих типов:

```python
# Списки объявляются квадратными скобками
my_list = [1,2,3]

# Строки объявляются кавычками
my_string = "Привет!"

# Словари объявляются фигурными скобками
my_dict = {"один": 1, "два": 2}

# Кортежи объявляются круглыми скобками
my_tuple = (1,2,3)
```

Когда объявляется какой-то другой тип объекта, нам нужно вызвать специальную функцию инициализации, называемую _конструктором_. Давайте посмотрим на работу с дробями через класс `Fraction`.

```python
# мы используем класс Fraction из модуля fractions
from fractions import Fraction

# создаем новые дроби
half = Fraction(1,2)

third = Fraction(1,3)

another = Fraction(3,11)

# выводим их
print(half)
print(third)
print(another)

# Дроби можно складывать вместе, например
print(half + third)
```

<sample-output>

1/2
1/3
3/11
5/6

</sample-output>

Как вы можете видеть выше, вызовы конструктора выглядят немного иначе, чем обычные вызовы методов, с которыми мы сталкивались раньше. Во-первых, они не прикреплены к какому-либо объекту точечной нотацией (поскольку вызов конструктора нужен для создания объекта в первую очередь). Метод конструктора также написан с заглавной буквы: `half = Fraction(1,2)`. Давайте внимательнее посмотрим на то, как создаются объекты, познакомившись с концепцией _класса_.

## Класс - это чертеж объекта

Мы уже много раз использовали термин _класс_ в материале. Например, в приведенном выше примере мы импортировали класс `Fraction` из модуля `fractions`. Новые объекты дробей были созданы путем вызова метода _конструктора_ класса `Fraction`.

Определение класса содержит структуру и функциональности любого объекта, который его представляет. Вот почему классы иногда называют чертежами объектов. Итак, определение класса говорит вам, какие данные содержит объект, и также определяет методы, которые могут использоваться с объектом. _Объектно-ориентированное программирование_ относится к парадигме программирования, где функциональность программы связана с использованием классов и объектов, созданных на их основе.

Одно определение класса может использоваться для создания нескольких объектов. Как упоминалось ранее, объекты независимы. Изменения, внесенные в один объект, обычно не влияют на другие объекты, представляющие тот же класс. Каждый объект имеет свой уникальный набор атрибутов данных. Может быть полезно рассмотреть это упрощение отношения класс-объект:

* класс определяет переменные
* когда создается объект, этим переменным присваиваются значения

Итак, мы можем использовать объект типа `Fraction` для доступа к числителю и знаменателю дробного числа:

```python
from fractions import Fraction

number = Fraction(2,5)

# Выводим числитель
print(number.numerator)

# ...и знаменатель
print(number.denominator)
```

<sample-output>

2
5

</sample-output>

Определение класса `Fraction` содержит объявления переменных `numerator` и `denominator`. Каждый объект, созданный на основе класса, имеет свои специфические значения, присвоенные этим переменным.

Аналогично, объекты, созданные на основе класса `date`, каждый содержат свои уникальные значения для года, месяца и дня даты:

```python
from datetime import date

xmas_eve = date(2020, 12, 24)
midsummer = date(2020, 6, 20)

# выводим только атрибут month обоих объектов
print(xmas_eve.month)
print(midsummer.month)
```

<sample-output>

12
6

</sample-output>

Определение класса `date` содержит объявления переменных `year`, `month` и `day`. Когда создается новый объект `date` на основе класса, этим переменным присваиваются значения. Каждый объект имеет свои уникальные значения, присвоенные этим переменным.

## Функции, которые работают с объектами

Передача объекта в качестве аргумента функции должна быть вам знакома, поскольку мы делали это много раз на этом курсе. Давайте посмотрим на следующий пример. Здесь у нас есть функция, которая проверяет, попадает ли объект `date`, переданный в качестве аргумента, на выходные:

```python
def is_it_weekend(my_date: date):
    weekday = my_date.isoweekday()
    return weekday == 6 or weekday == 7
```

Эта функция использует метод [isoweekday](https://docs.python.org/3/library/datetime.html#datetime.date.isoweekday), который определен в определении класса `date`, и возвращает целое значение так, что если данная дата - понедельник, он возвращает 1, если вторник, возвращает 2, и так далее.

Вы можете использовать вышеуказанную функцию вот так:

```python
xmas_eve = date(2020, 12, 24)
midsummer = date(2020, 6, 20)

print(is_it_weekend(xmas_eve))
print(is_it_weekend(midsummer))
```

<sample-output>

False
True

</sample-output>

## Методы против переменных

Работая с объектом типа `date`, вы можете заметить небольшую разницу между тем, как осуществляется доступ к переменным, содержащимся в объекте, в отличие от того, как используются методы, прикрепленные к объектам:

```python
my_date = date(2020, 12, 24)

# вызов метода
weekday = my_date.isoweekday()

# доступ к переменной
my_month = my_date.month

print("День недели:", weekday)
print("Месяц:", my_month)
```

<sample-output>

День недели: 4
Месяц: 12

</sample-output>

День недели, на который попадает дата, доступен через _метод_ `isoweekday`:

```python
weekday = my_date.isoweekday()
```

Это вызов метода, поэтому после имени метода есть круглые скобки. Отсутствие круглых скобок не вызывает ошибку, но результаты странные:

```python
weekday =  my_date.isoweekday
print("День недели:", weekday)
```

<sample-output>

День недели: <built-in method isoweekday of datetime.date object at 0x10ed66450>

</sample-output>

Месяц объекта `date` - это переменная, поэтому прикрепленное значение можно получить с помощью _ссылки_.

```python
my_month = my_date.month
```

Обратите внимание, что здесь _нет круглых скобок_. Добавление круглых скобок _вызвало бы_ ошибку:

```python
my_month = my_date.month()
```

<sample-output>

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable

</sample-output>

<programming-exercise name='List of years (Список лет)' tmcname='part08-03_list_years'>

Напишите функцию с именем `list_years(dates: list)`, которая принимает список объектов типа `date` в качестве аргумента. Функция должна вернуть новый список, который содержит _годы в исходном списке в хронологическом порядке_, от самого раннего к самому позднему.

Пример работы функции:

```python
date1 = date(2019, 2, 3)
date2 = date(2006, 10, 10)
date3 = date(1993, 5, 9)

years = list_years([date1, date2, date3])
print(years)
```

<sample-output>

[1993, 2006, 2019]

</sample-output>

</programming-exercise>


<programming-exercise name='Shopping list (Список покупок)' tmcname='part08-04_shopping_list'>

Шаблон упражнения содержит предопределенный класс `ShoppingList`, который можно использовать для моделирования списка покупок. Ваша задача - добавить метод к определению класса. Вам не нужно изменять никакие уже определенные методы.

Предполагая, что у нас есть объект `ShoppingList`, на который ссылается переменная с именем `shopping_list`, объект можно обрабатывать следующими методами:

```python

print(shopping_list.number_of_items())
print(shopping_list.item(1))
print(shopping_list.amount(1))
print(shopping_list.item(2))
print(shopping_list.amount(2))

```

<sample-output>

2
Bananas
4
Milk
1

</sample-output>

Мы также можем сделать это:

```python
# элементы в списке покупок индексируются с 1
for i in range(1, shopping_list.number_of_items()+1):
    item = shopping_list.item(i)
    amount = shopping_list.amount(i)
    print(f"{item}: {amount} units")
```


<sample-output>

Bananas 4 units
Milk 1 units

</sample-output>

Как видите, `ShoppingList` работает немного как обычный список, но к нему обращаются через методы, предоставленные классом ShoppingList. В отличие от обычных списков Python, индексация начинается с 1, а не с 0.

Напишите функцию с именем `total_units(my_list: ShoppingList)`, которая принимает объект типа `ShoppingList` в качестве аргумента. Функция должна подсчитать общее количество единиц в списке и вернуть значение.

Вы можете использовать следующий код для тестирования вашей функции:

```python
if __name__ == "__main__":
    my_list = ShoppingList()
    my_list.add("bananas", 10)
    my_list.add("apples", 5)
    my_list.add("pineapple", 1)

    print(total_units(my_list))
```

<sample-output>

16

</sample-output>

**Примечание:** определение класса `ShoppingList` уже включено в шаблон упражнения. Вам не нужно использовать оператор `import` для его импорта, в отличие от примеров выше с классами стандартной библиотеки Python `Fraction` и `date`.

</programming-exercise>