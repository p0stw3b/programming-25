---
path: '/ru/part-8/5-more-examples-of-classes'
title: 'Больше примеров классов'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы сможете создавать более универсальные классы
- Вы будете знать, как добавить метод `__str__` к определениям ваших классов

</text-box>


## Пример 1: класс Rectangle

Давайте посмотрим на класс, который моделирует прямоугольник в двухмерном пространстве:

```python
class Rectangle:
    def __init__(self, left_upper: tuple, right_lower: tuple):
        self.left_upper = left_upper
        self.right_lower = right_lower
        self.width = right_lower[0]-left_upper[0]
        self.height = right_lower[1]-left_upper[1]

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return self.width * 2 + self.height * 2

    def move(self, x_change: int, y_change: int):
        corner = self.left_upper
        self.left_upper = (corner[0]+x_change, corner[1]+y_change)
        corner = self.right_lower
        self.right_lower = (corner[0]+x_change, corner[1]+y_change)
```

Новый `Rectangle` создается с двумя кортежами в качестве аргументов. Эти кортежи содержат x и y координаты верхнего левого угла и нижнего правого угла. Конструктор вычисляет высоту и ширину прямоугольника на основе этих значений.

Методы `area` и `perimeter` вычисляют площадь и периметр прямоугольника на основе высоты и ширины. Метод `move` перемещает прямоугольник на значения x и y, заданные как аргументы.

Прямоугольник представлен в системе координат, где x координаты увеличиваются слева направо, а y координаты увеличиваются сверху вниз. Это общий способ обработки координат в программировании, поскольку часто проще и естественнее рассматривать верхний левый угол экрана компьютера как точку, где x и y равны нулю.

Следующая программа тестирует класс `Rectangle`:

```python
rectangle = Rectangle((1, 1), (4, 3))
print(rectangle.left_upper)
print(rectangle.right_lower)
print(rectangle.width)
print(rectangle.height)
print(rectangle.perimeter())
print(rectangle.area())

rectangle.move(3, 3)
print(rectangle.left_upper)
print(rectangle.right_lower)
```

<sample-output>

(1, 1)
(4, 3)
3
2
10
6
(4, 4)
(7, 6)

</sample-output>

## Печать объекта

Когда у вас есть объект, созданный из класса, определенного вами самими, реакция по умолчанию на вызов команды `print` с этим объектом в качестве аргумента не очень информативна:

```python
rectangle = Rectangle((1, 1), (4, 3))
print(rectangle)
```

Вывод должен выглядеть примерно так:

<sample-output>

<__main__.Rectangle object at 0x000002D7BF148A90>

</sample-output>

Очевидно, мы хотим больше контроля над тем, что выводится. Самый простой способ сделать это - добавить специальный метод `__str__` к определению класса. Его цель - вернуть снимок состояния объекта в строковом формате. Если определение класса содержит метод `__str__`, значение, возвращаемое методом, выводится при выполнении команды `print`.

Итак, давайте добавим определение метода `__str__` к нашему классу `Rectangle`:

```python
class Rectangle:

    # ...остальная часть класса идет здесь так же, как выше...

    # Этот метод возвращает состояние объекта в строковом формате
    def __str__(self):
        return f"прямоугольник {self.left_upper} ... {self.right_lower}"
```

Теперь команда `print` производит что-то более дружественное к пользователю:

```python
rectangle = Rectangle((1, 1), (4, 3))
print(rectangle)
```

<sample-output>

прямоугольник (1, 1) ... (4, 3)

</sample-output>

Метод `__str__`, возможно, чаще используется для формулирования строкового представления объекта с помощью функции `str`, как видно в следующей программе:

```python
rectangle = Rectangle((1, 1), (4, 3))
str_rep = str(rectangle)
print(str_rep)
```

<sample-output>

прямоугольник (1, 1) ... (4, 3)

</sample-output>

Существует много других специальных методов с подчеркиванием, которые можно определить для классов. Один довольно похожий на метод `__str__` - это метод `__repr__`. Его цель - обеспечить техническое представление состояния объекта. Мы встретимся с этим методом позже.

<programming-exercise name='Stopwatch (Секундомер)' tmcname='part08-13_stopwatch'>

Шаблон упражнения содержит следующий скелет для класса `Stopwatch`:

```python
class Stopwatch:
    def __init__(self):
        self.seconds = 0
        self.minutes = 0
```

Добавьте к определению класса так, чтобы оно работало следующим образом:

```python
watch = Stopwatch()
for i in range(3600):
    print(watch)
    watch.tick()
```

<sample-output>

00:00
00:01
00:02
... много строк выводится
00:59
01:00
01:01
... много, много строк выводится
59:58
59:59
00:00
00:01

</sample-output>

Итак, метод `tick` добавляет одну секунду к секундомеру. Максимальное значение как для секунд, так и для минут равно 59. Определение вашего класса должно также содержать метод `__str__`, который возвращает строковое представление состояния секундомера, как показано в примере выше.

**Подсказка:** может быть проще тестировать метод `tick`, если вы временно установите начальные значения секунд и минут на некоторое значение, близкое к 59, в конструкторе. Если вы изменяете начальные значения, не забудьте изменить их обратно перед отправкой.

</programming-exercise>

<programming-exercise name='Clock (Часы)' tmcname='part08-14_clock'>

Определите новый класс с именем `Clock`, который расширяет возможности вашего класса `Stopwatch`. Он должен работать следующим образом:

```python
clock = Clock(23, 59, 55)
print(clock)
clock.tick()
print(clock)
clock.tick()
print(clock)
clock.tick()
print(clock)
clock.tick()
print(clock)
clock.tick()
print(clock)
clock.tick()
print(clock)

clock.set(12, 5)
print(clock)
```

<sample-output>
23:59:55
23:59:56
23:59:57
23:59:58
23:59:59
00:00:00
00:00:01
12:05:00
</sample-output>

Как видно выше, конструктор должен принимать начальные значения для часов, минут и секунд в качестве аргументов и устанавливать их соответствующим образом. Метод `tick` добавляет одну секунду к часам. Метод `set` устанавливает новые значения для часов и минут и _устанавливает секунды в ноль_.

</programming-exercise>

<programming-exercise name='LunchCard (Карта питания)' tmcname='part08-15_lunchcard'>

В Unicafe, студенческой столовой Университета Хельсинки, студенты могут платить за свой обед специальной дебетовой картой.

В этом упражнении вы напишете класс с именем `LunchCard` с целью эмуляции функций, предоставляемых дебетовой картой столовой.

### Структура нового класса

Создайте новый класс с именем `LunchCard`.

Сначала напишите конструктор для класса. Он должен принимать начальный баланс, доступный на карте, в качестве аргумента и сохранить его как атрибут. Это предоставлено для вас в скелете ниже.

Затем напишите метод `__str__`, который возвращает строку, содержащую баланс: "На балансе X евро". Доступный баланс должен выводиться с точностью до одного знака после запятой. Пожалуйста, посмотрите пример ниже для использования.

Вот скелетная реализация для класса:

```python
class LunchCard:
    def __init__(self, balance: float):
        self.balance = balance

    def __str__(self):
        pass
```

Пример использования:

```python
card = LunchCard(50)
print(card)
```

Выполнение вышеуказанного должно произвести следующий вывод:

<sample-output>

На балансе 50.0 евро

</sample-output>

### Оплата обеда

Реализуйте следующие методы в вашем классе LunchCard:

- `eat_lunch` вычитает 2.60 евро с баланса карты
- `eat_special` вычитает 4.60 евро с баланса карты

Вы можете использовать следующую основную функцию для тестирования вашего класса:

```python
card = LunchCard(50)
print(card)

card.eat_lunch()
print(card)

card.eat_special()
card.eat_lunch()
print(card)
```

Это должно произвести следующий вывод:

<sample-output>

На балансе 50.0 евро
На балансе 47.4 евро
На балансе 40.2 евро

</sample-output>

Убедитесь, что баланс никогда не может достичь значений ниже нуля:

```python
card = LunchCard(4)
print(card)

card.eat_lunch()
print(card)

card.eat_lunch()
print(card)
```

<sample-output>

На балансе 4.0 евро
На балансе 1.4 евро
На балансе 1.4 евро

</sample-output>

Если на карте недостаточно денег для оплаты обеда, цена обеда не должна вычитаться с баланса.

### Пополнение денег на карту

Реализуйте метод `deposit_money` в вашем классе `LunchCard`.

Метод увеличивает баланс на карте на сумму, заданную как аргумент.

```python
card = LunchCard(10)
print(card)
card.deposit_money(15)
print(card)
card.deposit_money(10)
print(card)
card.deposit_money(200)
print(card)
```

<sample-output>

На балансе 10.0 евро
На балансе 25.0 евро
На балансе 35.0 евро
На балансе 235.0 евро

</sample-output>

Метод должен учитывать аргументы ниже нуля, [вызывая исключение](/ru/part-6/3-errors#raising-exceptions) типа `ValueError`:

```python
card = LunchCard(10)
card.deposit_money(-10)
```

<sample-output>

File "testi.py", line 3, in lunchcard
ValueError: Вы не можете внести сумму денег меньше нуля

</sample-output>

**Примечание:** этот метод должен _вызвать_ исключение. Пожалуйста, посмотрите инструкции по вызову исключений в [части 6](/ru/part-6/3-errors#raising-exceptions). Ни при каких обстоятельствах метод сам не должен ничего выводить - пример выше - это вывод из интерпретатора Python при встрече с исключением.

### Несколько карт

Напишите основную функцию, которая содержит следующую последовательность событий:

- Создайте карту питания для Петра. Начальный баланс на карте составляет 20 евро.
- Создайте карту питания для Грейс. Начальный баланс на карте составляет 30 евро.
- Петр ест специальный обед
- Грейс ест обычный обед
- _Выведите баланс на каждой карте (на отдельных строках, с именем владельца в начале строки)_
- Петр пополняет 20 евро
- Грейс ест специальный обед
- _Выведите баланс на каждой карте (на отдельных строках, с именем владельца в начале строки)_
- Петр ест обычный обед
- Петр ест обычный обед
- Грейс пополняет 50 евро
- _Выведите баланс на каждой карте (на отдельных строках, с именем владельца в начале строки)_

Тело основной программы

```python
peters_card = LunchCard(20)
graces_card = LunchCard(30)
# остальная часть вашей основной функции
```

Ваша основная функция должна вывести точно следующее:

<sample-output>

Петр: На балансе 15.4 евро
Грейс: На балансе 27.4 евро
Петр: На балансе 35.4 евро
Грейс: На балансе 22.8 евро
Петр: На балансе 30.2 евро
Грейс: На балансе 72.8 евро

</sample-output>

</programming-exercise>

## Пример 2: Список задач

Следующий класс `TaskList` моделирует список задач:

```python
class TaskList:
    def __init__(self):
        self.tasks = []

    def add_task(self, name: str, priority: int):
        self.tasks.append((priority, name))

    def get_next(self):
        self.tasks.sort()
        # Метод списка pop удаляет и возвращает последний элемент в списке
        task = self.tasks.pop()
        # Возвращает имя задачи (второй элемент в кортеже)
        return task[1]

    def number_of_tasks(self):
        return len(self.tasks)

    def clear_tasks(self):
        self.tasks = []
```

Метод `add_task` добавляет новую задачу в список. Каждая задача также имеет приоритет, который используется для сортировки задач. Метод `get_next` удаляет и возвращает задачу с наивысшим приоритетом из списка. Также есть метод `number_of_tasks`, который возвращает количество задач в списке, и, наконец, метод `clear_tasks`, который очищает список задач.

Внутри объекта задачи хранятся в списке. Каждая задача представляет собой кортеж, содержащий приоритет задачи и ее имя. Значение приоритета хранится первым, так что когда список сортируется, задача с наивысшим приоритетом является последним элементом в списке. Вот почему мы можем просто использовать метод `pop` для получения и удаления элемента с наивысшим приоритетом.

Посмотрите на следующую программу со списком задач в действии:

```python
tasks = TaskList()
tasks.add_task("учеба", 50)
tasks.add_task("упражнения", 60)
tasks.add_task("уборка", 10)
print(tasks.number_of_tasks())
print(tasks.get_next())
print(tasks.number_of_tasks())
tasks.add_task("свидание", 100)
print(tasks.number_of_tasks())
print(tasks.get_next())
print(tasks.get_next())
print(tasks.number_of_tasks())
tasks.clear_tasks()
print(tasks.number_of_tasks())
```

<sample-output>

3
упражнения
2
3
свидание
учеба
1
0

</sample-output>

<programming-exercise name='Series (Сериалы)' tmcname='part08-16_series'>

### Класс с именем Series

Напишите класс с именем `Series` со следующей функциональностью:

```python
dexter = Series("Декстер", 8, ["Криминал", "Драма", "Мистика", "Триллер"])
print(dexter)
```

<sample-output>

Декстер (8 сезонов)
жанры: Криминал, Драма, Мистика, Триллер
нет рейтингов

</sample-output>

Конструктор должен принимать название, количество сезонов и список жанров для сериала в качестве аргументов.

**Подсказка:** когда вам нужно получить строку из списка, содержащего строки, с разделяющим символом по вашему выбору между записями, вы можете использовать метод `join` следующим образом:

```python
genre_list = ["Криминал", "Драма", "Мистика", "Триллер"]
genre_string = ", ".join(genre_list)
print(genre_string)
```

<sample-output>

Криминал, Драма, Мистика, Триллер

</sample-output>

### Добавление отзывов

Реализуйте метод `rate(rating: int)`, который позволяет добавить рейтинг от 0 до 5 к любому объекту сериала. Вам также нужно будет скорректировать метод `__str__`, чтобы в случае, если есть рейтинги, метод выводил количество добавленных рейтингов и их среднее значение, округленное до одного знака после запятой.

```python
dexter = Series("Декстер", 8, ["Криминал", "Драма", "Мистика", "Триллер"])
dexter.rate(4)
dexter.rate(5)
dexter.rate(5)
dexter.rate(3)
dexter.rate(0)
print(dexter)
```

<sample-output>

Декстер (8 сезонов)
жанры: Криминал, Драма, Мистика, Триллер
5 рейтингов, среднее 3.4 балла

</sample-output>

### Поиск сериалов

Реализуйте эти две функции, которые позволяют искать в списке сериалов: `minimum_grade(rating: float, series_list: list)` и `includes_genre(genre: str, series_list: list)`.

Вот пример того, как используются новые методы:

```python
s1 = Series("Декстер", 8, ["Криминал", "Драма", "Мистика", "Триллер"])
s1.rate(5)

s2 = Series("Южный Парк", 24, ["Анимация", "Комедия"])
s2.rate(3)

s3 = Series("Друзья", 10, ["Романтика", "Комедия"])
s3.rate(2)

series_list = [s1, s2, s3]

print("минимальная оценка 4.5:")
for series in minimum_grade(4.5, series_list):
    print(series.title)

print("жанр Комедия:")
for series in includes_genre("Комедия", series_list):
    print(series.title)
```

<sample-output>

минимальная оценка 4.5:
Декстер
жанр Комедия:
Южный Парк
Друзья

</sample-output>

Код выше и автоматические тесты для этого упражнения предполагают, что ваш класс содержит атрибут `title`. Если вы использовали какое-то другое имя атрибута для ссылки на название сериала, измените его перед отправкой.

</programming-exercise>

Пожалуйста, ответьте на короткий опрос о материалах этой недели.

<quiz id="5fa782a4-59cc-5e75-9f77-e3a2b35a81e2"></quiz>