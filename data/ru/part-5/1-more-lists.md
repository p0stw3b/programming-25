---
path: '/ru/part-5/1-more-lists'
title: 'Больше о списках'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После изучения этого раздела

- Вы сможете создавать списки с различными типами элементов
- Вы узнаете, как использовать списки для организации данных
- Вы сможете хранить матрицу как двумерный список

</text-box>

<!--the same text is in sections 3-1, 5-1 and 6-1, check them all if you're changing this-->
<text-box variant='hint' name="О упражнениях на этом курсе">

Чтобы стать опытным программистом, требуется много практики, иногда даже довольно механической практики. Это также включает развитие навыков решения проблем и применение интуиции. Вот почему на этом курсе много упражнений разных видов. Некоторые из них просят вас довольно прямолинейно применить то, что вы изучили в материале, но некоторые намеренно более сложные и открытые.

Некоторые упражнения могут сначала показаться overwhelming, но это не повод для беспокойства. Ни одно из упражнений не является строго обязательным, и фактически _для прохождения курса требуется только 25% баллов в каждой части._ Более подробную информацию о прохождении курса можно найти на [странице об оценивании](/ru/grading-and-exams).

**Упражнения не расположены в каком-либо конкретном порядке сложности.** Каждый раздел обычно представляет некоторые новые концепции программирования, и они затем отрабатываются как на более простых, так и на более сложных упражнениях. **Если вы столкнётесь с упражнением, которое кажется слишком сложным, переходите к следующему.** Вы всегда можете вернуться к более сложным упражнениям, если у вас будет время позже.

Когда дела неизбежно усложняются, слово утешения: задача, которая кажется невозможно сложной на этой неделе, вероятно, покажется довольно лёгкой примерно через четыре недели.

</text-box>

## Списки с различными типами данных

В предыдущей части мы в основном работали со списками с целочисленными элементами, но в списках могут храниться любые типы значений. Список строк может выглядеть так:

```python
names = ["Марлин", "Рут", "Пол"]
print(names)
names.append("Давид")
print(names)

print("Количество имён в списке:", len(names))
print("Имена в алфавитном порядке:")
names.sort()
for name in names:
  print(name)
```

<sample-output>

['Марлин', 'Рут', 'Пол']
['Марлин', 'Рут', 'Пол', 'Давид']
Количество имён в списке: 4
Имена в алфавитном порядке:
Давид
Марлин
Пол
Рут

</sample-output>

Числа с плавающей точкой также являются допустимыми элементами списка:

```python
measurements = [-2.5, 1.1, 7.5, 14.6, 21.0, 19.2]

for measure in measurements:
    print(measure)

mean = sum(measurements) / len(measurements)

print("Среднее значение:", mean)
```

<sample-output>

-2.5
1.1
7.5
14.6
21.0
19.2
Среднее значение: 10.15

</sample-output>

<!--a similar warning is in sections 3-4, 4-6 and 5-1, check them all if you're changing this-->
## Напоминание: использование глобальных переменных внутри функций

Мы знаем, что возможно присваивать новые переменные в определениях функций, но функция также может видеть переменные, присвоенные вне её, в основной функции. Такие переменные называются _глобальными_ переменными.

Использование глобальных переменных из функций обычно плохая идея. Среди прочих проблем, это может вызвать ошибки, которые трудно отследить.

Ниже пример функции, которая использует глобальную переменную "по ошибке":

```python
def print_reversed(names: list):
    # использование глобальной переменной вместо параметра по случайности
    i = len(name_list) - 1
    while i >= 0:
        print(name_list[i])
        i -= 1

# здесь присваивается глобальная переменная
name_list = ["Стив", "Жан", "Катерина", "Пол"]
print_reversed(name_list)
print()
print_reversed(["Хьюи", "Дьюи", "Луи"])
```

<sample-output>

Пол
Катерина
Жан
Стив

Пол
Катерина
Жан
Стив

</sample-output>

Хотя оба вызова функций имеют правильный тип аргумента, функция всегда выводит то, что хранится в глобальной переменной `name_list`.

Чтобы сделать дела ещё более запутанными, помните, что весь код для тестирования ваших функций должен быть размещён в блоке `if __name__ == "__main__":` для автоматических тестов. Предыдущий пример должен быть изменён:

```python
def print_reversed(names: list):
    # использование глобальной переменной вместо параметра по случайности
    i = len(name_list) - 1
    while i>=0:
        print(name_list[i])
        i -= 1

# Весь код для тестирования функции должен быть в этом блоке
if __name__ == "__main__":
    # здесь присваивается глобальная переменная
    name_list = ["Стив", "Жан", "Катерина", "Пол"]
    print_reversed(name_list)
    print()
    print_reversed(["Хьюи", "Дьюи", "Луи"])
```

Обратите внимание, что глобальная переменная теперь присваивается в блоке `if`.

Автоматические тесты в системе TMC выполняются без запуска какого-либо кода в блоке `if`. Поэтому в этом последнем примере функция теоретически даже не работала бы, поскольку она ссылается на переменную `name_list`, которая вообще не существует при выполнении тестов.

## Предупреждение: перезапись параметра и слишком раннее возвращение

Есть пара новых источников ошибок, которые мы должны рассмотреть, прежде чем перейти к упражнениям в этой части. Давайте посмотрим на функцию, которая говорит нам, найдено ли целое число в списке. Оба определены как параметры функции:

```python
def number_in_list(numbers: list, number: int):
    for number in numbers:
        if number == number:
            return True
        else:
            return False
```

Эта функция, кажется, всегда возвращает `True`. Причина в том, что цикл `for` перезаписывает значение, хранящееся в параметре `number`. Таким образом, условие в операторе `if` всегда истинно.

Переименование параметра решает проблему:

```python
def number_in_list(numbers: list, searched_number: int):
    for number in numbers:
        if number == searched_number:
            return True
        else:
            return False
```

Теперь условие в операторе `if` выглядит лучше. Но есть новая проблема, поскольку функция всё ещё не работает правильно. Попытка следующего проявляет ошибку:

```python
found = number_in_list([1, 2, 3, 4], 3)
print(found)  # выводит False
```

Проблема здесь в том, что функция возвращается слишком рано, не проверив все числа в списке. Фактически, функция берёт только первый элемент в списке и возвращает `True` или `False` в зависимости от его значения. Мы не можем знать, _отсутствует_ ли число в списке, пока не проверили все элементы в списке. Команда `return False` должна быть размещена вне цикла `for`:

```python
def number_in_list(numbers: list, searched_number: int):
    for number in numbers:
        if number == searched_number:
            return True

    return False
```

Давайте посмотрим на другую ошибочную функцию:

```python
def unique_numbers(numbers: list):
    # вспомогательная переменная для хранения всех чисел, которые мы уже проверили
    numbers = []
    for number in numbers:
        # видели ли мы это число уже?
        if number in numbers:
            return False
        numbers.append(number)

    return True

unique = unique_numbers([1, 2, 2])
print(unique)  # выводит True
```

Эта функция должна проверить, являются ли все числа в списке различными друг от друга, но она всегда возвращает `True`.

Здесь функция снова перезаписывает значение, хранящееся в её параметре, по ошибке. Функция пытается использовать переменную `numbers` для хранения всех уже проверенных чисел, но это перезаписывает исходный список аргументов. Переименование вспомогательной переменной - простое исправление:

```python
def unique_numbers(numbers: list):
    # вспомогательная переменная для хранения всех чисел, которые мы уже проверили
    numbers_checked = []
    for number in numbers:
        # видели ли мы это число уже?
        if number in numbers_checked:
            return False
        numbers_checked.append(number)

    return True

unique = unique_numbers([1, 2, 2])
print(unique)  # выводит False
```

Подобные проблемы и многие другие могут быть обнаружены и исправлены с помощью отладчика или [инструмента визуализации](http://www.pythontutor.com/visualize.html#mode=edit). Обучение эффективному использованию этих инструментов невозможно переоценить.

<programming-exercise name='The longest string' tmcname='part05-01_longest_string' title='Самая длинная строка'>

Пожалуйста, напишите функцию с именем `longest(strings: list)`, которая принимает список строк в качестве аргумента. Функция находит и возвращает самую длинную строку в списке. Вы можете предполагать, что всегда есть одна самая длинная строка в списке.

Пример ожидаемого поведения:

```python

if __name__ == "__main__":
    strings = ["привет", "привет-привет", "здравствуй", "здравствуйте-здравствуйте", "привет там"]
    print(longest(strings))

```

<sample-output>

здравствуйте-здравствуйте

</sample-output>

</programming-exercise>

## Списки внутри списков

Элементы в списке могут быть списками сами по себе:

```python
my_list = [[5, 2, 3], [4, 1], [2, 2, 5, 1]]
print(my_list)
print(my_list[1])
print(my_list[1][0])
```
<sample-output>

[[5, 2, 3], [4, 1], [2, 2, 5, 1]]
[4, 1]
4

</sample-output>

Почему списки внутри списков полезны?

Помните, что списки могут содержать элементы разных типов. Вы могли бы хранить информацию о человеке в списке. Например, вы могли бы включить их имя как первый элемент, их возраст как второй элемент и их рост в метрах как третий элемент:

```python
["Анна", 12, 1.45]
```

База данных людей тогда могла бы быть списком, элементы которого были бы списками, содержащими информацию об одном человеке:

```python
persons = [["Бетти", 10, 1.37], ["Пётр", 7, 1.25], ["Эмили", 32, 1.64], ["Алан", 39, 1.78]]

for person in persons:
  name = person[0]
  age = person[1]
  height = person[2]
  print(f"{name}: возраст {age} лет, рост {height} метров")
```

<sample-output>

Бетти: возраст 10 лет, рост 1.37 метров
Пётр: возраст 7 лет, рост 1.25 метров
Эмили: возраст 32 лет, рост 1.64 метров
Алан: возраст 39 лет, рост 1.78 метров

</sample-output>

Цикл `for` проходит по элементам во внешнем списке один за другим. То есть каждый список, содержащий информацию об одном человеке, в свою очередь присваивается переменной `person`.

Списки не всегда лучший способ представления данных, таких как информация о человеке. Скоро мы познакомимся с Python _словарями_, которые часто лучше подходят для таких ситуаций.

## Матрицы

Двумерный массив, или _матрица_, также является естественным применением списка внутри списка.

Например, следующая матрица

<img src="../../part-5/5_1_1.png">

могла бы быть представлена как двумерный список в Python следующим образом:

```python
my_matrix = [[1, 2, 3], [3, 2, 1], [4, 5, 6]]
```

Поскольку матрица является списком, содержащим списки, отдельные элементы внутри матрицы могут быть доступны с использованием последовательных квадратных скобок. Первый индекс ссылается на строку, а второй на столбец. Индексация начинается с нуля, поэтому, например, `my_matrix[0][1]` ссылается на второй элемент в первой строке.

```python
my_matrix = [[1, 2, 3], [3, 2, 1], [4, 5, 6]]

print(my_matrix[0][1])
my_matrix[1][0] = 10
print(my_matrix)
```

<sample-output>

2
[[1, 2, 3], [10, 2, 1], [4, 5, 6]]

</sample-output>

Как и любой другой список, строки матрицы могут быть пройдены циклом `for`. Следующий код выводит каждую строку матрицы на отдельной строке:

```python
my_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_matrix:
    print(row)
```

<sample-output>

[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

</sample-output>

Аналогично, вложенные циклы могут быть использованы для доступа к отдельным элементам. Следующий код выводит каждый элемент в матрице на отдельной строке с помощью двух циклов `for`:

```python
my_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_matrix:
    print("новая строка")
    for element in row:
        print(element)
```

<sample-output>

новая строка
1
2
3
новая строка
4
5
6
новая строка
7
8
9

</sample-output>

## Визуализация кода, содержащего списки внутри списков

Программы, содержащие списки внутри списков, могут сначала показаться трудными для понимания. [Инструмент визуализации](http://www.pythontutor.com/visualize.html) от Python Tutor является отличной помощью в понимании того, как они работают. Следующая визуализация примера выше:

<img src="../../part-5/5_1_2.png">

Изображение выше показывает, что матрица 3 на 3 технически состоит из четырёх списков. Первый список представляет всю матрицу. Три оставшихся списка являются элементами первого списка и представляют строки.

Поскольку многомерные списки могут быть пройдены вложенными циклами, естественно было бы думать о самих списках как о вложенных, но изображение выше показывает нам, что это на самом деле не так. Вместо этого список, представляющий всю матрицу, "указывает" на каждый отдельный список, представляющий строку в матрице. Это называется _ссылкой_, и в [следующем разделе](/ru/part-5/2-references) идея будет исследована более тщательно.

На изображении выше выполнение продвинулось ко второй строке матрицы, и этот список - то, на что в настоящее время ссылается переменная `row`. Переменная `element` содержит элемент, на котором в данный момент находится выполнение. Значение, хранящееся в `element`, является средним элементом в списке, то есть 5.

## Доступ к элементам в матрице

Доступ к одной строке внутри матрицы прост - просто выберите желаемую строку. Следующая функция вычисляет сумму элементов в выбранной строке:

```python
def sum_of_row(my_matrix, row_no: int):
    # выбрать желаемую строку из матрицы
    row = my_matrix[row_no]
    row_sum = 0
    for item in row:
        row_sum += item

    return row_sum

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

my_sum = sum_of_row(m, 1)
print(my_sum) # выводит 33 (что равно 9 + 1 + 12 + 11)
```

Работа со столбцами внутри матрицы немного сложнее, поскольку матрица хранится по строкам: 

```python
def sum_of_column(my_matrix, column_no: int):
    # пройти через каждую строку и выбрать элемент в выбранной позиции
    column_sum = 0
    for row in my_matrix:
        column_sum += row[column_no]

    return column_sum

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

my_sum = sum_of_column(m, 2)
print(my_sum) # выводит 39 (что равно 3 + 12 + 9 + 15)
```

Столбец, обрабатываемый здесь, состоит из элементов с индексом 2 в _каждой строке_.

[Инструмент визуализации](http://www.pythontutor.com/visualize.html) определённо рекомендуется для понимания того, как работают эти функции.

Изменение значения одного элемента в матрице просто: выберите строку в матрице, а затем столбец в строке:

```python
def change_value(my_matrix, row_no: int, column_no: int, new_value: int):
    # выбрать желаемую строку
    row = my_matrix[row_no]
    # выбрать правильный элемент в строке
    row[column_no] = new_value

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

print(m)
change_value(m, 2, 3, 1000)
print(m)
```

<sample-output>

[[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]
[[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 1000], [2, 9, 15, 1]]

</sample-output>

Обратите внимание, как выше мы использовали индексы строки и столбца для доступа к выбранному элементу. Если мы хотим изменить содержимое матрицы, мы должны получить доступ к элементам по их индексам. Это означает, что мы не можем использовать простой цикл `for item in list` для прохода по матрице, если хотим изменить содержимое матрицы.

Вместо этого нам придётся отслеживать индексы элементов, например, с помощью цикла `while` или цикла `for`, используя функцию `range`. Следующий код увеличивает значение каждого элемента в матрице на единицу:

```python
m = [[1,2,3], [4,5,6], [7,8,9]]

for i in range(len(m)): # используя количество строк в матрице
    for j in range(len(m[i])): # используя количество элементов в каждой строке 
        m[i][j] += 1

print(m)
```

<sample-output>

[[2, 3, 4], [5, 6, 7], [8, 9, 10]]

</sample-output>

Внешний цикл проходит по индексам от нуля до длины матрицы, то есть количества строк в матрице. Внутренний цикл проходит по индексам от нуля до длины каждой строки в матрице.

<programming-exercise name='Number of matching elements' tmcname='part05-02_number_of_elements' title='Количество совпадающих элементов'>

Пожалуйста, напишите функцию с именем `count_matching_elements(my_matrix: list, element: int)`, которая принимает двумерный массив целых чисел и одно целочисленное значение в качестве аргументов. Функция затем подсчитывает, сколько элементов в матрице соответствуют значению аргумента.

Пример работы функции:

```python
m = [[1, 2, 1], [0, 3, 4], [1, 0, 0]]
print(count_matching_elements(m, 1))
```

<sample-output>

3

</sample-output>

</programming-exercise>

## Двумерный массив как структура данных в игре

Матрица может быть очень полезной структурой данных во многих разных играх. Например, сетка игры судоку на изображении ниже

<img src="../../part-5/5_1_3.png">

может быть представлена в матричной форме следующим образом:

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [0, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [0, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]
```

Здесь значение ноль представляет пустую клетку, поскольку ноль не является допустимым значением в законченной головоломке судоку.

Вот простая функция для вывода приведённой выше сетки судоку:

```python
def print_grid(sudoku):
    for row in sudoku:
        for square in row:
            if square > 0:
                print(f" {square}", end="")
            else:
                print(" _", end="")
        print()

print_grid(sudoku)
```

Вывод должен выглядеть так::

```x

 9 _ _ _ 8 _ 3 _ _
 _ _ _ 2 5 _ 7 _ _
 _ 2 _ 3 _ _ _ _ 4
 _ 9 4 _ _ _ _ _ _
 _ _ _ 7 3 _ 5 6 _
 7 _ 5 _ 6 _ 4 _ _
 _ _ 7 8 _ 3 9 _ _
 _ _ 1 _ _ _ _ _ 3
 3 _ _ _ _ _ _ _ 2

```

Любая обычная игра с макетом игрового поля может быть смоделирована подобным образом. Среди прочих, шахматы, Сапёр, Морской бой или Мастермайнд - все основаны на двумерной сетке. Для судоку естественно использовать числа для представления состояния игры, но для других игр могут быть лучше разные методы.

<programming-exercise name='Go' tmcname='part05-03_go' title='Го'>

В игре Го два игрока по очереди размещают чёрные и белые камни на игровой доске. Победитель - игрок, который сумеет окружить больше территории на доске своими игровыми фигурами. 

Пожалуйста, напишите функцию с именем `who_won(game_board: list)`, которая принимает двумерный массив в качестве аргумента. Массив состоит из целочисленных значений, которые представляют следующие ситуации:

* 0: пустая клетка
* 1: игровая фигура игрока 1
* 2: игровая фигура игрока 2

Правила подсчёта очков в Го могут быть довольно сложными, но в этом упражнении достаточно сравнить количество фигур, которые каждый игрок имеет на игровой доске. Также размер игровой доски не ограничен.

Функция должна вернуть значение 1, если выиграл игрок 1, и значение 2, если выиграл игрок 2. Если оба игрока имеют одинаковое количество фигур на доске, функция должна вернуть значение 0.

</programming-exercise>

<programming-exercise name='Sudoku: check row' tmcname='part05-04_sudoku_row' title='Судоку: проверка строки'>

Пожалуйста, напишите функцию с именем `row_correct(sudoku: list, row_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и целое число, ссылающееся на одну строку, в качестве аргументов. Строки индексируются с 0.

Функция должна вернуть `True` или `False`, в зависимости от того, правильно ли заполнена строка, то есть содержит ли она каждое из чисел от 1 до 9 не более одного раза.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(row_correct(sudoku, 0))
print(row_correct(sudoku, 1))
```

<sample-output>

True
False

</sample-output>

</programming-exercise>

<programming-exercise name='Sudoku: check column' tmcname='part05-05_sudoku_column' title='Судоку: проверка столбца'>

Пожалуйста, напишите функцию с именем `column_correct(sudoku: list, column_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и целое число, ссылающееся на один столбец, в качестве аргументов. Столбцы индексируются с 0. 

Функция должна вернуть `True` или `False`, в зависимости от того, правильно ли заполнен столбец, то есть содержит ли он каждое из чисел от 1 до 9 не более одного раза.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(column_correct(sudoku, 0))
print(column_correct(sudoku, 1))
```

<sample-output>

False
True

</sample-output>

</programming-exercise>

<programming-exercise name='Sudoku: check block' tmcname='part05-06_sudoku_block' title='Судоку: проверка блока'>

Пожалуйста, напишите функцию с именем `block_correct(sudoku: list, row_no: int, column_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и два целых числа, ссылающихся на индексы строки и столбца одной клетки, в качестве аргументов. Строки и столбцы индексируются с 0. 

Функция должна вернуть `True` или `False` в зависимости от того, правильно ли заполнен блок 3 на 3 вправо и вниз от данных индексов. То есть содержит ли блок каждое из чисел от 1 до 9 не более одного раза.

Обратите внимание, что эта функция не строго следует правилам судоку. В настоящей игре судоку есть только 9 блоков для проверки, и они расположены по индексам (0, 0), (0, 3), (0, 6), (3, 0), (3, 3), (3, 6), (6, 0), (6, 3) и (6, 6). Такие ограничения на индексы здесь не должны быть реализованы.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(block_correct(sudoku, 0, 0))
print(block_correct(sudoku, 1, 2))
```

<sample-output>

False
True

</sample-output>

Первый вызов функции должен проверить блок 3 на 3, начинающийся с клетки по индексам `0, 0`:

<pre>
9 0 0
2 0 0
0 2 0
</pre>

Второй вызов функции должен проверить блок 3 на 3, начинающийся с клетки в строке 1, столбце 2:

<pre>
0 2 5
0 3 0
4 0 0
</pre>

Этот второй блок не был бы проверен в фактической игре судоку, но ваша функция должна позволить его проверить.

</programming-exercise>

<programming-exercise name='Sudoku: check grid' tmcname='part05-07_sudoku_grid' title='Судоку: проверка сетки'>

Пожалуйста, напишите функцию с именем `sudoku_grid_correct(sudoku: list)`, которая принимает двумерный массив, представляющий сетку судоку, в качестве аргумента. Функция должна использовать функции из трёх предыдущих упражнений, чтобы определить, правильно ли заполнена полная сетка судоку. Скопируйте функции из упражнений выше в ваш файл с кодом Python для этого упражнения.

Функция должна проверить каждую из девяти строк, столбцов и блоков 3 на 3 в сетке. Если все содержат каждое из чисел от 1 до 9 не более одного раза, функция возвращает `True`. Если хотя бы один заполнен неправильно, функция возвращает `False`. 

Изображение сетки судоку выше этих упражнений имеет девять блоков в сетке, обозначенные более толстыми границами. Это блоки, которые функция должна проверить, и они начинаются по индексам (0, 0), (0, 3), (0, 6), (3, 0), (3, 3), (3, 6), (6, 0), (6, 3) и (6, 6). 

```python
sudoku1 = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(sudoku_grid_correct(sudoku1))

sudoku2 = [
  [2, 6, 7, 8, 3, 9, 5, 0, 4],
  [9, 0, 3, 5, 1, 0, 6, 0, 0],
  [0, 5, 1, 6, 0, 0, 8, 3, 9],
  [5, 1, 9, 0, 4, 6, 3, 2, 8],
  [8, 0, 2, 1, 0, 5, 7, 0, 6],
  [6, 7, 4, 3, 2, 0, 0, 0, 5],
  [0, 0, 0, 4, 5, 7, 2, 6, 3],
  [3, 2, 0, 0, 8, 0, 0, 5, 7],
  [7, 4, 5, 0, 0, 3, 9, 0, 1]
]

print(sudoku_grid_correct(sudoku2))
```

<sample-output>

False
True

</sample-output>

</programming-exercise>

<!---
A quiz to review the contents of this section:

<quiz id="ccb6dcbf-1065-513f-9294-15f42a318300"></quiz>
-->