---
path: '/ru/part-5/2-references'
title: 'Ссылки'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы узнаете, что означает ссылка на переменную
- Вы поймете, что может существовать несколько ссылок на один и тот же объект
- Вы сможете использовать списки в качестве параметров в функциях
- Вы узнаете, что означает побочный эффект функции

</text-box>

До сих пор мы думали о переменной как о своеобразном "ящике", который содержит значение переменной. Технически это неверно в Python. То, что хранится в переменной, это не само значение, а _ссылка_ на _объект_, который является фактическим значением переменной. Объектом может быть, например, число, строка или список.

На практике это означает, что значение переменной _не хранится_ в самой переменной. Вместо этого есть информация о местоположении в памяти компьютера, где можно найти это значение.

Ссылка часто представляется стрелкой от переменной к фактическому значению в памяти:

<img src="../../part-5/5_2_1.png">

Итак, ссылка сообщает нам, где можно найти значение. Функция `id` может использоваться для определения точного местоположения, на которое указывает переменная:

```python
a = [1, 2, 3]
print(id(a))
b = "Это тоже ссылка"
print(id(b))
```

<sample-output>

4538357072
4537788912

</sample-output>

Ссылка, или ID переменной, это целое число, которое можно рассматривать как адрес в памяти компьютера, где хранится значение переменной. Если вы выполните приведенный выше код на своем компьютере, результат, скорее всего, будет другим, поскольку ваши переменные будут указывать на другие местоположения - ссылки будут разными.

Инструмент визуализации Python Tutor также показывает ссылки как стрелки от переменной к фактическому содержимому, как мы видели в [предыдущем разделе](/ru/part-5/1-more-lists#визуализация-кода-содержащего-списки-в-списках). Однако инструмент немного "жульничает", когда дело доходит до строк. Он отображает строки так, как будто они хранятся в самих переменных:

<img src="../../part-5/5_2_2.png">

В действительности строки Python обрабатываются очень похоже на списки, со ссылками на местоположения в памяти.

Многие из встроенных типов в Python, такие как `str`, являются _неизменяемыми_. Это означает, что значение объекта или любая его часть не может изменяться. Значение может быть заменено новым значением:

<img src="../../part-5/5_2_3.png">

Некоторые типы Python являются _изменяемыми_. Например, содержимое списка может изменяться без необходимости создания совершенно нового списка:

<img src="../../part-5/5_2_4.png">

Вас может удивить, что также основные типы данных `int`, `float` и `bool` являются неизменяемыми в Python. Давайте посмотрим на следующий фрагмент кода:

```python
number = 1
number = 2
number += 10
```

Кажется, что команды выше просто изменяют значение, хранящееся в переменной, но на самом деле каждая команда создает совершенно новое число в памяти компьютера.

Вывод из следующей программы проясняет ситуацию:

```python
number = 1
print(id(number))
number += 10
print(id(number))
a = 1
print(id(a))
```

<sample-output>

4535856912
4535856944
4535856912

</sample-output>

Сначала переменная `number` указывает на местоположение в памяти 4535856912. Когда `number` присваивается новое значение, она указывает на местоположение 4535856944. Теперь, когда переменной `a` присваивается значение 1, `a` указывает на то же самое местоположение, куда указывала `number`, когда ей также было присвоено значение 1.

Похоже, Python сохранил значение 1 в местоположении памяти 4535856912. Всякий раз, когда переменной присваивается значение 1, она _ссылается_ на это местоположение в памяти компьютера.

Хорошо помнить, что _почти все является ссылкой_ в Python, но все это редко актуально для повседневных задач программирования. Так что давайте вернемся к более практическим вопросам.

## Несколько ссылок на один и тот же список

Что на самом деле происходит, когда вы присваиваете переменную списка новой переменной - копируется ли список?

```python
a = [1, 2, 3]
b = a
b[0] = 10
```

Присваивание `b = a` копирует значение, хранящееся в переменной `a`, в переменную `b`. Однако значение, хранящееся в `a`, это не сам _список_, а _ссылка_ на список.

Таким образом, присваивание `b = a` копирует ссылку. В результате теперь есть две ссылки на одно и то же местоположение в памяти, содержащее список.

<img src="../../part-5/5_2_5.png">

К списку можно получить доступ через любую из двух ссылок:

```python
list1 = [1, 2, 3, 4]
list2 = list1

list1[0] = 10
list2[1] = 20

print(list1)
print(list2)
```

<sample-output>

[10, 20, 3, 4]
[10, 20, 3, 4]

</sample-output>

Если есть более одной ссылки на один и тот же список, любая из ссылок может использоваться для доступа к списку. С другой стороны, изменение, сделанное через любую из ссылок, влияет также на другие ссылки, поскольку их цель одинакова.

Инструмент визуализации снова очень полезен для понимания того, что происходит:

<img src="../../part-5/5_2_6.png">

## Копирование списка

Если вы хотите создать фактически отдельную копию списка, вы можете создать новый список и добавить каждый элемент из исходного списка по очереди:

```python
my_list = [1, 2, 3, 3, 5]

new_list = []
for item in my_list:
    new_list.append(item)

new_list[0] = 10
new_list.append(6)
print("оригинал:", my_list)
print("копия:", new_list)
```

<sample-output>

оригинал [1, 2, 3, 3, 5]
копия [10, 2, 3, 3, 5, 6]

</sample-output>

Снимок процесса копирования в инструменте визуализации:

<img src="../../part-5/5_2_7.png">

Переменная `new_list` указывает на другой список, чем переменная `my_list`.

Более простой способ скопировать список - это оператор квадратных скобок `[]`, который мы использовали ранее для срезов. Обозначение `[:]` выбирает все элементы в коллекции. Как побочный эффект, это создает копию списка:

```python
my_list = [1,2,3,4]
new_list = my_list[:]

my_list[0] = 10
new_list[1] = 20

print(my_list)
print(new_list)
```

<sample-output>

[10, 2, 3, 4]
[1, 20, 3, 4]

</sample-output>

## Использование списков в качестве параметров в функциях

Когда вы передаете список в качестве аргумента функции, вы передаете ссылку на этот список. Это означает, что функция может изменять список напрямую.

Следующая функция принимает список в качестве аргумента и добавляет новый элемент в конец списка:

```python
def add_item(my_list: list):
    new_item = 10
    my_list.append(new_item)

a_list = [1,2,3]
print(a_list)
add_item(a_list)
print(a_list)
```

<sample-output>
[1, 2, 3]
[1, 2, 3, 10]
</sample-output>

Обратите внимание, что функция `add_item` не имеет возвращаемого значения. Она только изменяет список, который принимает в качестве аргумента.

Инструмент визуализации может помочь вам понять, что здесь происходит:

<img src="../../part-5/5_2_8.png">

_Global frame_ относится к переменным, определенным в главной функции, тогда как фрейм *add_item* с синим фоном представляет параметры и переменные в этой функции. Как вы можете видеть из визуализации, функция `add_item` ссылается на тот же самый список, что и главная функция. Изменения, сделанные в функции `add_item`, также влияют на главную функцию.

Другой способ реализовать эту функциональность - создать новый список внутри функции и вернуть его:

```python
def add_item(my_list: list) -> list:
    new_item = 10
    my_list_copy = my_list[:]
    my_list_copy.append(new_item)
    return my_list_copy

numbers = [1, 2, 3]
numbers2 = add_item(numbers)

print("исходный список:", numbers)
print("новый список:", numbers2)
```

<sample-output>

исходный список: [1, 2, 3]
новый список: [1, 2, 3, 10]

</sample-output>

Если вы не абсолютно уверены, что понимаете, что происходит в коде выше, пожалуйста, пройдите через него в инструменте визуализации.

## Редактирование списка, переданного в качестве аргумента

Следующая попытка создать функцию, которая должна увеличить каждый элемент в списке на десять:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)
    my_list = new_list

numbers = [1, 2, 3]
print("в начале:", numbers)
augment_all(numbers)
print("после выполнения функции:", numbers)
```

<sample-output>

в начале: [1, 2, 3]
после выполнения функции: [1, 2, 3]

</sample-output>

По какой-то причине функция не работает, так что же происходит?

Функция принимает _ссылку_ на список в качестве аргумента. Это хранится в переменной `my_list`. Присваивание `my_list = new_list` присваивает новое значение этой же переменной. Переменная `my_list` теперь указывает на новый список, созданный внутри функции, и ссылка на исходный список больше не доступна внутри функции. Однако это присваивание не имеет эффекта вне функции.

<!---
Следующая последовательность изображений иллюстрирует состояния переменных на разных этапах во время выполнения функции:

<img src="../../part-5/5_2_9.png" width="400">
-->

Кроме того, переменная `new_list`, которая содержит новые, увеличенные значения, недоступна извне функции. Она "теряется" по завершении выполнения функции, и фокус возвращается к главной функции. Переменная `numbers` в главной функции всегда указывает на исходный список.

Инструмент визуализации - ваш друг и здесь. Пожалуйста, пройдите через этапы внимательно и посмотрите, как исходный список вообще не затрагивается выполнением функции:

<img src="../../part-5/5_2_10.png">

Один из способов исправить это - скопировать все элементы из нового списка в старый список, один за другим:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)

    # копируем элементы из нового списка в старый список
    for i in range(len(my_list)):
        my_list[i] = new_list[i]
```

Python также имеет удобное сокращение для присваивания нескольких элементов в коллекции одновременно:

```python
>>> my_list = [1, 2, 3, 4]
>>> my_list[1:3] = [10, 20]
>>> my_list
[1, 10, 20, 4]
```

В примере выше срезу списка присваиваются значения из другой коллекции.

Как мы знаем, срез может включать всю коллекцию:

```python
>>> my_list = [1, 2, 3, 4]
>>> my_list[:] = [100, 99, 98, 97]
>>> my_list
[100, 99, 98, 97]
```

Все содержимое старого списка заменяется. Вдохновленная этим, рабочая версия функции увеличения может выглядеть так:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)

    my_list[:] = new_list
```

На самом деле, нет необходимости создавать новый список внутри функции вообще. Мы можем просто присвоить новые значения напрямую в исходный список:

```python
def augment_all(my_list: list):
    for i in range(len(my_list)):
        my_list[i] += 10
```

<programming-exercise name='Элементы, умноженные на два' tmcname='part05-08_items_multiplied_by_two'>

Пожалуйста, напишите функцию с именем `double_items(numbers: list)`, которая принимает список целых чисел в качестве аргумента.

Функция должна вернуть новый список, который содержит все значения из исходного списка, удвоенные. Функция _не должна_ изменять исходный список.

Пример работы функции:

```python
if __name__ == "__main__":
    numbers = [2, 4, 5, 3, 11, -4]
    numbers_doubled = double_items(numbers)
    print("исходный:", numbers)
    print("удвоенный:", numbers_doubled)
```
<sample-output>

исходный: [2, 4, 5, 3, 11, -4]
удвоенный: [4, 8, 10, 6, 22, -8]

</sample-output>

</programming-exercise>

<programming-exercise name='Удалить наименьший' tmcname='part05-09_remove_smallest'>

Пожалуйста, напишите функцию с именем `remove_smallest(numbers: list)`, которая принимает список целых чисел в качестве аргумента.

Функция должна найти и удалить наименьший элемент в списке. Можно предположить, что в списке есть один наименьший элемент.

Функция не должна иметь возвращаемого значения - она должна напрямую изменять список, который получает в качестве параметра.

Пример работы функции:

```python
if __name__ == "__main__":
    numbers = [2, 4, 6, 1, 3, 5]
    remove_smallest(numbers)
    print(numbers)
```
<sample-output>

[2, 4, 6, 3, 5]

</sample-output>

</programming-exercise>

<programming-exercise name='Судоку: вывести сетку и добавить число' tmcname='part05-10_sudoku_print_and_add'>

В этом упражнении мы завершим еще две функции для проекта судоку из предыдущего раздела: `print_sudoku` и `add_number`.

Функция `print_sudoku(sudoku: list)` принимает двумерный массив, представляющий сетку судоку, в качестве аргумента. Функция должна вывести сетку в формате, указанном в примерах ниже.

Функция `add_number(sudoku: list, row_no: int, column_no: int, number:int)` принимает двумерный массив, представляющий сетку судоку, два целых числа, ссылающиеся на индексы строки и столбца отдельной ячейки, и одну цифру между 1 и 9, в качестве аргументов. Функция должна добавить цифру в указанное место в сетке.

```python
sudoku  = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
]

print_sudoku(sudoku)
add_number(sudoku, 0, 0, 2)
add_number(sudoku, 1, 2, 7)
add_number(sudoku, 5, 7, 3)
print()
print("Три числа добавлены:")
print()
print_sudoku(sudoku)
```

<sample-output>

<pre>
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

Три числа добавлены:

2 _ _  _ _ _  _ _ _
_ _ 7  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ 3 _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

</pre>

</sample-output>

**Подсказка**

Помните, что можно вызвать функцию `print` без перехода на новую строку:

```python
print("символы ", end="")
print("без переноса строки", end="")
```

<sample-output>

символы без переноса строки

</sample-output>

Иногда вам нужна просто новая строка, которую даст оператор print без аргументов:

```python
print()
```

</programming-exercise>

<programming-exercise name='Судоку: добавить число в копию сетки' tmcname='part05-11_sudoku_add_to_copy'>

Это самое последнее задание по судоку. На этот раз мы создадим несколько другую версию функции для добавления новых чисел в сетку.

Функция `copy_and_add(sudoku: list, row_no: int, column_no: int, number: int)` принимает двумерный массив, представляющий сетку судоку, два целых числа, ссылающиеся на индексы строки и столбца отдельной ячейки, и одну цифру между 1 и 9, в качестве аргументов. Функция должна _вернуть_ копию исходной сетки с новой цифрой, добавленной в правильное место. Функция _не должна_ изменять исходную сетку, полученную в качестве параметра.

Функция `print_sudoku` из предыдущего упражнения может быть полезна для тестирования, и она используется в примере ниже:

```python
sudoku  = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
]

grid_copy = copy_and_add(sudoku, 0, 0, 2)
print("Исходная:")
print_sudoku(sudoku)
print()
print("Копия:")
print_sudoku(grid_copy)
```

<sample-output>

<pre>
Исходная:
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

Копия:
2 _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

</pre>

</sample-output>

**Подсказка** 
При работе с вложенными списками следует быть особенно осторожным при копировании. Что все нужно явно скопировать, и где изменения фактически имеют эффект? [Инструмент визуализации](http://www.pythontutor.com/visualize.html#mode=edit) - отличная помощь и здесь, хотя размер сетки судоку сделает вид менее аккуратным, чем обычно.

</programming-exercise>

<programming-exercise name='Крестики-нолики' tmcname='part05-12_tic_tac_toe'>

Крестики-нолики играются на сетке 3 на 3 двумя игроками, которые по очереди ставят нолики и крестики. Если любой игрок успевает разместить три своих символа в любой строке, столбце или диагонали, он выигрывает. Если ни один игрок не справляется с этим, это ничья.

Пожалуйста, напишите функцию с именем `play_turn(game_board: list, x: int, y: int, piece: str)`, которая размещает данный символ в данных координатах на доске. Значения координат на доске находятся между 0 и 2.

**Примечание:** в отличие от упражнений по судоку, аргументы, которые принимает функция, здесь расположены в другом порядке. Столбец `x` идет первым, а строка `y` - вторым.

Доска состоит из следующих строк:

* `""`: пустая ячейка
* `"X"`: символ игрока 1
* `"O"`: символ игрока 2

Функция должна вернуть `True`, если ячейка была пустой и символ был успешно размещен на игровой доске. Функция должна вернуть `False`, если ячейка была занята или если координаты были недействительными.

Пример выполнения функции:

```python
game_board = [["", "", ""], ["", "", ""], ["", "", ""]]
print(play_turn(game_board, 2, 0, "X"))
print(game_board)
```

<sample-output>

True
[['', '', 'X'], ['', '', ''], ['', '', '']]

</sample-output>

</programming-exercise>

<programming-exercise name='Транспонировать матрицу' tmcname='part05-13_transpose_matrix'>

Пожалуйста, напишите функцию с именем `transpose(matrix: list)`, которая принимает двумерный массив целых чисел, то есть матрицу, в качестве аргумента. Функция должна _транспонировать_ матрицу. Транспонирование означает по сути переворачивание матрицы по ее диагонали: столбцы становятся строками, а строки становятся столбцами.

Вы можете предположить, что матрица является квадратной матрицей, поэтому она будет иметь одинаковое количество строк и столбцов.

Следующая матрица

```python
1 2 3
4 5 6
7 8 9
```

транспонированная выглядит так:

```python
1 4 7
2 5 8
3 6 9
```

Функция не должна иметь возвращаемого значения. Матрица должна быть изменена напрямую через ссылку.

</programming-exercise>

## Побочные эффекты функций

Если функция принимает ссылку на список в качестве аргумента, она сможет изменить этот список. Если прямые изменения не были предназначены программистом, случайное изменение списка, полученного в качестве параметра, может вызвать проблемы в других местах программы.

Давайте посмотрим на функцию, которая должна найти второй наименьший элемент в списке:

```python
def second_smallest(my_list: list) -> int:
    # в упорядоченном списке второй наименьший элемент находится по индексу 1
    my_list.sort()
    return my_list[1]

numbers = [1, 4, 2, 5, 3, 6, 4, 7]
print(second_smallest(numbers))
print(numbers)
```

<sample-output>
2
[1, 2, 3, 4, 4, 5, 6, 7]
</sample-output>

Функция действительно надежно находит второй наименьший элемент, но дополнительно сортирует список на месте, изменяя порядок элементов. Если порядок значим в других частях программы, вызов функции может вызвать ошибки. Непреднамеренные изменения объекта, доступного через ссылку, называются _побочным эффектом_ функции.

Мы можем избежать побочного эффекта, внеся небольшое изменение в функцию:

```python
def second_smallest(my_list: list) -> int:
    list_copy = sorted(my_list)
    return list_copy[1]

numbers = [1, 4, 2, 5, 3, 6, 4, 7]
print(second_smallest(numbers))
print(numbers)
```

<sample-output>

2
[1, 4, 2, 5, 3, 6, 4, 7]

</sample-output>

Функция `sorted` возвращает новую, отсортированную копию списка, поэтому поиск второго наименьшего элемента больше не влияет на порядок исходного списка.

Как правило, считается хорошей практикой программирования избегать побочных эффектов в функциях. Побочные эффекты могут затруднить проверку того, что программа функционирует как задумано во всех ситуациях.

Функции без побочных эффектов также называются _чистыми функциями_. Особенно при следовании стилю функционального программирования это общий идеал. Мы исследуем эту тему далее в _Продвинутом курсе программирования_, который является курсом, следующим за этим.

<!---
Викторина для обзора содержания этого раздела:

<quiz id="b254a4f9-09bb-55c8-87c0-538f91e51ace"></quiz>
-->