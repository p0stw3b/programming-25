---
path: '/ru/part-13/2-animation'
title: 'Анимация'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела

- Вы будете знать, как создать анимацию с помощью pygame
- Вы сможете использовать часы для установки скорости вашей программы
- Вы сможете использовать базовые тригонометрические функции в своих анимациях

</text-box>

Во многих играх есть движущиеся персонажи, поэтому логичным следующим шагом является создание анимаций. Мы можем создать иллюзию движения, рисуя одно и то же изображение в разных местах на экране и правильно синхронизируя изменения.

## Создание анимации

Следующий код создает анимацию, в которой робот движется слева направо в окне pygame:

```python
import pygame

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

x = 0
y = 0
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()

    x += 1
    clock.tick(60)
```

При выполнении результат должен выглядеть так:

<img src="../../part-13/pygame_animation.gif">

Рассмотрим более подробно задействованные команды. Если мы хотим отследить движение изображения на экране, нам нужно знать его местоположение, поэтому у нас есть две переменные для координат левого верхнего угла изображения:

```python
x = 0
y = 0
```

У нас также есть часы, которые мы используем, чтобы убедиться, что скорость анимации подходящая:

```python
clock = pygame.time.Clock()
```

Главный цикл рисует изображение в его текущем местоположении на каждой итерации:

```python
    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()
```

Сначала метод `fill` заполняет окно чёрным цветом, как и раньше. Цвет передается как кортеж, содержащий RGB значения для цвета. В этом случае аргумент `(0, 0, 0)` означает, что все три компонента - красный, зелёный и синий - имеют значение 0. Каждый компонент может иметь значение между 0 и 255. Так, если бы мы передали `(255, 255, 255)` в качестве аргумента, мы бы получили белое окно, а с `(255, 0, 0)` мы бы получили красное окно. RGB цветовые коды составляют основу цифровой окраски, и в интернете есть много инструментов для работы с ними, например [RGB Color Codes Chart](https://www.rapidtables.com/web/color/RGB_Color.html).

После того как окно заполнено цветом, изображение рисуется в данном местоположении методом `blit`. Затем содержимое окна обновляется функцией `pygame.display.flip`.

Наконец, значение, хранящееся в `x`, увеличивается, что заставляет изображение двигаться на один пиксель вправо с каждой итерацией:

```python
    x += 1
```

В конце вызывается метод часов `tick`:

```python
    clock.tick(60)
```

Метод `tick` заботится о скорости анимации. Аргумент `60` диктует, что цикл должен выполняться 60 раз в секунду, что означает, что изображение движется на 60 пикселей вправо каждую секунду. Это приблизительно соответствует значению _FPS_ или _кадров в секунду_, используемому в играх.

В принципе, метод `tick` гарантирует, что анимация работает с одинаковой скоростью на каждом компьютере. Если бы не было такой синхронизации, скорость анимации зависела бы от скорости компьютера.

## Отскок от стены

Предыдущая анимация была превосходна, но когда робот достигал стены, он просто продолжал двигаться из поля зрения. Заставим робота отскакивать от стены.

```python
import pygame

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

x = 0
y = 0
velocity = 1
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()
    
    x += velocity
    if velocity > 0 and x+robot.get_width() >= 640:
        velocity = -velocity
    if velocity < 0 and x <= 0:
        velocity = -velocity

    clock.tick(60)
```

Выполнение приведенного выше кода должно выглядеть так:

<img src="../../part-13/pygame_animation2.gif">

Есть новая переменная `velocity`, которая определяет направление движения. Если значение больше нуля, движение происходит вправо, а если меньше нуля, движение происходит влево. Точнее, в данном случае, если значение равно `1`, робот движется вправо, а если оно равно `-1`, робот движется влево.

Следующие строки заставляют робота отскакивать от боковых стен:

```python
    if velocity > 0 and x+robot.get_width() >= 640:
        velocity = -velocity
    if velocity < 0 and x <= 0:
        velocity = -velocity
```

Если скорость больше нуля, так что робот движется вправо, и правый край изображения выходит за правый край окна, направление меняется на противоположное, и робот начинает двигаться влево. Аналогично, если скорость меньше нуля, так что робот движется влево, и левый край изображения достигает левого края окна, направление снова меняется на противоположное, и робот начинает двигаться вправо снова.

Это заставляет робота двигаться по пути от левого края окна к правому краю, и обратно к левому, а затем к правому снова, повторяя это до бесконечности.

## Вращение

Создадим ещё одну анимацию. На этот раз робот должен _вращаться_ по кругу вокруг центра окна:

```python
import pygame
import math

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

angle = 0
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    x = 320+math.cos(angle)*100-robot.get_width()/2
    y = 240+math.sin(angle)*100-robot.get_height()/2

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()

    angle += 0.01
    clock.tick(60)
```

Выполнение приведенного выше кода должно выглядеть так:

<img src="../../part-13/pygame_rotation.gif">

Вращение в относительно точном круге достигается с помощью некоторых базовых тригонометрических функций. Переменная `angle` содержит угол местоположения робота относительно центра окна и горизонтальной линии, проходящей через него. Функции синуса и косинуса из библиотеки math Python используются для вычисления координат местоположения робота:

```python
        x = 320+math.cos(angle)*100-robot.get_width()/2
        y = 240+math.sin(angle)*100-robot.get_height()/2
```

Робот вращается вокруг круга радиусом 100 вокруг центра окна. Гипотенуза в этом сценарии - это радиус круга. Функция косинуса даёт длину _прилежащей_ стороны прямоугольного треугольника относительно гипотенузы, что означает, что она даёт нам координату `x` местоположения. Функция синуса даёт длину _противоположной_ стороны, то есть координату `y`. Местоположение затем корректируется для размера изображения, так что центр круга находится в центре окна.

С каждой итерацией размер `angle` увеличивается на 0.01. Поскольку мы используем радианы, полный круг равен 2π, что равно примерно 6.28. Роботу требуется около 628 итераций, чтобы пройти полный круг, и при 60 итерациях в секунду это занимает чуть более 10 секунд.

<programming-exercise name='Vertical movement' tmcname='part13-05_vertical_movement'>

Пожалуйста, создайте анимацию, где робот движется вверх и вниз в бесконечном цикле. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_vertical.gif">

</programming-exercise>

<programming-exercise name='Round the perimeter' tmcname='part13-06_round_the_perimeter'>

Пожалуйста, создайте анимацию, где робот обходит периметр окна. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_perimeter.gif">

</programming-exercise>

<programming-exercise name='Two robots' tmcname='part13-07_two_robots'>

Пожалуйста, создайте анимацию, где два робота движутся взад и вперед влево и вправо. Нижний робот должен двигаться в два раза быстрее верхнего. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_move2.gif">

</programming-exercise>

<programming-exercise name='Robots in a circle' tmcname='part13-08_robot_circle'>

Пожалуйста, создайте анимацию, где десять роботов движутся по кругу. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_circle.gif">

</programming-exercise>

<programming-exercise name='Bouncing ball' tmcname='part13-09_bouncing_ball'>

Пожалуйста, создайте анимацию, где мяч отскакивает от краёв окна. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_bounce.gif">

Шаблон упражнения содержит изображение `ball.png`.

</programming-exercise>

<programming-exercise name='Robot invasion' tmcname='part13-10_robot_invasion'>

Пожалуйста, создайте анимацию, где роботы случайно падают с неба. Когда робот достигает земли, он начинает двигаться влево или вправо, и наконец исчезает с экрана. Конечный результат должен выглядеть так:

<img src="../../part-13/pygame_invasion.gif">

</programming-exercise>