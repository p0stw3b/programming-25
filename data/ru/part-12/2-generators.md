---
path: '/ru/part-12/2-generators'
title: 'Генераторы'
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После изучения этого раздела

- Вы поймёте, что такое генератор Python
- Вы будете знакомы с ключевым словом `yield`
- Вы сможете писать собственные функции-генераторы

</text-box>

Мы уже сталкивались с ситуациями, когда мы имеем дело с рядом элементов, и нам нужны следующие элементы в ряду, но мы не обязательно хотим формулировать весь ряд до этой точки каждый раз, когда требуется новый элемент. Некоторые рекурсивные ряды, такие как числа Фибоначчи, являются хорошим примером такой ситуации. Если каждый вызов функции рекурсивно генерирует весь ряд до желаемой точки, мы в итоге генерируем начало ряда много раз подряд.

_Генераторы_ Python — это способ производить только следующий элемент в ряду, когда он нужен, по сути, выполняя процесс генерации для ряда только один раз (для данного выполнения программы). Они работают в основном как обычные функции, поскольку их можно вызывать и они будут возвращать значения, но значение, которое возвращает функция-генератор, отличается от обычной функции. Обычная функция должна возвращать одно и то же значение каждый раз при одинаковых аргументах. Функция-генератор, с другой стороны, должна помнить своё текущее состояние и возвращать следующий элемент в ряду, который может отличаться от предыдущего элемента.

Точно так же, как существует много способов решения почти любой программистской задачи, существует много способов достижения функциональности, аналогичной генераторам, но генераторы могут помочь сделать программу более понятной и в определённых ситуациях сэкономить память или другие вычислительные ресурсы.

## Ключевое слово yield

Функция-генератор должна содержать ключевое слово `yield`, которое отмечает значение, которое возвращает функция. Давайте рассмотрим функцию, которая генерирует целые числа, начиная с нуля и заканчивая предопределённым максимальным значением:

```python

def counter(max_value: int):
    number = 0
    while number <= max_value:
        yield number
        number += 1

```

Теперь функция `counter` может быть передана в качестве аргумента функции `next()`:

```python
if __name__ == "__main__":
    numbers = counter(10)
    print("First value:")
    print(next(numbers))
    print("Second value:")
    print(next(numbers))
```

<sample-output>

First value:
0
Second value:
1

</sample-output>

Как вы можете видеть из примера выше, ключевое слово `yield` похоже на ключевое слово `return`: оба используются для определения возвращаемого значения. Разница в том, что `yield` не "закрывает" функцию в том же смысле, что и `return`. Функция-генератор с ключевым словом `yield` отслеживает своё состояние, и при следующем вызове она продолжит с того же состояния.

Этот генератор также требует максимального значения, которое было `10` в примере выше. Когда у генератора заканчиваются значения, он вызывает исключение `StopIteration`:

```python
if __name__ == "__main__":
    # creates a generator with maximum value 1
    numbers = counter(1)
    print(next(numbers))
    print(next(numbers))
    print(next(numbers))
```

<sample-output>

0
1
Traceback (most recent call last):
  File "generator_example.py", line 11, in <module>
    print(next(numbers))
StopIteration

</sample-output>

Исключение можно перехватить с помощью блока `try` - `except`:

```python
if __name__ == "__main__":
    numbers = counter(1)
    try:
        print(next(numbers))
        print(next(numbers))
        print(next(numbers))
    except StopIteration:
        print("ran out of numbers")
```

<sample-output>

0
1
ran out of numbers

</sample-output>

Прохождение через все элементы генератора легко делается с помощью цикла `for`:

```python
if __name__ == "__main__":
    numbers = counter(5)
    for number in numbers:
        print(number)
```

<sample-output>

0
1
2
3
4
5

</sample-output>

Генераторы не обязательно должны иметь определённое максимальное значение или точку завершения. Они могут генерировать значения бесконечно (в пределах других вычислительных и физических ограничений, естественно).

Обратите внимание: прохождение генератора с помощью цикла `for` работает только в том случае, если генератор в какой-то момент завершается. Если генератор построен на бесконечном цикле, попытка пройти его простым циклом `for` приведёт к бесконечному выполнению, точно так же, как цикл `while` без конца или условия break.

<programming-exercise name='Even numbers' tmcname='part12-08_even_numbers'>

Напишите функцию-генератор `even_numbers(beginning: int, maximum: int)`, которая принимает два целых числа в качестве аргументов. Функция должна генерировать чётные числа, начиная с `beginning` и заканчивая, максимум, `maximum`.

Два примера работы функции:

```python
numbers = even_numbers(2, 10)
for number in numbers:
    print(number)
```

<sample-output>

2
4
6
8
10

</sample-output>

```python
numbers = even_numbers(11, 21)
for number in numbers:
    print(number)
```

<sample-output>

12
14
16
18
20

</sample-output>

</programming-exercise>

<programming-exercise name='Prime numbers' tmcname='part12-09_prime_numbers'>

Простое число — это число, которое делится только на себя и на число 1. По соглашению простые числа определяются как положительные целые числа от числа 2 и выше. Первые шесть простых чисел: 2, 3, 5, 7, 11 и 13.

Напишите функцию-генератор `prime_numbers()`, которая создаёт новый генератор. Генератор должен возвращать новые простые числа, одно за другим в последовательности, начиная с 2. НБ: этот генератор никогда не завершается. Он будет генерировать числа столько, сколько они нужны.

Например:

```python
numbers = prime_numbers()
for i in range(8):
    print(next(numbers))
```

<sample-output>

2
3
5
7
11
13
17
19

</sample-output>

**Подсказка:** вы можете использовать цикл для проверки, является ли число простым. Если мы проверяем число `x`, цикл проходил бы через числа от `2` до `x-1`. Если `x` делится на любое из них, это не простое число.

</programming-exercise>


## Генераторные выражения

Вам не обязательно нужно определение функции для создания генератора. Вместо этого мы можем использовать структуру, аналогичную спискам выражения. На этот раз мы используем _круглые_ скобки для обозначения генератора вместо списка или словаря:

```python
# This generator returns squares of integers
squares = (x ** 2 for x in range(1, 64))

print(squares) # the printout of a generator object isn't too informative

for i in range(5):
    print(next(squares))
```

<sample-output>

<generator object &lt;genexpr&gt; at 0x000002B4224EBFC0>
1
4
9
16
25

</sample-output>

В следующем примере мы выводим подстроки английского алфавита, каждая длиной в три символа. Это выводит первые 10 элементов в генераторе:

```python
substrings = ("abcdefghijklmnopqrstuvwxyz"[i : i + 3] for i in range(24))

# print out first 10 substrings
for i in range(10):
    print(next(substrings))
```

<sample-output>

abc
bcd
cde
def
efg
fgh
ghi
hij
ijk
jkl

</sample-output>

<programming-exercise name='Random words' tmcname='part12-10_random_words'>

Напишите функцию `word_generator(characters: str, length: int, amount: int)`, которая возвращает новый генератор для генерации случайных слов на основе заданных параметров.

Случайное слово генерируется путём выбора из строки `characters` такого количества символов, которое указано аргументом `length`. Один и тот же символ может появляться много раз в случайном слове.

Генератор возвращает столько слов, сколько указано аргументом `amount`, прежде чем завершиться.

Пример работы генератора слов:

```python
wordgen = word_generator("abcdefg", 3, 5)
for word in wordgen:
    print(word)
```

<sample-output>

dbf
baf
ead
fga
ccc

</sample-output>

НБ: вам решать, как реализовать эту функцию. Вы можете использовать "традиционный" генератор или генераторное выражение одинаково хорошо.

</programming-exercise>