---
path: '/ru/part-14/2-robot-and-boxes'
title: 'Робот и ящики'
hidden: false
---

Самая сложная вещь для реализации в игре в стиле Sokoban, как правило, — это перемещение робота так, чтобы он мог толкать ящики в желаемом направлении. Игра должна уметь определять, когда робот может двигаться в указанном направлении, и уметь обрабатывать любую ситуацию, где ящик также должен двигаться. Давайте теперь решим эту задачу.

## Обработка событий клавиш

Игрок управляет роботом с помощью четырёх клавиш-стрелок, поэтому наш обработчик событий также должен уметь реагировать на соответствующие события клавиш:

```python
    def check_events(self):
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    self.move(0, -1)
                if event.key == pygame.K_RIGHT:
                    self.move(0, 1)
                if event.key == pygame.K_UP:
                    self.move(-1, 0)
                if event.key == pygame.K_DOWN:
                    self.move(1, 0)

            if event.type == pygame.QUIT:
                exit()
```

Теперь всякий раз, когда игрок нажимает клавишу-стрелку, метод `move` вызывается с соответствующей парой аргументов. Первый аргумент содержит движение в вертикальном направлении, а второй содержит движение в горизонтальном направлении.

## Поиск робота

Игра должна знать местоположение робота, чтобы правильно его перемещать. Давайте добавим метод `find_robot`, который определяет местоположение робота:

```python
    def find_robot(self ):
        for y in range(self.height):
            for x in range(self.width):
                if self.map[y][x] in [4, 6]:
                    return (y, x)
```

Метод проходит через все клетки в игровой сетке и возвращает координаты клетки, которая содержит либо число 4 (робот сам по себе), либо число 6 (робот на целевой клетке).

Идея заключается в том, что всякий раз, когда игрок нажимает клавишу-стрелку, сначала устанавливается местоположение робота путём прохождения клеток сетки. Это может показаться немного медленным и излишним, поскольку мы могли бы также просто держать местоположение робота в отдельной переменной или двух. Преимущество этого подхода поиска состоит в том, что мы не храним местоположение робота в двух разных местах (в игровой сетке _и_ отдельных переменных), а вместо этого нам просто нужно беспокоиться об одном месте (игровой сетке), что означает, что состояние игры в компьютерной памяти проще в обработке.

## Изменения в игровой сетке

Мы уже вызвали метод `move` выше, но мы ещё не определили его. Давайте сделаем это сейчас.

Метод `move` принимает направление, в котором игрок хочет двигаться, в качестве своих аргументов. Затем он соответственно обновляет игровую сетку или определяет, что ход не разрешён, и оставляет сетку без изменений.

```python
    def move(self, move_y, move_x):
        robot_old_y, robot_old_x = self.find_robot() 
        robot_new_y = robot_old_y + move_y
        robot_new_x = robot_old_x + move_x

        if self.map[robot_new_y][robot_new_x] == 1:
            return

        if self.map[robot_new_y][robot_new_x] in [3, 5]:
            box_new_y = robot_new_y + move_y
            box_new_x = robot_new_x + move_x

            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
                return

            self.map[robot_new_y][robot_new_x] -= 3
            self.map[box_new_y][box_new_x] += 3

        self.map[robot_old_y][robot_old_x] -= 4
        self.map[robot_new_y][robot_new_x] += 4
```

Метод имеет довольно много различных этапов, поэтому давайте рассмотрим каждый из них по очереди:

### Старое и новое местоположение робота

```python
        robot_old_y, robot_old_x = self.find_robot() 
        robot_new_y = robot_old_y + move_y
        robot_new_x = robot_old_x + move_x
```

Сначала метод вызывает `find_robot`, чтобы найти текущее местоположение робота перед ходом. Это сохраняется в переменных `robot_old_y` и `robot_old_x`.

Затем новое местоположение робота после предполагаемого хода сохраняется в переменных `robot_new_y` и `robot_new_x`. Новые координаты можно легко вычислить, добавив значения, переданные в качестве аргументов, к старому местоположению робота, поскольку оба содержали вертикальные и горизонтальные значения.

### Ударился ли робот о стену?

```python
        if self.map[robot_new_y][robot_new_x] == 1:
            return
```

Оператор `if` выше заботится о ситуации, когда робот ударился бы о стену в результате хода. Помните, 1 была позицией клетки стены в списке изображений. Это не разрешено, поэтому метод просто возвращается без дальнейших действий.

### Перемещение ящика

```python
        if self.map[robot_new_y][robot_new_x] in [3, 5]:
            box_new_y = robot_new_y + move_y
            box_new_x = robot_new_x + move_x

            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
                return

            self.map[robot_new_y][robot_new_x] -= 3
            self.map[box_new_y][box_new_x] += 3
```

Если новое предполагаемое местоположение робота содержит число 3 (ящик сам по себе) или число 5 (ящик на целевой клетке), робот пытается переместить ящик на следующую клетку вдоль. Для этой цели нам нужны две новые переменные: `box_new_y` и `box_new_x`, которые содержат местоположение ящика после хода.

Аналогично роботу, ящик не может быть перемещён на клетку стены с идентификатором 1. Ящик также не может переместиться на другой ящик или целевую клетку с ящиком на ней. Если это произошло бы в результате хода, метод снова просто возвращается, не внося никаких изменений в сетку.

В любом другом случае ящик может двигаться. Значение в текущем местоположении ящика на сетке уменьшается на 3, а значение в его новом местоположении на сетке увеличивается на 3. Благодаря умному упорядочению элементов в списке `images` это работает правильно как когда задействованы клетки пола, так и целевые клетки.

### Перемещение робота

```python
        self.map[robot_old_y][robot_old_x] -= 4
        self.map[robot_new_y][robot_new_x] += 4
```

Если выполнение метода достигло этой точки без возврата, пришло время переместить и робота. Процедура аналогична перемещению ящика, но значение, вычитаемое из и добавляемое к соответствующим местоположениям в сетке, на этот раз равно 4. Это обеспечивает, опять же через умное упорядочение элементов в списке `images`, что конечный результат на сетке правильный как когда в ходе задействованы клетки пола, так и целевые клетки.

## Рефакторинг?

Использование только сетки для хранения состояния игры во все времена очень удобно в том смысле, что только одна переменная постоянно задействована во всём процессе, и относительно легко обновлять состояние сетки через простые сложения и вычитания.

Недостаток в том, что может быть немного трудно понять программный код игры. Если бы кто-то незнакомый с используемой логикой увидел эту следующую строку кода, они, вероятно, были бы немного озадачены:

```python
            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
```

Фрагмент кода выше использует _магические числа_ для представления клеток в сетке. Любой, читающий код, должен был бы знать, что 1 означает стену, 3 означает ящик, а 5 означает ящик на целевой клетке.

Строки, включающие умные вычитания и сложения, выглядели бы ещё более озадачивающими:

```python
            self.map[robot_new_y][robot_new_x] -= 3
```

Число 3 означало ящик только что ранее, но теперь оно вычитается из значения клетки на сетке. Это работает в контексте нашей схемы нумерации, поскольку изменяет ящик (3) в обычную клетку пола (0) или целевую клетку с ящиком (5) в пустую целевую клетку (2), но понимание этого требует предварительного знания используемой схемы нумерации.

Мы могли бы упростить чтение кода для любого, _рефакторив_ нашу реализацию. Это означает улучшение структуры и читаемости кода. Один способ достичь этого — использовать названия клеток вместо чисел от 0 до 6, хотя это всё ещё не объяснило бы, как и почему числа можно складывать и вычитать, сохраняя при этом целостность сетки.

Делая программный код действительно доступным, вероятно, потребовался бы гораздо более фундаментально трансформационный рефакторинг. Например, мы могли бы сохранить структуру игровой карты в одном месте и хранить местоположения робота и ящиков в какой-то отдельной структуре данных. Недостаток _этого_ заключается в том, что это, вероятно, привело бы к гораздо большему количеству кода, а внутренняя структура игры стала бы гораздо сложнее.

Рефакторинг и качество кода — это предмет некоторых последующих курсов, таких как _Методы разработки программного обеспечения_ и _Программная инженерия_.