---
path: '/ru/part-14/3-finishing-the-game'
title: 'Завершение игры'
hidden: false
---

Наша игра уже довольно функциональна, поэтому пришло время добавить к ней некоторые завершающие штрихи. Мы добавим счётчик для отображения сделанных ходов, опцию для начала новой игры и закрытия игры с помощью клавиатурного ввода, и уведомление о том, когда игрок успешно решает игру.

## Счётчик ходов

Счётчик ходов у нижнего края игрового окна отображает количество ходов, сделанных игроком до сих пор. Это можно использовать для поиска решения с наименьшим количеством ходов.

Счётчик требует некоторых изменений в коде. Сначала давайте изменим конструктор так, чтобы было достаточно места для счётчика и чтобы у нас был подходящий шрифт в нашем распоряжении для рисования текста:

```python
    def __init__(self):
        ...
        self.window = pygame.display.set_mode((window_width, window_height + self.scale))

        self.game_font = pygame.font.SysFont("Arial", 24)
        ...
```

Счётчик ходов инициализируется нулём в начале игры. Каждый ход увеличивает его на единицу:

```python
    def new_game(self):
        ...
        self.moves = 0
```

```python
    def move(self, move_y, move_x):
        ...
        self.moves += 1

```

Каждый раз, когда содержимое окна обновляется, количество сделанных ходов, показанное на экране, также должно обновляться:

```python
    def draw_window(self):
        ...
        game_text = self.game_font.render("Moves: " + str(self.moves), True, (255, 0, 0))
        self.window.blit(game_text, (25, self.height * self.scale + 10))
        ...
```

## Новая игра и выход из игры

Далее давайте добавим команды клавиатуры для начала новой игры с F2 и выхода из игры с Esc. Обе довольно легко реализовать:

```python
    def check_events(self):
        ...
                if event.key == pygame.K_F2:
                    self.new_game()
                if event.key == pygame.K_ESCAPE:
                    exit()
        ...
```

Мы также должны добавить информацию об этой функциональности для игрока:

```python
    def draw_window(self):
        ...
        game_text = self.game_font.render("F2 = new game", True, (255, 0, 0))
        self.window.blit(game_text, (200, self.height * self.scale + 10))

        game_text = self.game_font.render("Esc = exit game", True, (255, 0, 0))
        self.window.blit(game_text, (400, self.height * self.scale + 10))
        ...
```

## Решение игры

Игрок решил игру, когда каждый ящик находится в одной из целевых клеток. Следующий метод заботится о проверке этого:

```python
    def game_solved(self):
        for y in range(self.height):
            for x in range(self.width):
                if self.map[y][x] in [2, 6]:
                    return False
        return True
```

Метод проходит через все клетки в игровой сетке. Если любая из клеток является 2 (пустая целевая клетка) или 6 (робот в целевой клетке), игра ещё не решена, поэтому метод возвращает `False`. Если такой клетки нет в сетке, все целевые клетки должны быть заняты ящиками, игра решена, и метод возвращает `True`.

Если игрок решает игру, мы должны отобразить соответствующее сообщение методом `draw_window`:

```python
    def draw_window(self):
        ...
        if self.game_solved():
            game_text = self.game_font.render("Congratulations, you solved the game!", True, (255, 0, 0))
            game_text_x = self.scale * self.width / 2 - game_text.get_width() / 2
            game_text_y = self.scale * self.height / 2 - game_text.get_height() / 2
            pygame.draw.rect(self.window, (0, 0, 0), (game_text_x, game_text_y, game_text.get_width(), game_text.get_height()))
            self.window.blit(game_text, (game_text_x, game_text_y))
        ...
```

Для полноты давайте также изменим метод `move` так, чтобы игрок больше не мог двигаться, когда он решил игру:

```python
    def move(self, move_y, move_x):
        if self.game_solved():
            return
        ...
```

Игрок по-прежнему может видеть игровую сетку и конечное состояние игры, однако.

## Подсказка для тестирования

При разработке игр часто случается, что вы хотели бы проверить, что происходит в какой-то более поздней ситуации в игре. Например, в этой игре момент, когда игра решена, является одной из таких ситуаций.

Может быть трудно протестировать правильное функционирование такой ситуации, поскольку вам обычно пришлось бы решить игру, чтобы достичь этой точки в игре. Как программисты мы можем сделать некоторые временные облегчения в наших играх, чтобы упростить их тестирование. Например, мы могли бы добавить следующее, чтобы временно упростить решение игры:

```python
    def game_solved(self):
        return True
```

Теперь метод всегда возвращает `True`, что означает, что игра "решена" с самого начала. Это упрощает проверку того, что уведомление в конце выглядит хорошо и игрок больше не может двигаться по сетке после решения. Когда эта функциональность тщательно протестирована, мы можем отменить изменения.

## Ваша игра на GitHub?

Игра теперь закончена. Если вы хотите простой способ поиграть с кодом и изображениями, вы можете получить исходный код с GitHub:

* [https://github.com/moocfi/sokoban](https://github.com/moocfi/sokoban)

GitHub — популярное место для многих видов программных проектов. Его можно использовать для хранения исходного кода и других материалов всех ваших собственных программных проектов, и ваша программа будет затем поддерживаться через систему контроля версий git, и её можно легко поделиться с другими. Вы станете очень знакомы с git и GitHub, если продолжите изучение других курсов программирования mooc.fi.

## Сколько ходов требуется?

Сетка в этой игре довольно мала, но игра не так проста. Первый вызов — просто пройти игру, но следующий этап — попробовать сделать это с как можно меньшим количеством ходов. Насколько короток самый короткий путь к решению?

Поиск кратчайшего возможного решения — не простая задача вообще, но есть и вычислительные решения для этого. Они являются одним из предметов курса _Структуры данных и алгоритмы_.